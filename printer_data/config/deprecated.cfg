[gcode_macro _INIT_SVF_KEYS]
description: Ensure all required SVF keys exist (and remove invalid ones)
variable_macro_html: "?tInitializes, and or repairs the offsets keys saved in the save variables file.?p_INIT_SVF_KEYS "
gcode:
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set entries = namespace(to_check=[]) %}
  {% set missing  = [] %}
  {% set repaired = [] %}
  {% set removed  = [] %}
  {% set warnings = [] %}

  {% set drift_key   = p['gcode_macro _TC_ADJUST_TTBZ_DRIFT'].get('key_name', 'drift') %}
  {% set probe_keys  = ['x', 'y', 'z', 'ttbz', drift_key|string] if (tcs.get('ttbz_drift_autoadjust', {}) != {}) else ['x', 'y', 'z', 'ttbz'] %}
  {% set tool_keys   = ['x', 'y', 'z', 'probe'] if tcs.get('enable_probe_calibration', True) else ['x', 'y', 'z']  %}

  #————|  Build list of SVF entries to check
  {% set _ = entries.to_check.append({'entry_name':'probe_position','entry_keys':probe_keys}) %}
  {% for name in p.toolchanger.tool_names %}
    {% set _   = entries.to_check.append({'entry_name':'offsets_' ~ name|replace('tool ','')|lower,'entry_keys':tool_keys}) %}
  {% endfor %}

  #————|  If offset history is enabled, also add that to check
  {% if tcs.get('offset_history', {}) != {} %}
    {% set _ = entries.to_check.append({'entry_name':'offsets_history_probe','entry_keys':probe_keys,'list_values':True}) %}
    {% for name in p.toolchanger.tool_names %}
      {% set _   = entries.to_check.append({'entry_name':'offsets_history_' ~ name|replace('tool ','')|lower,'entry_keys':tool_keys,'list_values':True}) %}
    {% endfor %}
  {% endif %}
  
  #————|  Iterate every SVF entry
  {% for e in entries.to_check %}
    {% set dict_name = e.entry_name %}
    {% set allowed   = e.entry_keys %}
    {% set is_list   = e.get('list_values', False) %}
    {% set cur       = svf.get(dict_name, {}) %}
    {% if cur is not mapping %}{% set cur = {} %}{% endif %}
    {% set new       = cur.copy() %}

    #————| Add any missing entry_keys
    {% for k in allowed %}
      {% if k not in new %}
        {% if is_list %}
          {% set _ = new.update({k: []}) %}
        {% else %}
          {% set _ = new.update({k: 0.0}) %}
        {% endif %}
        {% set _ = missing.append(dict_name ~ '.' ~ k) %}
      {% endif %}
    {% endfor %}

    #————| Remove any extras
    {% for k in new.keys()|list %}
      {% if k not in allowed %}
        {% if tcs.get('svf_remove_invalid', True) %}{% set _ = new.pop(k) %}{% endif %}
        {% set _ = removed.append(dict_name ~ '.' ~ k) %}
      {% endif %}
    {% endfor %}

    #————| Ensure lists are lists.
    {% if is_list %}
      {% for k in allowed %}
        {% if new[k] is not sequence %}
          {% set _ = new.update({k: []}) %}
          {% set _ = repaired.append(dict_name ~ '.' ~ k ~ ' reset to list') %}
        {% endif %}
      {% endfor %}
    {% endif %}

    #————| Save back if changed
    {% if new != cur %}
      SAVE_VARIABLE VARIABLE={dict_name} VALUE="{new}"
      #{% set _ = repaired.append(dict_name) %}
    {% endif %}

    #————| Warn if this is the first tool and any axis != 0
    {% if dict_name == 'offsets_' ~ p.toolchanger.tool_names[0]|replace('tool ','')|lower and
          (new.x|default(0)|float != 0 or new.y|default(0)|float != 0 or new.z|default(0)|float != 0) %}
      {% set _ = warnings.append('Tool 0 offsets should always be (0,0,0)!') %}
    {% endif %}
  {% endfor %}

  #————|  Final console report
  {% if missing|length !=0 or removed|length!=0 or repaired|length!=0 or warnings|length!=0 %}
    {% set out = [] %}
    {% set _ = out.append("?s0?t?mUpdated your ?bsave variables file?b") %}
    {% if repaired %} {% set _ = out.append("?s2?t?m?cRepaired the following dicts:?c?n  -> " ~ repaired|join("?n  -> ")) %}{% endif %}
    {% if missing %}  {% set _ = out.append("?s0?t?m?cAdded the missing keys:?c?n  -> " ~ missing|join("?n  -> ")) %}{% endif %}
    {% if removed %}  {% set _ = out.append("?s4?t?m?cRemoved:?c?n  -> " ~ removed|join("?n  -> ")) %}{% endif %}
    {% if warnings %} {% set _ = out.append("?s4?t?m?cWarning: ?c" ~ warnings|join("?n  -> ")) %}{% endif %}
    _UNIFIED_RESPOND MSG="{macro_html ~ out|join('')}"
  {% endif %}












[gcode_macro TC_ADJUST_Z_ALL]
description: Adjust all per-tool probe Z offsets, current z and global ttbz with a UI
variable_last_adjust: 0.0
gcode:
  #───< short/settings
  {% set p          = printer %}
  {% set svf        = p.save_variables.variables %}
  {% set tcs        = p['gcode_macro _toolchanger_settings'] %}
  {% set r_save     = (tcs.get('offset_calibration', {})).get('value_rounding', 3)|int %}
  {% set amount     = params.get('AMOUNT', 0)|float %}
  {% set curz       = printer.toolhead.position[2] %}#printer.gcode_move.gcode_position[2] %}
  {% set increments = [0.05, 0.01, 0.005, -0.05, -0.01, -0.005] %}  
  #───< macro/short helpers
  {% macro ui(txt) -%}       RESPOND TYPE=command MSG="action:prompt_{txt}"           {%- endmacro %}
  {% macro off_key(tname)-%} {'offsets_' ~ tname|replace('tool ', '')|lower}          {%- endmacro %}
  
  {% if amount %}
    #───< move by that amount
    SAVE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
    G91
    G0 Z{amount} #───< move by amount, convince printer we didnt.
    G90
    SET_KINEMATIC_POSITION Z={curz}
    RESTORE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
    #───< update every probe in our offsets 
    {% for tname in p.toolchanger.tool_names if off_key(tname) in svf %}
      {% set offsets    = svf.get(off_key(tname), {}) %}
      {% set probe_val  = offsets.get('probe', -1) %}
      {% set _          = offsets.update({'probe': (probe_val - amount)|round(r_save)}) %}
      SAVE_VARIABLE VARIABLE={off_key(tname)} VALUE="{offsets}"
    {% endfor %}
    #───< update our probes ttbz offset shift
    {% set pp        = svf.get('probe_position', {}) %}
    {% set c_ttbz    = pp.get('ttbz', 0) %}
    {% set _         = pp.update({'ttbz': (c_ttbz - amount)|round(r_save)}) %}
    SAVE_VARIABLE VARIABLE=probe_position VALUE="{pp}"

  #───< regular invoke, open UI
  {% else %}
    {ui('begin Adjust Z Probe Offsets')}
    {ui('text This will adjust:')}
    {ui('text  > all probe_offsets')}
    {ui('text  > the current z position')}
    {ui('text  > calibration probes ttbz offset')}
    #───< incremental buttons
    {% for start in [0, increments|length // 2] %}
      {ui('button_group_start')}
      {% for i in range(start, start + increments|length // 2) %}
        {% set val   = increments[i] %}
        {% set sign  = '+' if val > 0 else '' %}
        {ui('button ' ~ sign ~ val ~ '|TC_ADJUST_Z_ALL AMOUNT=' ~ val ~ '|' ~ 'secondary')}
      {% endfor %}
      {ui('button_group_end')}
    {% endfor %}
    {ui('footer_button CLOSE|RESPOND TYPE=command MSG=action:prompt_end')}
    {ui('show')}
  {% endif %}








###########################################################################################################################################
###   Below is a macro sequency to find the stdt deviations of your nudge and xyz endstops (compared to the nudge ofc)   ##################
###########################################################################################################################################
#####################################################################
#   TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY
#####################################################################
[gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY]
description: Compares nudge repeatability vs. homed endstop repeatability
variable_edge_offset: 15
variable_grid_count: 3
###################### storage variables used for the calculated stuffies
variable_homed_pos: ""
variable_unhomed_pos: ""
gcode:
  {% if "xyz" not in p.toolhead.homed_axes %}
      RESPOND MSG="Printer must be homed before finding tool offsets."
  {% else %}
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=unhomed VALUE=0
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=homed VALUE=0
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=unhomed_pos VALUE='""'
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=homed_pos VALUE='""'
    RESPOND MSG="Starting measurement loop..."
    _TC_CALIBRATION_PROBE_ACCURACY_LOOP
  {% endif %}

#####################################################################
#   _TC_CALIBRATION_PROBE_ACCURACY_LOOP
#####################################################################
[gcode_macro _TC_CALIBRATION_PROBE_ACCURACY_LOOP]
variable_homed: 0
variable_unhomed: 0
gcode:
  {% set grid_count = p["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"].grid_count|int %}
  {% set edge_offset = p["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"].edge_offset|float %}
  {% set max_x = p.configfile.config["stepper_x"]["position_max"]|float - edge_offset %}
  {% set min_x = p.configfile.config["stepper_x"]["position_min"]|float + edge_offset %}
  {% set max_y = p.configfile.config["stepper_y"]["position_max"]|float - edge_offset %}
  {% set min_y = p.configfile.config["stepper_y"]["position_min"]|float + edge_offset %}
  {% set feed = p.configfile.config["toolchanger"]["params_fast_speed"]|int %}
  {% set total_points = grid_count * grid_count %}

  {% if unhomed < total_points %}
    {% set x = min_x + (max_x - min_x) * (unhomed % grid_count) / (grid_count - 1) %}
    {% set y = min_y + (max_y - min_y) * (unhomed // grid_count) / (grid_count - 1) %}
    RESPOND MSG="Unhomed iteration {unhomed} at X={x|round(1)} Y={y|round(1)}"
    G0 X{x} Y{y} F{feed}
    {% set atn = p.tool_probe_endstop.active_tool_number|int %}
    {% set ttbz = p.configfile.settings.tools_calibrate.trigger_to_bottom_z|float %}
    {% if atn == -1 %}
      RESPOND MSG="<span class='error--text'{macro_html}<span class='warning--text'&apos;tool_probe_endstop.active_tool_number&apos; is {atn} (not valid) run &apos;DETECT_ACTIVE_TOOLPROBE&apos; to update it.'>No active tool</span>"
    {% elif atn == 0 %} # If we are T0
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_LOCATE_SENSOR
    {% else %}
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_CALIBRATE_TOOL_OFFSET
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=unhomed VALUE={unhomed+1}
    {% if p.toolchanger.params_debug_toolchanger %}
      RESPOND MSG="calling _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP"
    {% endif %}
    UPDATE_DELAYED_GCODE ID=_TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP DURATION=1

  {% elif homed < total_points %}
    {% set x = min_x + (max_x - min_x) * (homed % grid_count) / (grid_count - 1) %}
    {% set y = min_y + (max_y - min_y) * (homed // grid_count) / (grid_count - 1) %}
    RESPOND MSG="Homed iteration {homed} at X={x|round(1)} Y={y|round(1)}"
    G0 X{x} Y{y} F{feed}
    G28 X Y
    {% set atn = p.tool_probe_endstop.active_tool_number|int %}
    {% set ttbz = p.configfile.settings.tools_calibrate.trigger_to_bottom_z|float %}
    {% if atn == -1 %}
      RESPOND MSG="<span class='error--text'{macro_html}<span class='warning--text'&apos;tool_probe_endstop.active_tool_number&apos; is {atn} (not valid) run &apos;DETECT_ACTIVE_TOOLPROBE&apos; to update it.'>No active tool</span>"
    {% elif atn == 0 %} # If we are T0
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_LOCATE_SENSOR
    {% else %}
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_CALIBRATE_TOOL_OFFSET
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=homed VALUE={homed+1}
    {% if p.toolchanger.params_debug_toolchanger %}
      RESPOND MSG="calling _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP"
    {% endif %}
    UPDATE_DELAYED_GCODE ID=_TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP DURATION=1

  {% else %}
    RESPOND MSG="All measurements done. Analyzing..."
    _MOVE_TO_CENTER
    _TC_NUDGE_ANALYZE_AND_PRINT
  {% endif %}

#####################################################################
#   _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP
#####################################################################
[delayed_gcode _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP]
gcode:
  {% if printer.toolchanger.params_debug_toolchanger %}
  RESPOND MSG="_TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP start"
  {% endif %}
  
  {% set loop = printer["gcode_macro _TC_CALIBRATION_PROBE_ACCURACY_LOOP"] %}
  {% set parent = printer["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"] %}
  {% set current_homed = loop.homed|int %}
  {% set current_unhomed = loop.unhomed|int %}
  {% set grid_count = parent.grid_count|int %}
  {% set current_homed_pos_string = parent.homed_pos|string %}
  {% set current_unhomed_pos_string = parent.unhomed_pos|string %}
  {% set last_x = printer.tools_calibrate.last_x_result|float|round(4) %}
  {% set last_y = printer.tools_calibrate.last_y_result|float|round(4) %}
  {% set last_z = printer.tools_calibrate.last_z_result|float|round(4) %}
  {% set last_x_string = last_x|string %}
  {% set last_y_string = last_y|string %}
  {% set last_z_string = last_z|string %}

  ######## horrors beyond comprehension follow after this point. 
  ######## we are converting our whole array of coordinates into a string and making a really long string of coordinate points just to later split it.
  {% if current_unhomed < grid_count * grid_count %}
    {% set stringAddition = current_unhomed_pos_string|string + "u_x" + last_x_string + "y" + last_y_string + "z" + last_z_string + ";" %}
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=unhomed_pos VALUE='"{stringAddition}"'
  {% elif current_homed < grid_count * grid_count %}
    {% set stringAddition = current_homed_pos_string|string + "h_x" + last_x_string + "y" + last_y_string + "z" + last_z_string + ";" %}
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=homed_pos VALUE='"{stringAddition}"'
  {% endif %}
  {% if printer.toolchanger.params_debug_toolchanger %}
  RESPOND MSG="calling _TC_CALIBRATION_PROBE_ACCURACY_LOOP"
  {% endif %}
  _TC_CALIBRATION_PROBE_ACCURACY_LOOP

#####################################################################
#   _TC_NUDGE_ANALYZE_AND_PRINT
#####################################################################
[gcode_macro _TC_NUDGE_ANALYZE_AND_PRINT]
gcode:
    {% if printer.toolchanger.params_debug_toolchanger %}
      RESPOND MSG="_TC_NUDGE_ANALYZE_AND_PRINT start"
    {% endif %}
  {% set parent = printer["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"] %}
  {% set unhomed_str = parent.unhomed_pos|string %}
  {% set homed_str = parent.homed_pos|string %}

  {% set nohomo_ns = namespace(sum_x=0.0, sum_y=0.0, sum_z=0.0, sum_sqr_x=0.0, sum_sqr_y=0.0, sum_sqr_z=0.0, count=0) %}
  {% set homo_ns = namespace(sum_x=0.0, sum_y=0.0, sum_z=0.0, sum_sqr_x=0.0, sum_sqr_y=0.0, sum_sqr_z=0.0, count=0) %}

  ######## le string horrors
  {% for entry in unhomed_str.split(';') %}
    {% if entry.startswith("u_") %}
      {% set x_idx = entry.find('x') %}
      {% set y_idx = entry.find('y') %}
      {% set z_idx = entry.find('z') %}
      {% if x_idx != -1 and y_idx != -1 and z_idx != -1 %}
        {% set x_val = entry[x_idx+1:y_idx]|float %}
        {% set y_val = entry[y_idx+1:z_idx]|float %}
        {% set z_val = entry[z_idx+1:]|float %}
        {% set nohomo_ns.sum_x = nohomo_ns.sum_x + x_val %}
        {% set nohomo_ns.sum_y = nohomo_ns.sum_y + y_val %}
        {% set nohomo_ns.sum_z = nohomo_ns.sum_z + z_val %}
        {% set nohomo_ns.sum_sqr_x = nohomo_ns.sum_sqr_x + x_val*x_val %}
        {% set nohomo_ns.sum_sqr_y = nohomo_ns.sum_sqr_y + y_val*y_val %}
        {% set nohomo_ns.sum_sqr_z = nohomo_ns.sum_sqr_z + z_val*z_val %}
        {% set nohomo_ns.count = nohomo_ns.count + 1 %}
      {% endif %}
    {% endif %}
  {% endfor %}

  {% for entry in homed_str.split(';') %}
    {% if entry.startswith("h_") %}
      {% set x_idx = entry.find('x') %}
      {% set y_idx = entry.find('y') %}
      {% set z_idx = entry.find('z') %}
      {% if x_idx != -1 and y_idx != -1 and z_idx != -1 %}
        {% set x_val = entry[x_idx+1:y_idx]|float %}
        {% set y_val = entry[y_idx+1:z_idx]|float %}
        {% set z_val = entry[z_idx+1:]|float %}
        {% set homo_ns.sum_x = homo_ns.sum_x + x_val %}
        {% set homo_ns.sum_y = homo_ns.sum_y + y_val %}
        {% set homo_ns.sum_z = homo_ns.sum_z + z_val %}
        {% set homo_ns.sum_sqr_x = homo_ns.sum_sqr_x + x_val*x_val %}
        {% set homo_ns.sum_sqr_y = homo_ns.sum_sqr_y + y_val*y_val %}
        {% set homo_ns.sum_sqr_z = homo_ns.sum_sqr_z + z_val*z_val %}
        {% set homo_ns.count = homo_ns.count + 1 %}
      {% endif %}
    {% endif %}
  {% endfor %}

  ######## the nudge knows where it is because it knows where it isnt, and by substracting where it is from where it isnt,
  {% set un_mean_x = nohomo_ns.sum_x / nohomo_ns.count %}
  {% set un_mean_y = nohomo_ns.sum_y / nohomo_ns.count %}
  {% set un_mean_z = nohomo_ns.sum_z / nohomo_ns.count %}
  {% set un_stdev_x = ((nohomo_ns.sum_sqr_x / nohomo_ns.count) - un_mean_x*un_mean_x)**0.5 %}
  {% set un_stdev_y = ((nohomo_ns.sum_sqr_y / nohomo_ns.count) - un_mean_y*un_mean_y)**0.5 %}
  {% set un_stdev_z = ((nohomo_ns.sum_sqr_z / nohomo_ns.count) - un_mean_z*un_mean_z)**0.5 %}

  ######## or where it isnt from where it is (whichever is greater) and arriving at a position where it wasnt (and is now)
  {% set ho_mean_x = homo_ns.sum_x / homo_ns.count %}
  {% set ho_mean_y = homo_ns.sum_y / homo_ns.count %}
  {% set ho_mean_z = homo_ns.sum_z / homo_ns.count %}
  {% set ho_stdev_x = ((homo_ns.sum_sqr_x / homo_ns.count) - ho_mean_x*ho_mean_x)**0.5 %}
  {% set ho_stdev_y = ((homo_ns.sum_sqr_y / homo_ns.count) - ho_mean_y*ho_mean_y)**0.5 %}
  {% set ho_stdev_z = ((homo_ns.sum_sqr_z / homo_ns.count) - ho_mean_z*ho_mean_z)**0.5 %}

  RESPOND MSG="-- Nudge (UNHOMED) --"
  RESPOND MSG="Mean X={un_mean_x|round(4)}, Y={un_mean_y|round(4)}, Z={un_mean_z|round(4)}"
  RESPOND MSG="Std  X={un_stdev_x|round(5)}, Y={un_stdev_y|round(5)}, Z={un_stdev_z|round(5)}"

  RESPOND MSG="-- Nudge (HOMED) --"
  RESPOND MSG="Mean X={ho_mean_x|round(4)}, Y={ho_mean_y|round(4)}, Z={ho_mean_z|round(4)}"
  RESPOND MSG="Std  X={ho_stdev_x|round(5)}, Y={ho_stdev_y|round(5)}, Z={ho_stdev_z|round(5)}"

  RESPOND MSG="Done! Compare unhomed vs. homed stdev to gauge endstop accuracy."  
  ######## it arrives where it wasnt.

###########################################################################################################################################
###########################################################################################################################################
###########################################################################################################################################