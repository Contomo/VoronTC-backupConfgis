[gcode_macro _INIT_SVF_KEYS]
description: Ensure all required SVF keys exist (and remove invalid ones)
variable_macro_html: "?tInitializes, and or repairs the offsets keys saved in the save variables file.?p_INIT_SVF_KEYS "
gcode:
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set entries = namespace(to_check=[]) %}
  {% set missing  = [] %}
  {% set repaired = [] %}
  {% set removed  = [] %}
  {% set warnings = [] %}

  {% set drift_key   = p['gcode_macro _TC_ADJUST_TTBZ_DRIFT'].get('key_name', 'drift') %}
  {% set probe_keys  = ['x', 'y', 'z', 'ttbz', drift_key|string] if (tcs.get('ttbz_drift_autoadjust', {}) != {}) else ['x', 'y', 'z', 'ttbz'] %}
  {% set tool_keys   = ['x', 'y', 'z', 'probe'] if tcs.get('enable_probe_calibration', True) else ['x', 'y', 'z']  %}

  #————|  Build list of SVF entries to check
  {% set _ = entries.to_check.append({'entry_name':'probe_position','entry_keys':probe_keys}) %}
  {% for name in p.toolchanger.tool_names %}
    {% set _   = entries.to_check.append({'entry_name':'offsets_' ~ name|replace('tool ','')|lower,'entry_keys':tool_keys}) %}
  {% endfor %}

  #————|  If offset history is enabled, also add that to check
  {% if tcs.get('offset_history', {}) != {} %}
    {% set _ = entries.to_check.append({'entry_name':'offsets_history_probe','entry_keys':probe_keys,'list_values':True}) %}
    {% for name in p.toolchanger.tool_names %}
      {% set _   = entries.to_check.append({'entry_name':'offsets_history_' ~ name|replace('tool ','')|lower,'entry_keys':tool_keys,'list_values':True}) %}
    {% endfor %}
  {% endif %}
  
  #————|  Iterate every SVF entry
  {% for e in entries.to_check %}
    {% set dict_name = e.entry_name %}
    {% set allowed   = e.entry_keys %}
    {% set is_list   = e.get('list_values', False) %}
    {% set cur       = svf.get(dict_name, {}) %}
    {% if cur is not mapping %}{% set cur = {} %}{% endif %}
    {% set new       = cur.copy() %}

    #————| Add any missing entry_keys
    {% for k in allowed %}
      {% if k not in new %}
        {% if is_list %}
          {% set _ = new.update({k: []}) %}
        {% else %}
          {% set _ = new.update({k: 0.0}) %}
        {% endif %}
        {% set _ = missing.append(dict_name ~ '.' ~ k) %}
      {% endif %}
    {% endfor %}

    #————| Remove any extras
    {% for k in new.keys()|list %}
      {% if k not in allowed %}
        {% if tcs.get('svf_remove_invalid', True) %}{% set _ = new.pop(k) %}{% endif %}
        {% set _ = removed.append(dict_name ~ '.' ~ k) %}
      {% endif %}
    {% endfor %}

    #————| Ensure lists are lists.
    {% if is_list %}
      {% for k in allowed %}
        {% if new[k] is not sequence %}
          {% set _ = new.update({k: []}) %}
          {% set _ = repaired.append(dict_name ~ '.' ~ k ~ ' reset to list') %}
        {% endif %}
      {% endfor %}
    {% endif %}

    #————| Save back if changed
    {% if new != cur %}
      SAVE_VARIABLE VARIABLE={dict_name} VALUE="{new}"
      #{% set _ = repaired.append(dict_name) %}
    {% endif %}

    #————| Warn if this is the first tool and any axis != 0
    {% if dict_name == 'offsets_' ~ p.toolchanger.tool_names[0]|replace('tool ','')|lower and
          (new.x|default(0)|float != 0 or new.y|default(0)|float != 0 or new.z|default(0)|float != 0) %}
      {% set _ = warnings.append('Tool 0 offsets should always be (0,0,0)!') %}
    {% endif %}
  {% endfor %}

  #————|  Final console report
  {% if missing|length !=0 or removed|length!=0 or repaired|length!=0 or warnings|length!=0 %}
    {% set out = [] %}
    {% set _ = out.append("?s0?t?mUpdated your ?bsave variables file?b") %}
    {% if repaired %} {% set _ = out.append("?s2?t?m?cRepaired the following dicts:?c?n  -> " ~ repaired|join("?n  -> ")) %}{% endif %}
    {% if missing %}  {% set _ = out.append("?s0?t?m?cAdded the missing keys:?c?n  -> " ~ missing|join("?n  -> ")) %}{% endif %}
    {% if removed %}  {% set _ = out.append("?s4?t?m?cRemoved:?c?n  -> " ~ removed|join("?n  -> ")) %}{% endif %}
    {% if warnings %} {% set _ = out.append("?s4?t?m?cWarning: ?c" ~ warnings|join("?n  -> ")) %}{% endif %}
    _UNIFIED_RESPOND MSG="{macro_html ~ out|join('')}"
  {% endif %}












[gcode_macro TC_ADJUST_Z_ALL]
description: Adjust all per-tool probe Z offsets, current z and global ttbz with a UI
variable_last_adjust: 0.0
gcode:
  #───< short/settings
  {% set p          = printer %}
  {% set svf        = p.save_variables.variables %}
  {% set tcs        = p['gcode_macro _toolchanger_settings'] %}
  {% set r_save     = (tcs.get('offset_calibration', {})).get('value_rounding', 3)|int %}
  {% set amount     = params.get('AMOUNT', 0)|float %}
  {% set curz       = printer.toolhead.position[2] %}#printer.gcode_move.gcode_position[2] %}
  {% set increments = [0.05, 0.01, 0.005, -0.05, -0.01, -0.005] %}  
  #───< macro/short helpers
  {% macro ui(txt) -%}       RESPOND TYPE=command MSG="action:prompt_{txt}"           {%- endmacro %}
  {% macro off_key(tname)-%} {'offsets_' ~ tname|replace('tool ', '')|lower}          {%- endmacro %}
  
  {% if amount %}
    #───< move by that amount
    SAVE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
    G91
    G0 Z{amount} #───< move by amount, convince printer we didnt.
    G90
    SET_KINEMATIC_POSITION Z={curz}
    RESTORE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
    #───< update every probe in our offsets 
    {% for tname in p.toolchanger.tool_names if off_key(tname) in svf %}
      {% set offsets    = svf.get(off_key(tname), {}) %}
      {% set probe_val  = offsets.get('probe', -1) %}
      {% set _          = offsets.update({'probe': (probe_val - amount)|round(r_save)}) %}
      SAVE_VARIABLE VARIABLE={off_key(tname)} VALUE="{offsets}"
    {% endfor %}
    #───< update our probes ttbz offset shift
    {% set pp        = svf.get('probe_position', {}) %}
    {% set c_ttbz    = pp.get('ttbz', 0) %}
    {% set _         = pp.update({'ttbz': (c_ttbz - amount)|round(r_save)}) %}
    SAVE_VARIABLE VARIABLE=probe_position VALUE="{pp}"

  #───< regular invoke, open UI
  {% else %}
    {ui('begin Adjust Z Probe Offsets')}
    {ui('text This will adjust:')}
    {ui('text  > all probe_offsets')}
    {ui('text  > the current z position')}
    {ui('text  > calibration probes ttbz offset')}
    #───< incremental buttons
    {% for start in [0, increments|length // 2] %}
      {ui('button_group_start')}
      {% for i in range(start, start + increments|length // 2) %}
        {% set val   = increments[i] %}
        {% set sign  = '+' if val > 0 else '' %}
        {ui('button ' ~ sign ~ val ~ '|TC_ADJUST_Z_ALL AMOUNT=' ~ val ~ '|' ~ 'secondary')}
      {% endfor %}
      {ui('button_group_end')}
    {% endfor %}
    {ui('footer_button CLOSE|RESPOND TYPE=command MSG=action:prompt_end')}
    {ui('show')}
  {% endif %}








###########################################################################################################################################
###   Below is a macro sequency to find the stdt deviations of your nudge and xyz endstops (compared to the nudge ofc)   ##################
###########################################################################################################################################
#####################################################################
#   TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY
#####################################################################
[gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY]
description: Compares nudge repeatability vs. homed endstop repeatability
variable_edge_offset: 15
variable_grid_count: 3
###################### storage variables used for the calculated stuffies
variable_homed_pos: ""
variable_unhomed_pos: ""
gcode:
  {% if "xyz" not in p.toolhead.homed_axes %}
      RESPOND MSG="Printer must be homed before finding tool offsets."
  {% else %}
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=unhomed VALUE=0
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=homed VALUE=0
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=unhomed_pos VALUE='""'
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=homed_pos VALUE='""'
    RESPOND MSG="Starting measurement loop..."
    _TC_CALIBRATION_PROBE_ACCURACY_LOOP
  {% endif %}

#####################################################################
#   _TC_CALIBRATION_PROBE_ACCURACY_LOOP
#####################################################################
[gcode_macro _TC_CALIBRATION_PROBE_ACCURACY_LOOP]
variable_homed: 0
variable_unhomed: 0
gcode:
  {% set grid_count = p["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"].grid_count|int %}
  {% set edge_offset = p["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"].edge_offset|float %}
  {% set max_x = p.configfile.config["stepper_x"]["position_max"]|float - edge_offset %}
  {% set min_x = p.configfile.config["stepper_x"]["position_min"]|float + edge_offset %}
  {% set max_y = p.configfile.config["stepper_y"]["position_max"]|float - edge_offset %}
  {% set min_y = p.configfile.config["stepper_y"]["position_min"]|float + edge_offset %}
  {% set feed = p.configfile.config["toolchanger"]["params_fast_speed"]|int %}
  {% set total_points = grid_count * grid_count %}

  {% if unhomed < total_points %}
    {% set x = min_x + (max_x - min_x) * (unhomed % grid_count) / (grid_count - 1) %}
    {% set y = min_y + (max_y - min_y) * (unhomed // grid_count) / (grid_count - 1) %}
    RESPOND MSG="Unhomed iteration {unhomed} at X={x|round(1)} Y={y|round(1)}"
    G0 X{x} Y{y} F{feed}
    {% set atn = p.tool_probe_endstop.active_tool_number|int %}
    {% set ttbz = p.configfile.settings.tools_calibrate.trigger_to_bottom_z|float %}
    {% if atn == -1 %}
      RESPOND MSG="<span class='error--text'{macro_html}<span class='warning--text'&apos;tool_probe_endstop.active_tool_number&apos; is {atn} (not valid) run &apos;DETECT_ACTIVE_TOOLPROBE&apos; to update it.'>No active tool</span>"
    {% elif atn == 0 %} # If we are T0
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_LOCATE_SENSOR
    {% else %}
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_CALIBRATE_TOOL_OFFSET
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=unhomed VALUE={unhomed+1}
    {% if p.toolchanger.params_debug_toolchanger %}
      RESPOND MSG="calling _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP"
    {% endif %}
    UPDATE_DELAYED_GCODE ID=_TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP DURATION=1

  {% elif homed < total_points %}
    {% set x = min_x + (max_x - min_x) * (homed % grid_count) / (grid_count - 1) %}
    {% set y = min_y + (max_y - min_y) * (homed // grid_count) / (grid_count - 1) %}
    RESPOND MSG="Homed iteration {homed} at X={x|round(1)} Y={y|round(1)}"
    G0 X{x} Y{y} F{feed}
    G28 X Y
    {% set atn = p.tool_probe_endstop.active_tool_number|int %}
    {% set ttbz = p.configfile.settings.tools_calibrate.trigger_to_bottom_z|float %}
    {% if atn == -1 %}
      RESPOND MSG="<span class='error--text'{macro_html}<span class='warning--text'&apos;tool_probe_endstop.active_tool_number&apos; is {atn} (not valid) run &apos;DETECT_ACTIVE_TOOLPROBE&apos; to update it.'>No active tool</span>"
    {% elif atn == 0 %} # If we are T0
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_LOCATE_SENSOR
    {% else %}
      STATUS_CALIBRATING_Z
      _MOVE_OVER_PROBE
      TOOL_CALIBRATE_TOOL_OFFSET
    {% endif %}
    SET_GCODE_VARIABLE MACRO=_TC_CALIBRATION_PROBE_ACCURACY_LOOP VARIABLE=homed VALUE={homed+1}
    {% if p.toolchanger.params_debug_toolchanger %}
      RESPOND MSG="calling _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP"
    {% endif %}
    UPDATE_DELAYED_GCODE ID=_TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP DURATION=1

  {% else %}
    RESPOND MSG="All measurements done. Analyzing..."
    MOVE_TO_CENTER
    _TC_NUDGE_ANALYZE_AND_PRINT
  {% endif %}

#####################################################################
#   _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP
#####################################################################
[delayed_gcode _TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP]
gcode:
  {% if printer.toolchanger.params_debug_toolchanger %}
  RESPOND MSG="_TC_CALIBRATION_PROBE_DATA_COLLECT_LOOP start"
  {% endif %}
  
  {% set loop = printer["gcode_macro _TC_CALIBRATION_PROBE_ACCURACY_LOOP"] %}
  {% set parent = printer["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"] %}
  {% set current_homed = loop.homed|int %}
  {% set current_unhomed = loop.unhomed|int %}
  {% set grid_count = parent.grid_count|int %}
  {% set current_homed_pos_string = parent.homed_pos|string %}
  {% set current_unhomed_pos_string = parent.unhomed_pos|string %}
  {% set last_x = printer.tools_calibrate.last_x_result|float|round(4) %}
  {% set last_y = printer.tools_calibrate.last_y_result|float|round(4) %}
  {% set last_z = printer.tools_calibrate.last_z_result|float|round(4) %}
  {% set last_x_string = last_x|string %}
  {% set last_y_string = last_y|string %}
  {% set last_z_string = last_z|string %}

  ######## horrors beyond comprehension follow after this point. 
  ######## we are converting our whole array of coordinates into a string and making a really long string of coordinate points just to later split it.
  {% if current_unhomed < grid_count * grid_count %}
    {% set stringAddition = current_unhomed_pos_string|string + "u_x" + last_x_string + "y" + last_y_string + "z" + last_z_string + ";" %}
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=unhomed_pos VALUE='"{stringAddition}"'
  {% elif current_homed < grid_count * grid_count %}
    {% set stringAddition = current_homed_pos_string|string + "h_x" + last_x_string + "y" + last_y_string + "z" + last_z_string + ";" %}
    SET_GCODE_VARIABLE MACRO=TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY VARIABLE=homed_pos VALUE='"{stringAddition}"'
  {% endif %}
  {% if printer.toolchanger.params_debug_toolchanger %}
  RESPOND MSG="calling _TC_CALIBRATION_PROBE_ACCURACY_LOOP"
  {% endif %}
  _TC_CALIBRATION_PROBE_ACCURACY_LOOP

#####################################################################
#   _TC_NUDGE_ANALYZE_AND_PRINT
#####################################################################
[gcode_macro _TC_NUDGE_ANALYZE_AND_PRINT]
gcode:
    {% if printer.toolchanger.params_debug_toolchanger %}
      RESPOND MSG="_TC_NUDGE_ANALYZE_AND_PRINT start"
    {% endif %}
  {% set parent = printer["gcode_macro TC_ENDSTOP_AND_CALIBRATION_PROBE_ACCURACY"] %}
  {% set unhomed_str = parent.unhomed_pos|string %}
  {% set homed_str = parent.homed_pos|string %}

  {% set nohomo_ns = namespace(sum_x=0.0, sum_y=0.0, sum_z=0.0, sum_sqr_x=0.0, sum_sqr_y=0.0, sum_sqr_z=0.0, count=0) %}
  {% set homo_ns = namespace(sum_x=0.0, sum_y=0.0, sum_z=0.0, sum_sqr_x=0.0, sum_sqr_y=0.0, sum_sqr_z=0.0, count=0) %}

  ######## le string horrors
  {% for entry in unhomed_str.split(';') %}
    {% if entry.startswith("u_") %}
      {% set x_idx = entry.find('x') %}
      {% set y_idx = entry.find('y') %}
      {% set z_idx = entry.find('z') %}
      {% if x_idx != -1 and y_idx != -1 and z_idx != -1 %}
        {% set x_val = entry[x_idx+1:y_idx]|float %}
        {% set y_val = entry[y_idx+1:z_idx]|float %}
        {% set z_val = entry[z_idx+1:]|float %}
        {% set nohomo_ns.sum_x = nohomo_ns.sum_x + x_val %}
        {% set nohomo_ns.sum_y = nohomo_ns.sum_y + y_val %}
        {% set nohomo_ns.sum_z = nohomo_ns.sum_z + z_val %}
        {% set nohomo_ns.sum_sqr_x = nohomo_ns.sum_sqr_x + x_val*x_val %}
        {% set nohomo_ns.sum_sqr_y = nohomo_ns.sum_sqr_y + y_val*y_val %}
        {% set nohomo_ns.sum_sqr_z = nohomo_ns.sum_sqr_z + z_val*z_val %}
        {% set nohomo_ns.count = nohomo_ns.count + 1 %}
      {% endif %}
    {% endif %}
  {% endfor %}

  {% for entry in homed_str.split(';') %}
    {% if entry.startswith("h_") %}
      {% set x_idx = entry.find('x') %}
      {% set y_idx = entry.find('y') %}
      {% set z_idx = entry.find('z') %}
      {% if x_idx != -1 and y_idx != -1 and z_idx != -1 %}
        {% set x_val = entry[x_idx+1:y_idx]|float %}
        {% set y_val = entry[y_idx+1:z_idx]|float %}
        {% set z_val = entry[z_idx+1:]|float %}
        {% set homo_ns.sum_x = homo_ns.sum_x + x_val %}
        {% set homo_ns.sum_y = homo_ns.sum_y + y_val %}
        {% set homo_ns.sum_z = homo_ns.sum_z + z_val %}
        {% set homo_ns.sum_sqr_x = homo_ns.sum_sqr_x + x_val*x_val %}
        {% set homo_ns.sum_sqr_y = homo_ns.sum_sqr_y + y_val*y_val %}
        {% set homo_ns.sum_sqr_z = homo_ns.sum_sqr_z + z_val*z_val %}
        {% set homo_ns.count = homo_ns.count + 1 %}
      {% endif %}
    {% endif %}
  {% endfor %}

  ######## the nudge knows where it is because it knows where it isnt, and by substracting where it is from where it isnt,
  {% set un_mean_x = nohomo_ns.sum_x / nohomo_ns.count %}
  {% set un_mean_y = nohomo_ns.sum_y / nohomo_ns.count %}
  {% set un_mean_z = nohomo_ns.sum_z / nohomo_ns.count %}
  {% set un_stdev_x = ((nohomo_ns.sum_sqr_x / nohomo_ns.count) - un_mean_x*un_mean_x)**0.5 %}
  {% set un_stdev_y = ((nohomo_ns.sum_sqr_y / nohomo_ns.count) - un_mean_y*un_mean_y)**0.5 %}
  {% set un_stdev_z = ((nohomo_ns.sum_sqr_z / nohomo_ns.count) - un_mean_z*un_mean_z)**0.5 %}

  ######## or where it isnt from where it is (whichever is greater) and arriving at a position where it wasnt (and is now)
  {% set ho_mean_x = homo_ns.sum_x / homo_ns.count %}
  {% set ho_mean_y = homo_ns.sum_y / homo_ns.count %}
  {% set ho_mean_z = homo_ns.sum_z / homo_ns.count %}
  {% set ho_stdev_x = ((homo_ns.sum_sqr_x / homo_ns.count) - ho_mean_x*ho_mean_x)**0.5 %}
  {% set ho_stdev_y = ((homo_ns.sum_sqr_y / homo_ns.count) - ho_mean_y*ho_mean_y)**0.5 %}
  {% set ho_stdev_z = ((homo_ns.sum_sqr_z / homo_ns.count) - ho_mean_z*ho_mean_z)**0.5 %}

  RESPOND MSG="-- Nudge (UNHOMED) --"
  RESPOND MSG="Mean X={un_mean_x|round(4)}, Y={un_mean_y|round(4)}, Z={un_mean_z|round(4)}"
  RESPOND MSG="Std  X={un_stdev_x|round(5)}, Y={un_stdev_y|round(5)}, Z={un_stdev_z|round(5)}"

  RESPOND MSG="-- Nudge (HOMED) --"
  RESPOND MSG="Mean X={ho_mean_x|round(4)}, Y={ho_mean_y|round(4)}, Z={ho_mean_z|round(4)}"
  RESPOND MSG="Std  X={ho_stdev_x|round(5)}, Y={ho_stdev_y|round(5)}, Z={ho_stdev_z|round(5)}"

  RESPOND MSG="Done! Compare unhomed vs. homed stdev to gauge endstop accuracy."  
  ######## it arrives where it wasnt.

###########################################################################################################################################
###########################################################################################################################################
###########################################################################################################################################









#################################################################################################################
# _DEBUG_RESPOND ################################################################################################
#################################################################################################################
[gcode_macro _DEBUG_RESPOND]
variable_first_run: 1
description:"[MSG=](message) will respond if debug is enabled."
variable_color:"secondary"
gcode:
	{% if printer['gcode_macro _toolchanger_settings'].debug_messages|default(true) %}
		{% set raw = params.MSG %}
		{% set parts = raw.split('$') %}
		{% if parts|length >= 3 %}
			{% set prefix = '$' ~ parts[1] ~ '$' %}
			{% set msg = raw.split(prefix, 1)[1].lstrip() %}
            {% set msg = msg[2:] %}
		{% else %}
			{% set pipe_index = raw.find('|') %}
			{% if pipe_index != -1 %}
				{% set prefix = raw[:pipe_index].rstrip() %}
			    {% set msg = raw[pipe_index:].lstrip() %}
		    {% else %}
			    {% set prefix = "?WHOCALLED?" %}
			    {% set msg = raw %}
            {% endif %}
		{% endif %}
        {% set msg = msg|replace("'", "&apos;") %}
        RESPOND MSG="<span style='cursor:pointer; color:rgba(79, 79, 79, 0.6);' title='{prefix}'>{msg}</span>"
	{% endif %}
	{% if printer['gcode_macro _toolchanger_settings'].debug_messages is not defined and first_run == 1 %}
			EXTENDED_RESPOND MSG="please define 'variable_debug_messages' inside [_toolchanger_settings] either as true or false." COLOR={"error"}
            SET_GCODE_VARIABLE MACRO=_DEBUG_RESPOND VARIABLE=first_run VALUE=0
	{% endif %}


#################################################################################################################
# _WARNING_RESPOND ##############################################################################################
#################################################################################################################
[gcode_macro _WARNING_RESPOND]
variable_first_run: 1
description:"[MSG=](message) will respond if warnings are enabled. (formatting is $caller name$ | warning message)"
variable_color: "secondary"
variable_warning_color: "warning"
gcode:
	{% if printer['gcode_macro _toolchanger_settings'].warning_messages|default(true) %}
		{% set raw = params.MSG %}
		{% set parts = raw.split('$') %}
		{% if parts|length >= 3 %}
			{% set prefix = '$' ~ parts[1] ~ '$' %}
			{% set msg = raw.split(prefix, 1)[1].lstrip() %}
		{% else %}
			{% set pipe_index = raw.find('|') %}
			{% if pipe_index != -1 %}
				{% set prefix = raw[:pipe_index].rstrip() %}
			    {% set msg = raw[pipe_index:].lstrip() %}
		    {% else %}
			    {% set prefix = "?WARNING?" %}
			    {% set msg = raw %}
            {% endif %}
		{% endif %}
		EXTENDED_RESPOND PREFIX="{prefix|string}" PREFIX_COLOR="{warning_color|string}" MSG="{msg|string}" COLOR="{color|string}"
	{% endif %}
	{% if printer['gcode_macro _toolchanger_settings'].warning_messages is not defined  and first_run == 1 %}
			EXTENDED_RESPOND MSG="please define 'variable_warning_messages' inside [_toolchanger_settings] either as true or false." COLOR={"error"}
            SET_GCODE_VARIABLE MACRO=_WARNING_RESPOND VARIABLE=first_run VALUE=0
	{% endif %}


#################################################################################################################
# _WARNING_RESPOND ##############################################################################################
#################################################################################################################
[gcode_macro _VALID_RESPOND]
variable_first_run: 1
description:"[MSG=](message) will respond if warnings are enabled. (formatting is $caller name$ | warning message)"
variable_color: "secondary"
variable_valid_color: "success"
gcode:
	{% if printer['gcode_macro _toolchanger_settings'].valid_messages|default(true) %}
		{% set raw = params.MSG %}
		{% set parts = raw.split('$') %}
		{% if parts|length >= 3 %}
			{% set prefix = '$' ~ parts[1] ~ '$' %}
			{% set msg = raw.split(prefix, 1)[1].lstrip() %}
		{% else %}
			{% set pipe_index = raw.find('|') %}
			{% if pipe_index != -1 %}
				{% set prefix = raw[:pipe_index].rstrip() %}
			    {% set msg = raw[pipe_index:].lstrip() %}
		    {% else %}
			    {% set prefix = "?VALID?" %}
			    {% set msg = raw %}
            {% endif %}
		{% endif %}
		EXTENDED_RESPOND PREFIX="{prefix|string}" PREFIX_COLOR="{valid_color|string}" MSG="{msg|string}" COLOR="{color|string}"
	{% endif %}
	{% if printer['gcode_macro _toolchanger_settings'].valid_messages is not defined and first_run == 1 %}
			EXTENDED_RESPOND MSG="please define 'variable_valid_messages' inside [_toolchanger_settings] either as true or false." COLOR={"error"}
            SET_GCODE_VARIABLE MACRO=_VALID_RESPOND VARIABLE=first_run VALUE=0
	{% endif %}


#################################################################################################################
# EXTENDED_RESPOND ##############################################################################################
#################################################################################################################
[gcode_macro EXTENDED_RESPOND]
description:"[PREFIX=] PREFIX_COLOR=] [MSG=] [COLOR=] (prefix, prefix color, message, message color)"
gcode:
  {% set colors = ('primary', 'secondary', 'accent', 'info', 'success', 'error', 'warning') %}

  {% if params.TYPE is defined and params.MSG is defined %} # if TYPE and MSG are defined, just use the default RESPOND
      {% if params.TYPE in ('echo', 'echo_no_space', 'command', 'error') and params.TYPE != '' %}
          {% set type = 'TYPE=' + params.TYPE|string %}
      {% else %}
          RESPOND TYPE=error MSG="RESPOND TYPE '{params.TYPE}' is invalid. Must be one of 'echo', 'echo_no_space', 'command' or 'error'"
      {% endif %}
  {% endif %}

  {% set color = "DEFAULT" %} # default garbage value
  
  {% if params.MSG is defined and params.COLOR is defined %}
  
      {% set color = params.COLOR|lower %}

      {% if color in colors %} # valid color supplied
          {% set msg = 'MSG="<span class=' + color + '--text>' + params.MSG + '</span>"'|string %} # apply color to main message body
      {% else %}
          RESPOND TYPE=error MSG="RESPOND COLOR '{color}' is invalid. Must be one of 'primary', 'secondary', 'accent', 'info', 'success', 'warning' or 'error'"
      {% endif %}

  {% elif params.MSG is defined %} # no color, but yes message
      {% set msg = 'MSG="'+ params.MSG + '"'|string %}
  {% endif %}

  {% if params.PREFIX is defined and params.PREFIX_COLOR is defined %} # check if a separate color was supplied for the prefix - otherwise, fall back on the default one
  
      {% set prefixColor = params.PREFIX_COLOR | default("DEFAULT") | lower %}
  
      {% if prefixColor in colors %} # valid prefix color supplied
          {% set prefix = 'PREFIX="<span class=' + prefixColor + '--text>' + params.PREFIX + '</span>"'|string %}
      {% elif color in color %} # prefix color is invalid - fall back on overall value if possible
          {% set prefix = 'PREFIX="<span class=' + color + '--text>' + params.PREFIX + '</span>"'|string %}
      {% else %}
          RESPOND TYPE=error MSG="RESPOND PREFIX_COLOR '{prefixColor}' is invalid. Must be one of 'primary', 'secondary', 'accent', 'info', 'success', 'warning' or 'error'"
      {% endif %}
      
  {% elif params.PREFIX is defined and color in colors %} # no provided prefix color - use the same color for the prefix as is used for the main message body if possible
      {% set prefix = 'PREFIX="<span class=' + color + '--text>' + params.PREFIX + '</span>"'|string %}
  {% elif params.PREFIX is defined %} # no valid colors provided either for the prefix or overall but we DO have a prefix- leave it default
      {% set prefix = 'PREFIX="' + params.PREFIX + '"'|string %}
  {% else %} # no prefix provided - don't use one!
      {% set prefix = "" | string %}
  {% endif %}
  
  RESPOND {type} {prefix} {msg}






[gcode_macro FIND_VARIABLES_MAYBE]
description: "Search for S=some_string within printer. Optional LIMIT=NN. Does not dump container contents if matched."
variable_color_path: "accent--text text--lighten-1"
variable_color_value: "primary--text text--lighten-1"
variable_color_type: "accent--text text--lighten-4"
variable_color_bool_true: "success--text text--darken-2"
variable_color_bool_false: "error--text text--darken-2"
variable_color_none: "secondary--text text--darken-4"
variable_color_special: "success--text text--darken-1"
variable_color_number: "info--text text--lighten-1"
variable_color_object: "accent--text text--darken-4"
variable_color_hint: "secondary--text text--lighten-1"
gcode:
    {% set search = params.S|default("")|lower %}
    {% set limit = params.LIMIT|default(50)|int %}
    {% if not search %}
        RESPOND MSG="Please provide S=some_string"
    {% else %}
        {% set ns = namespace(lines=[], total=0, stack=[]) %}

        {% for top_key in printer %}
            {% set key_str = top_key|string %}
            {% set has_special = (" " in key_str or "'" in key_str or "\"" in key_str or "[" in key_str or "]" in key_str) %}
            {% if has_special %}
                {% set path_str = "printer['" ~ key_str|replace("'","&apos;")|replace("\"","&quot;") ~ "']" %}
            {% else %}
                {% set path_str = "printer." ~ key_str %}
            {% endif %}
            {% set val_obj = printer[top_key] %}
            {% set _ = ns.stack.append([path_str, val_obj]) %}
        {% endfor %}

        {% for i in range(100000) %}
            {% if ns.stack|length == 0 %}
                {% set _=1 %}
            {% else %}
                {% set popped = ns.stack[ns.stack|length -1] %}
                {% set ns.stack = ns.stack[:ns.stack|length -1] %}
                {% set cur_path = popped[0] %}
                {% set cur_val = popped[1] %}
                {% set cur_val_str = cur_val|string %}
                {% set match_path = search in cur_path|lower %}
                {% set match_value = search in cur_val_str|lower %}
                {% if match_path or match_value %}
                    {% set ns.total = ns.total + 1 %}
                    {% if ns.lines|length < limit %}
                        {% set val_type = cur_val.__class__.__name__ %}
                        {% set escaped_path = cur_path|replace("'","&apos;")|replace("\"","&quot;") %}
                        {% if val_type in ["dict","list","tuple","set"] %}
                            {% set line_html = "<span class='" ~ color_path ~ "'>" ~ escaped_path ~ "</span>: <span class='" ~ color_object ~ "'>(" ~ val_type ~ ")</span>" %}
                            {% set _ = ns.lines.append(line_html) %}
                        {% else %}
                            {% set val_color = color_value %}
                            {% if val_type == "bool" %}
                                {% if cur_val_str|lower == "true" %}
                                    {% set val_color = color_bool_true %}
                                {% else %}
                                    {% set val_color = color_bool_false %}
                                {% endif %}
                            {% elif val_type in ["float","int"] %}
                                {% set val_color = color_number %}
                            {% elif val_type == "NoneType" %}
                                {% set val_color = color_none %}
                            {% elif val_type == "Coord" %}
                                {% set val_color = color_special %}
                            {% endif %}
                            {% set escaped_val = cur_val_str|replace("'","&apos;")|replace("\"","&quot;") %}
                            {% set line_html = "<span class='" ~ color_path ~ "'>" ~ escaped_path ~ "</span>: " ~
                                               "<span class='" ~ val_color ~ "'>" ~ escaped_val ~ "</span> " ~
                                               "<span class='" ~ color_type ~ "'>(" ~ val_type ~ ")</span>" %}
                            {% set _ = ns.lines.append(line_html) %}
                        {% endif %}
                    {% endif %}
                {% endif %}

                {% if cur_val is mapping %}
                    {% for ck in cur_val %}
                        {% set ck_str = ck|string %}
                        {% set ck_special = (" " in ck_str or "'" in ck_str or "\"" in ck_str or "[" in ck_str or "]" in ck_str) %}
                        {% if ck_special %}
                            {% set child_path = cur_path ~ "['" ~ ck_str|replace("'","&apos;")|replace("\"","&quot;") ~ "']" %}
                        {% else %}
                            {% set child_path = cur_path ~ "." ~ ck_str %}
                        {% endif %}
                        {% set child_obj = cur_val[ck] %}
                        {% set _ = ns.stack.append([child_path, child_obj]) %}
                    {% endfor %}
                {% endif %}
            {% endif %}
        {% endfor %}

        {% if ns.lines|length == 0 %}
            RESPOND MSG="No matches found for '" ~ search ~ "'."
        {% else %}
            {% set leftover = ns.total - ns.lines|length %}
            {% if leftover > 0 %}
                {% set leftover_info = "<br><span class='" ~ color_hint ~ "'>... " ~ leftover|string ~ " more matches not shown. (Use LIMIT=NN to see more)</span>" %}
            {% else %}
                {% set leftover_info = "" %}
            {% endif %}
            {% set final_output = "Found " ~ ns.total|string ~ " matches for '" ~ search ~ "'.<br>" ~ (ns.lines|join("<br>")) ~ leftover_info %}
            RESPOND MSG="{final_output}"
        {% endif %}
    {% endif %}




[gcode_macro FIND_VARIABLES]
description: "Search for S=some_string within printer. Optional LIMIT=NN to control how many lines are shown."
variable_color_path: "accent--text text--lighten-1"
variable_color_value: "primary--text text--lighten-1"
variable_color_type: "accent--text text--lighten-4"
variable_color_bool_true: "success--text text--darken-2"
variable_color_bool_false: "error--text text--darken-2"
variable_color_none: "secondary--text text--darken-4"
variable_color_special: "success--text text--darken-1"
variable_color_number: "info--text text--lighten-1"
variable_color_object: "accent--text text--darken-4"
variable_color_hint: "secondary--text text--lighten-1"
gcode:
    {% set search = params.S|default("")|lower %}
    {% set limit = params.LIMIT|default(50)|int %}
    {% if not search %}
        RESPOND MSG="Please provide S=some_string"
    {% else %}
        {% set ns = namespace(lines=[], total=0, stack=[]) %}

        {% for top_key in printer %}
            {% set key_str = top_key|string %}
            {% set has_special = (" " in key_str or "'" in key_str or "\"" in key_str or "[" in key_str or "]" in key_str) %}
            {% if has_special %}
                {% set path_str = "printer['" ~ key_str|replace("'","&apos;")|replace("\"","&quot;") ~ "']" %}
            {% else %}
                {% set path_str = "printer." ~ key_str %}
            {% endif %}
            {% set val_obj = printer[top_key] %}
            {% set _ = ns.stack.append([path_str, val_obj]) %}
        {% endfor %}

        {% for i in range(100000) %}
            {% if ns.stack|length == 0 %}
                {% set _=1 %}
            {% else %}
                {% set popped = ns.stack[ns.stack|length -1] %}
                {% set ns.stack = ns.stack[:ns.stack|length -1] %}
                {% set cur_path = popped[0] %}
                {% set cur_val = popped[1] %}
                {% set cur_val_str = cur_val|string %}
                {% if search in cur_path|lower or search in cur_val_str|lower %}
                    {% set ns.total = ns.total + 1 %}
                    {% if ns.lines|length < limit %}
                        {% set val_type = cur_val.__class__.__name__ %}
                        {% set val_color = color_value %}
                        {% if val_type == "bool" %}
                            {% if cur_val_str|lower == "true" %}
                                {% set val_color = color_bool_true %}
                            {% else %}
                                {% set val_color = color_bool_false %}
                            {% endif %}
                        {% elif val_type in ["float","int"] %}
                            {% set val_color = color_number %}
                        {% elif val_type == "NoneType" %}
                            {% set val_color = color_none %}
                        {% elif val_type == "Coord" %}
                            {% set val_color = color_special %}
                        {% endif %}
                        {% set escaped_val = cur_val_str|replace("'","&apos;")|replace("\"","&quot;") %}
                        {% set escaped_path = cur_path|replace("'","&apos;")|replace("\"","&quot;") %}
                        {% set line_html = "<span class='" ~ color_path ~ "'>" ~ escaped_path ~ "</span>: " ~
                                           "<span class='" ~ val_color ~ "'>" ~ escaped_val ~ "</span> " ~
                                           "<span class='" ~ color_type ~ "'>(" ~ val_type ~ ")</span>" %}
                        {% set _ = ns.lines.append(line_html) %}
                    {% endif %}
                {% endif %}
                {% if cur_val is mapping %}
                    {% for ck in cur_val %}
                        {% set ck_str = ck|string %}
                        {% set ck_special = (" " in ck_str or "'" in ck_str or "\"" in ck_str or "[" in ck_str or "]" in ck_str) %}
                        {% if ck_special %}
                            {% set child_path = cur_path ~ "['" ~ ck_str|replace("'","&apos;")|replace("\"","&quot;") ~ "']" %}
                        {% else %}
                            {% set child_path = cur_path ~ "." ~ ck_str %}
                        {% endif %}
                        {% set child_obj = cur_val[ck] %}
                        {% set _ = ns.stack.append([child_path, child_obj]) %}
                    {% endfor %}
                {% endif %}
            {% endif %}
        {% endfor %}

        {% if ns.lines|length == 0 %}
            RESPOND MSG="No matches found for '" ~ search ~ "'."
        {% else %}
            {% set leftover = ns.total - ns.lines|length %}
            {% if leftover > 0 %}
                {% set leftover_info = "<br><span class='" ~ color_hint ~ "'>... " ~ leftover|string ~ " more matches not shown. (Use LIMIT=NN to see more)</span>" %}
            {% else %}
                {% set leftover_info = "" %}
            {% endif %}
            {% set final_output = "Found " ~ ns.total|string ~ " matches for '" ~ search ~ "'.<br>" ~ (ns.lines|join("<br>")) ~ leftover_info %}
            RESPOND MSG="{final_output}"
        {% endif %}
    {% endif %}



#  find out if  {% for child_key, child_val in base_val.items() recursive %} RECURSIVE is actully a thing



[gcode_macro TEST_MACRO_BLOCK]
variable_macro: ""
variable_macro2: ""
gcode:
    {% macro shout(x) %}
        SET_GCODE_VARIABLE MACRO=TEST_MACRO_BLOCK VARIABLE=macro2 VALUE="test"
        {x}
    {% endmacro %}
    
    {% set return = shout("HELLO") %}
    RESPOND MSG="{macro2}"
    RESPOND MSG="{macro}"
    RESPOND MSG="Macro test complete."


[gcode_macro PARAM_TEST]
description: "Test macro that prints all passed parameters, their values, and types"
gcode:
    {% set nl = '\u0026\u0023\u0031\u0030\u003b' %}
    {% set report = [] %}
    {% for k in params %}
        {% set v = params[k] %}
        {% set t = v.__class__.__name__ %}
        {% set line = k ~ ": " ~ v ~ " (" ~ t ~ ")" %}
        {% set _ = report.append(line) %}
    {% endfor %}
    {% if report|length > 0 %}
        RESPOND MSG="PARAM_TEST Results:{nl}{report|join(nl)}"
    {% else %}
        RESPOND MSG="PARAM_TEST: No parameters provided."
    {% endif %}
    RESPOND MSG="rawparams: {rawparams}"
    RESPOND MSG="params[0]: {params[0]}"

[gcode_macro SEARCH_VARS]
description: S=[sjhk]
gcode:
    {% set search = params.S|lower %}
    {% set ns = namespace() %}
    {% for item in printer  %}
        {% if ' ' in item %}
            {% set ns.path = ['printer', "['%s']" % (item), ''] %}
        {% else %}
            {% set ns.path = ['printer.', item, ''] %}
        {% endif %}

        {% if search in ns.path|lower %}
            { action_respond_info(ns.path|join) }
        {% endif %}

        {% if printer[item].items() %}
            {% for childkey, child in printer[item].items() recursive %}
                {% set ns.path = ns.path[:loop.depth|int + 1] %}

                {% if ' ' in childkey %}{% set null = ns.path.append("['%s']" % (childkey)) %}
                {% else %}{% set null = ns.path.append(".%s" % (childkey)) %}{% endif %}

                {% if child is mapping  %}
                    { loop(child.items()) }
                {% else %}
                    {% if search in ns.path|lower %}
                        { action_respond_info("%s : %s" % (ns.path|join, child)) }
                    {% endif %}
                {% endif %}

            {% endfor %}
        {% endif %}
    {% endfor %}




[gcode_macro EXTENDED_RESPOND_SEARCH]
gcode:
  {% set colors = ('primary', 'secondary', 'accent', 'info', 'success', 'error', 'warning') %}

  {% if params.TYPE is defined and params.MSG is defined %} # if TYPE and MSG are defined, just use the default RESPOND
      {% if params.TYPE in ('echo', 'echo_no_space', 'command', 'error') and params.TYPE != '' %}
          {% set type = 'TYPE=' + params.TYPE|string %}
      {% else %}
          RESPOND TYPE=error MSG="RESPOND TYPE '{params.TYPE}' is invalid. Must be one of 'echo', 'echo_no_space', 'command' or 'error'"
      {% endif %}
  {% endif %}

  {% set color = "DEFAULT" %} # default garbage value
  
  {% if params.MSG is defined and params.COLOR is defined %}
  
      {% set color = params.COLOR|lower %}

      {% if color in colors %} # valid color supplied
          {% set msg = 'MSG="<span class=' + color + '--text>' + params.MSG + '</span>"'|string %} # apply color to main message body
      {% else %}
        {% set msg = 'MSG="<span class=' + color + '--text>' + params.MSG + '</span>"'|string %} # apply color to main message body
          #RESPOND TYPE=error MSG="RESPOND COLOR '{color}' is invalid. Must be one of 'primary', 'secondary', 'accent', 'info', 'success', 'warning' or 'error'"
      {% endif %}

  {% elif params.MSG is defined %} # no color, but yes message
      {% set msg = 'MSG="'+ params.MSG + '"'|string %}
  {% endif %}

  {% if params.PREFIX is defined and params.PREFIX_COLOR is defined %} # check if a separate color was supplied for the prefix - otherwise, fall back on the default one
  
      {% set prefixColor = params.PREFIX_COLOR | default("DEFAULT") | lower %}
  
      {% if prefixColor in colors %} # valid prefix color supplied
          {% set prefix = 'PREFIX="<span class=' + prefixColor + '--text>' + params.PREFIX + '</span>"'|string %}
      {% elif color in color %} # prefix color is invalid - fall back on overall value if possible
          {% set prefix = 'PREFIX="<span class=' + color + '--text>' + params.PREFIX + '</span>"'|string %}
      {% else %}
          RESPOND TYPE=error MSG="RESPOND PREFIX_COLOR '{prefixColor}' is invalid. Must be one of 'primary', 'secondary', 'accent', 'info', 'success', 'warning' or 'error'"
      {% endif %}
      
  {% elif params.PREFIX is defined and color in colors %} # no provided prefix color - use the same color for the prefix as is used for the main message body if possible
      {% set prefix = 'PREFIX="<span class=' + color + '--text>' + params.PREFIX + '</span>"'|string %}
  {% elif params.PREFIX is defined %} # no valid colors provided either for the prefix or overall but we DO have a prefix- leave it default
      {% set prefix = 'PREFIX="' + params.PREFIX + '"'|string %}
  {% else %} # no prefix provided - don't use one!
      {% set prefix = "" | string %}
  {% endif %}
  
  RESPOND {type} {prefix} {msg}



[gcode_macro DUMP_VARIABLES]
description: "Dump variables that match optional NAME/CONTENT filters."
gcode:
    {% set filter_name = params.NAME|default('')|string|lower %}
    {% set filter_value = params.VALUE|default('')|string|lower %}
    {% set show_cfg = params.SHOW_CFG|default(0)|int %}
    {% set color_prefix = "primary" %}
    {% set color_key = "accent" %}         # for keys like printer['foo'] or ['foo'].bar #}
    {% set color_value = "accent" %}       # for numbers, strings, bools #}
    {% set color_type = "secondary" %}     # for (float), (Coord), etc #}
    {% set color_special_obj = "success" %} # for known classes like Coord, PID, etc #}

    {% set ns = namespace(matches=[]) %}

    {% for key1 in printer %}
        {% set level1 = printer[key1] %}
        {% if level1 is mapping %}
            {% for key2 in level1 %}
                {% set val = level1[key2] %}
                {% if (show_cfg or not (key1|lower == 'configfile' and key2|lower in ['config', 'settings'])) and (filter_name in key1|lower or filter_name in key2|lower) and (filter_value in val|string|lower) %}
                    {% set val_type = val.__class__.__name__|string %}
                    {% set val_str = val|string %}
                    {% set type_color = color_type %}
                    {% if val_type in ('Coord', 'PID', 'Stepper', 'Extruder') %}
                        {% set type_color = color_special_obj %}
                    {% endif %}
                    {% set line = "<span class='" ~ color_key ~ "--text'>printer['" ~ key1 ~ "']." ~ key2 ~ "</span>: <span class='" ~ color_value ~ "--text'>" ~ val_str ~ "</span> <span class='" ~ type_color ~ "--text'>(" ~ val_type ~ ")</span>" %}
                    {% set _ = ns.matches.append(line) %}
                {% endif %}
            {% endfor %}
        {% else %}
            {% set val = level1 %}
            {% if filter_name in key1|lower and filter_value in val|string|lower %}
                {% set val_type = val.__class__.__name__|string %}
                {% set val_str = val|string %}
                {% set type_color = color_type %}
                {% if val_type in ('Coord', 'PID', 'Stepper', 'Extruder') %}
                    {% set type_color = color_special_obj %}
                {% endif %}
                {% set line = "<span class='" ~ color_key ~ "--text'>printer['" ~ key1 ~ "']</span>: <span class='" ~ color_value ~ "--text'>" ~ val_str ~ "</span> <span class='" ~ type_color ~ "--text'>(" ~ val_type ~ ")</span>" %}
                {% set _ = ns.matches.append(line) %}
            {% endif %}
        {% endif %}
    {% endfor %}

    {% if ns.matches|length > 0 %}
        EXTENDED_RESPOND_SEARCH PREFIX="DUMP_VARIABLES:" PREFIX_COLOR=color_prefix MSG="{ns.matches|join('\n')}" COLOR="info"
    {% else %}
        EXTENDED_RESPOND_SEARCH PREFIX="DUMP_VARIABLES:" PREFIX_COLOR=color_prefix MSG="No matching variables found." COLOR="warning"
    {% endif %}





[gcode_macro _DEPRECATED_MEGA_DUMP]
description: Up to N-level BFS. If container path matches, show (dict) and skip inside. [S=foo°bar°stack] will return results containing foo, and bar, and stack.
variable_color_path:    "rgb(128,128,128)"  # light gary
variable_color_key:     "rgb(0,150,255)"    # blue
variable_color_val:     "rgb(255,200,50)"   # yellow
variable_color_typ:     "rgb(180,180,180)"  # whiteish
variable_color_match:   "rgb(255,0,100)"    # magenta
variable_long_limit:    "120"                 # characters before cutoff
variable_max_depth:     "5"                   # 5 levels (3-4 should work too)
gcode:
    {% set raw_s = params.I|default("")|string %}
    {% set cutoff = 99999 if 'F' in params else 50 %}
    {% set search_lc = raw_s|lower %}
    {% set terms = search_lc.split("°") %}

    #{% set nl = '\u0026\u0023\u0031\u0030\u003b' %}
    {% set nl = '<br>' %}

    {% set ns = namespace(lines=[], total=0, stack=[], done=False, doneAtLine="None", val="") %}

    {% for top_key in printer %}
        {% set item = [top_key|string, printer[top_key], 1] %}
        {% set ns.stack = ns.stack + [ item ] %}
    {% endfor %}

    {% for i in range(99999) %}
        {% if ns.stack|length == 0 %}
            {% set ns.done = 1 %}
        {% else %}
            {% set popped = ns.stack[ ns.stack|length -1 ] %}
            {% set ns.stack = ns.stack[:ns.stack|length -1] %}
            {% set cur_path = popped[0] %}
            {% set cur_obj  = popped[1] %}
            {% set depth    = popped[2] %}
            {% set typ_str  = cur_obj.__class__.__name__|string %}

            {% set val_str = "" %}
            {% if typ_str not in ["dict", "list", "tuple", "set"] %}
                {% set val_str = cur_obj|string %}
            {% endif %}

            {% set combined = cur_path|lower %}
            {% if val_str %}
                {% set combined = combined ~ " " ~ val_str|lower ~ typ_str|lower %}
            {% endif %}

            {% set match_ns = namespace(keep=true) %}
            {% for t in terms %}
                {% if t|length > 0 and not (t in combined) %}
                    {% set match_ns.keep = false %}
                {% endif %}
            {% endfor %}
            
            {% if 'configfile.config' in cur_path|lower %}
                {% set match_ns.keep = false %}
            {% endif %}

            {% if match_ns.keep %}
                {% set ns.total = ns.total + 1 %}
                {% set ns.final_path = cur_path %}
                {% set ns.final_val  = val_str|replace('"', '&quot;')|replace("'", '&apos;')|replace("<", "&lt;")|replace(">", "&gt;") %}
                {% set ns.final_typ  = "(" ~ typ_str ~ ")" %}
                {% set segments = cur_path.split(".") %}
                {% set ns.final_key = segments[segments|length -1] %}

                # |replace('"', '&quot;')|replace("'", '&apos;')|replace("<", "&lt;")|replace(">", "&gt;")

                {% set hover_path = cur_path|replace('"', '&quot;')|replace("'", '&apos;')|replace("<", "&lt;")|replace(">", "&gt;") %}
                {% set hover = "printer." ~ hover_path %}

                # ------------------------------------------------------------------ #
                #  Two-pass highlighter: avoids tuching characters that already
                #  live inside earlier span tags.
                #  - terms  - list split from the S=… parameter
                #  - color_match  – your highlight RGB variale
                #  - ns.final_path / key / val / typ  – the strings we want to color
                # ------------------------------------------------------------------ #

                {% set mask = namespace(path = ns.final_path, key  = ns.final_key, val  = ns.final_val, typ  = ns.final_typ) %}

                {% for t in terms %}
                    {% if t|length > 0 %}
                        {% set term = t|lower %}
             
                        {% set lower_path = mask.path|lower %}
                        {% set lower_key  = mask.key|lower %}
                        {% set lower_val  = mask.val|lower %}
                        {% set lower_typ  = mask.typ|lower %}

                        # ---- path ----
                        {% set idx = lower_path.find(term) %}
                        {% if idx != -1 %}
                            {% set orig = mask.path[idx:idx + term|length] %}
                            {% set mask.path = mask.path[:idx] ~ "<span style='color:" ~ color_match ~ "'>" ~ orig ~ "</span>" ~ mask.path[idx + term|length:] %}
                        {% endif %}
                        # ---- key ----
                        {% set idx = lower_key.find(term) %}
                        {% if idx != -1 %}
                            {% set orig = mask.key[idx:idx + term|length] %}
                            {% set mask.key = mask.key[:idx] ~ "<span style='color:" ~ color_match ~ "'>" ~ orig ~ "</span>" ~ mask.key[idx + term|length:] %}
                        {% endif %}
                        # ---- val ----
                        {% set idx = lower_val.find(term) %}
                        {% if idx != -1 %}
                            {% set orig = mask.val[idx:idx + term|length] %}
                            {% set mask.val = mask.val[:idx]  ~ "<span style='color:" ~ color_match ~ "'>" ~ orig ~ "</span>"  ~ mask.val[idx + term|length:] %}
                        {% endif %}
                        # ---- typ ----
                        {% set idx = lower_typ.find(term) %}
                        {% if idx != -1 %}
                            {% set orig = mask.typ[idx:idx + term|length] %}
                            {% set mask.typ = mask.typ[:idx]  ~ "<span style='color:" ~ color_match ~ "'>" ~ orig ~ "</span>"  ~ mask.typ[idx + term|length:] %}
                        {% endif %}
                    {% endif %}
                {% endfor %}

                {% set ns.final_path = mask.path %}
                {% set ns.final_key  = mask.key  %}
                {% set ns.final_val  = mask.val  %}
                {% set ns.final_typ  = mask.typ  %}

                {% if typ_str in ["dict", "set"] and cur_obj|length > 0 %} # "list" #"tuple"
                    {% set summary = "<summary><span style='color:" ~ color_path ~ "'>" ~ ns.final_path ~ "</span> {<span style='color:" ~ color_val ~ "'>(" ~ typ_str ~ ")</span>}</summary>" %}
                    {% set children = [] %}
                    {% set show_keys = cur_obj.keys()|list %} #if typ_str == "dict" else range(cur_obj|length) %}
                    {% for k in show_keys[:10] %}
                        {% set val_type = cur_obj[k].__class__.__name__ %}
                        #{% if val_type not in ["dict", "list", "tuple", "set"] %}
                            {% set val_str = cur_obj[k]|string %}
                            {% if val_str|length > cutoff %}
                                {% set val_str = val_str[:cutoff-3] ~ "..." %}
                            {% endif %}
                            {% set child_line = "<div style='margin-left:1em'><span style='color:" ~ color_key ~ "'>" ~ k|string ~ ":</span> <span style='color:" ~ color_val ~ "'>" ~ val_str|replace('"', '&quot;')|replace("'", '&apos;')|replace("<", "&lt;")|replace(">", "&gt;") ~ "</span> <span style='color:" ~ color_typ ~ "'>(" ~ val_type ~ ")</span></div>" %}
                            {% set _ = children.append(child_line) %}
                        #{% endif %}
                    {% endfor %}
                    
                    {% set html = "<span style='display:inline-block'><details title='" ~ hover ~ "'>" ~ summary ~ children|join() ~ "</details></span>" %} # children|join(nl)
                    {% set ns.lines = ns.lines + [html] %}
                {% else %}
                    # -------------------------------------------------------------------- #
                    #  BUILD PRETTY INDENT
                    #  – ident at if else for starts
                    #  – reduce indent at ending tags
                    # -------------------------------------------------------------------- #
                    {% set raw_lines = ns.final_val.split('\n') %}
                    {% set ns_gcode = namespace(dent = 0, prev_empty = false, unclosed = false) %}
                    {% set html_lines = [] %}

                    {% for ln in raw_lines %}
                        {% set t = ln|trim %}

                        # 1 - close or else/elif → pop
                        {% if '{% end' in t or '{% el' in t %}
                            {% set ns_gcode.dent = [ns_gcode.dent - 1, 0]|max %}
                        {% endif %}

                        # 2 - render at current indent
                        {% set pad = '&nbsp;&nbsp;' * ns_gcode.dent %}

                        # 2b - dont spam newlines where klipper added newline for a removed comment.
                        {% if t == '' %}
                            {% if not ns_gcode.prev_empty %}
                                {% set _ = html_lines.append(nl) %}
                                {% set ns_gcode.prev_empty = true %}
                            {% endif %}
                        {% else %}
                            {% set _ = html_lines.append(pad ~ t ~ nl) %}
                            {% set ns_gcode.prev_empty = false %}
                        {% endif %}

                        # 2c - if it ends with a pure closer, inject blank line
                        {% if (t.endswith('{% endif %}') or t.endswith('{% endfor %}')) and (t != ('{% endif %}' or '{% endfor %}')) and not ns_gcode.prev_empty %}
                            {% set _ = html_lines.append(nl) %}
                        {% endif %}

                        # 3 - opener or else/elif → push
                        {% if '{% if' in t or '{% for' in t or '{% el' in t %}
                            {% set ns_gcode.dent = ns_gcode.dent + 1 %}
                        {% endif %}
                    {% endfor %}

                    # 4 - Re-join, wrap in your summary/details logic as before 
                    {% set plain_full = html_lines|join('') %}

                    # -------------------------------------------------------------------- #
                    #  DISPLAY WITH SUMMARY
                    #  – if the string is short  → keep the old one-liner
                    #  – if the string is long   → show preview + expandable details
                    # -------------------------------------------------------------------- #
                    {% if plain_full|length <= long_limit|int and '\n' not in plain_full %}
                        # ── SHORT STRING ─────────────────────────── #
                        {% set line = "<span title='" ~ hover ~ "'>" ~
                            "<span style='color:" ~ color_path ~ "'>" ~ ns.final_path ~ "</span> {" ~
                            "<span style='color:" ~ color_key  ~ "'>" ~ ns.final_key  ~ "</span>: " ~
                            "<span style='color:" ~ color_val  ~ "'>" ~ plain_full|replace(nl, '') ~ "</span> " ~
                            "<span style='color:" ~ color_typ  ~ "'>" ~ ns.final_typ   ~ "</span>}" ~
                            "</span>" %}
                        {% set ns.lines = ns.lines + [ line ] %}

                    {% else %}
                        # ── LONG STRING → build preview around 1st highlight + details─── #

                        # find earliest highlighted <span> placeholder (§n§ already expanded) #
                        {% set first_idx = plain_full.find(color_match) %}
                        {% if first_idx == -1 %} {% set first_idx = 0 %} {% endif %}

                        {% set preview_start = [first_idx - 35, 0]|max %}
                        {% set preview_end = preview_start + 75|int %}
                        {% set preview = plain_full[preview_start:preview_end] %}

                        # --- add ... if not cut at start
                        {% if preview_start > 0 %} {% set preview = "…" ~ preview %} {% endif %}
                        # --- add ... if not cut at end
                        {% if preview_end < plain_full|length %} {% set preview = preview ~ "…" %} {% endif %}

                        # summary line (preview) #
                        {% set summary = "<summary><span style='color:" ~ color_path ~ "'>" ~ ns.final_path ~
                            "</span> {" ~
                            "<span style='color:" ~ color_key ~ "'>" ~ ns.final_key ~ "</span>: " ~
                            "<span style='color:" ~ color_val ~ "'>" ~ preview|replace(nl, '') ~ "</span> " ~
                            "<span style='color:" ~ color_typ ~ "'>" ~ ns.final_typ ~ "</span>}</summary>" %}

                        # full content shown after expanding #
                        {% set details = "<div style='margin-left:1em; white-space:pre; overflow-x:auto;'>" ~ plain_full ~ "</div>" %}
                        {% set html = "<span style='display:inline-block'><details title='" ~ hover ~ "'>" ~ summary ~ details ~ "</details></span>" %}

                        {% set ns.lines = ns.lines + [ html ] %}
                    {% endif %}
                {% endif %}
            # -------------------------------------------------------------------- #
            #  SEARCH FURTHER
            #  - if type contains contents, go further until max_depth is hit.
            #  - adds to the list the for loop accesses.
            # -------------------------------------------------------------------- #
            {% elif typ_str == "dict" and depth < max_depth|int %}
                {% for child_key in cur_obj %}
                    {% set next = cur_path ~ "." ~ child_key|string %}
                    {% set entry = [next, cur_obj[child_key], depth + 1] %}
                    {% set ns.stack = ns.stack + [ entry ] %}
                {% endfor %}
            {% elif typ_str in ["list", "tuple", "set"] and depth < max_depth|int %}
                {% set idx = 0 %}
                {% for val in cur_obj %}
                    {% set next = cur_path ~ "[" ~ idx|string ~ "]" %}
                    {% set entry = [next, val, depth + 1] %}
                    {% set ns.stack = ns.stack + [ entry ] %}
                    {% set idx = idx + 1 %}
                {% endfor %}
            {% endif %}
            {% if ns.done|default(false) and ns.doneAtLine == "None" %}
                {% set ns.doneAtLine=loop.index|string %}
                RESPOND MSG="{loop.index|string}"
            {% endif %}
        {% endif %}
    {% endfor %}
    
    {% if ns.lines|length == 0 %}
        {% set safe = raw_s|replace("'", "&apos;") %}
        RESPOND MSG="No matches found for '{safe}'"
    {% else %}
        # split into config vs everything else 
        {% set cfg = [] %}
        {% set oth = [] %}
        {% set hlp = [] %}
        {% for line in ns.lines %}
            {% if "<details title='printer.configfile.settings" in line or "<span title='printer.configfile.settings" in line %}
                {% set _ = cfg.append(line) %}
            {% elif "<details title='printer.gcode.commands" in line or "<span title='printer.gcode.commands" in line %}
                {% set _ = hlp.append(line) %}
            {% else %}
                {% set _ = oth.append(line) %}
            {% endif %}
        {% endfor %}

        # build the summaries 
        {% if oth %} {% set summary_oth = "<details><summary>others   (" ~ oth|length|string ~ " matches)</summary>" ~ (oth|join(nl)) ~ "</details>" %} {% endif %}
        {% if cfg %} {% set summary_cfg = "<details><summary>config   (" ~ cfg|length|string ~ " matches)</summary>" ~ (cfg|join(nl)) ~ "</details>" %} {% endif %}
        {% if hlp %} {% set summary_cfg = "<details><summary>help/cmd (" ~ hlp|length|string ~ " matches)</summary>" ~ (hlp|join(nl)) ~ "</details>" %} {% endif %}
        # send them both 
        {% set msg = "Found " ~ ns.lines|length|string ~ " matches for " ~ raw_s|replace("'", "&apos;") ~ ":" ~ summary_oth|replace('\n', nl)|replace('\r','') ~ summary_cfg|replace('\n', nl)|replace('\r','') %}
        RESPOND MSG="{msg}"
    {% endif %}


[gcode_macro DUMP_VARIABLES_SEARCH]
gcode:
    {% set filter_name = params.NAME|default('')|string|lower %}
    {% set filter_value = params.VALUE|default('')|string|lower %}
    {% set show_cfg = params.SHOW_CFG|default(0)|int %}
    {% set out = [] %}
    {% for key1 in printer %}
        {% for key2 in printer[key1] %}
            {% if (show_cfg or not (key1|lower == 'configfile' and key2|lower in ['config', 'settings'])) and (filter_name in key1|lower or filter_name in key2|lower) and filter_value in printer[key1][key2]|string|lower %}
                {% set dummy = out.append("printer['%s'].%s = %s" % (key1, key2, printer[key1][key2])) %}
            {% endif %}
        {% else %}
            {% if filter_name in key1|lower and filter_value in printer[key1]|string|lower %}
                {% set dummy = out.append("printer['%s'] = %s" % (key1, printer[key1])) %}
            {% endif %}
        {% endfor %}
    {% endfor %}
    {action_respond_info(out|join("\n"))}








[display_template logo2]
param_tn: 'None'
text:
  # defaults/our defines.
  {% set ns     = namespace(is_homing = False) %}
  {% set actn   = printer.tool_probe_endstop.active_tool_number %}
  {% set colors = printer['gcode_macro _toolchanger_led_vars'].get('colors', {}).get('logo', {}) %}
  {% set c      = colors.get(standby, {}) %}
  {% set status = 'standby' %}
  # get stuffs
  {% set pp = printer.printer %}
  {% set th = pp.lookup_object('toolhead') %}
  {% set probe = pp.lookup_object('probe') %}
  # check if we are currently homing
  {% set ns.is_homing = 'xyz' not in printer.toolhead.homed_axes|lower %}
  {% for _ in range (3) %}{% set ns.is_homing = False if printer.toolhead.position[loop.index0] else ns.is_homing %}{% endfor %}
  
  # check if the probe is currently triggered.
  {% if ns.is_homing and param_tn|int == actn %}
    #{% set invert = probe.mcu_probe.query_endstop(th.get_last_move_time()) %}
    {% set status = 'homing' %}
  {% endif %}

  # retrieve current status colors and set them.
  {% for k in ['r','g','b','w'] %}
    {% set color = colors.get(status, c).get(k, c.get(k, 0)) %}
    {% set _ = c.update({k: ((color -1)|abs if invert else color)}) %}
  {% endfor %}
  {c.r},{c.g},{c.b},{c.w}