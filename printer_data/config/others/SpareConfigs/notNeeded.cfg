[gcode_macro RECONSTRUCT_LITERAL_FROM_STRING]
description: "reconstructs literal from a string input as param or rawparams?"
gcode:
  {% set raw = params.DATA|default("") %}
  {% set ns = namespace(
    result=None,
    stack=[],              # List of all active containers
    key_stack=[],          # Dict keys waiting for values
    cur="",                # Current token
    quote="",              # Quote mode (' or ")
    i=0                    # Char index
  ) %}

  {% for _ in range(9999) %}
    {% if ns.i < raw|length %}
      {% set c = raw[ns.i] %}
      {% set ns.i = ns.i + 1 %}

      {% if c in [" ", "\n", "\t"] and ns.quote == "" %}
        # whitespace: do nothing

      {% elif c in ["'", '"'] %}
        {% set ns.quote = "" if ns.quote == c else c %}

      {% elif ns.quote %}
        {% set ns.cur = ns.cur ~ c %}

      {% elif c == ":" %}
        {% set _ = ns.key_stack.append(ns.cur.strip()) %}
        {% set ns.cur = "" %}

      {% elif c in [",", "]", "}"] %}
        {% if ns.cur|length > 0 %}
          {% set val_str = ns.cur.strip() %}
          {% set c0 = val_str[0] if val_str|length > 0 else "" %}
          {% set is_numberish = ("0" <= c0 <= "9") or c0 == "-" %}
          {% set is_boolish = val_str|lower in ["true", "false"] %}
          {% set val = 
            true if val_str|lower == "true" else
            false if val_str|lower == "false" else
            val_str|float if is_numberish and "." in val_str else
            val_str|int if is_numberish else
            val_str %}
          {% if ns.stack[-1].__class__.__name__ == "dict" %}
            {% set key = ns.key_stack.pop() %}
            {% set _ = ns.stack[-1].update({key: val}) %}
          {% else %}
            {% set _ = ns.stack[-1].append(val) %}
          {% endif %}
          {% set ns.cur = "" %}
        {% endif %}
        {% if c in ["]", "}"] %}
          {% set last = ns.stack.pop() %}
          {% if ns.stack|length == 0 %}
            {% set ns.result = last %}
          {% elif ns.stack[-1].__class__.__name__ == "dict" %}
            {% set key = ns.key_stack.pop() %}
            {% set _ = ns.stack[-1].update({key: last}) %}
          {% else %}
            {% set _ = ns.stack[-1].append(last) %}
          {% endif %}
        {% endif %}

      {% elif c == "[" %}
        {% set newlist = [] %}
        {% set _ = ns.stack.append(newlist) %}

      {% elif c == "{" %}
        {% set newdict = {} %}
        {% set _ = ns.stack.append(newdict) %}
        {% if ns.result == None %}
          {% set ns.result = newdict %}
        {% endif %}

      {% else %}
        {% set ns.cur = ns.cur ~ c %}
      {% endif %}
    {% endif %}
  {% endfor %}

  {action_respond_info("Parsed:\n" ~ ns.result|string)}



#########################################################################################
#    _STEPPER_Z_SOFT_TURN_ON    #########################################################
#########################################################################################
[gcode_macro _STEPPER_Z_SOFT_TURN_ON]
description: Softly ramp up Z stepper current to avoid loud bumps or PSU spikes
variable_default_steps: 5         # default ramp steps
variable_default_ramp_time: 250   # total ramp time in ms
gcode:
    {% if printer.stepper_enable.steppers.stepper_z %}
        # Already on — skip ramp
    {% else %}
        {% set steps = params.STEPS|default(default_steps)|int %}
        {% set ramp_time = params.RAMP_TIME|default(default_ramp_time)|float %}
        {% set step_delay = ramp_time / steps %}
        {% for i in range(steps) %}
            _SET_Z_STEPPER_CURRENT DUTY={i * (100 // steps)}
            G4 P{step_delay|int}
        {% endfor %}
        _SET_Z_STEPPER_CURRENT DUTY=100
    {% endif %}



#########################################################################################
#    _SET_Z_STEPPER_CURRENT    ##########################################################
#########################################################################################
[gcode_macro _SET_Z_STEPPER_CURRENT]
description: Provide a current percentage (0-100) for all Z TMC drivers
variable_found_steppers: None
gcode:
    {% set duty = params.DUTY|default(100)|int %}
    {% set z_steps = ['stepper_z', 'stepper_z1', 'stepper_z2', 'stepper_z3'] %}
    {% set drivers = ['tmc2130', 'tmc2208', 'tmc2209', 'tmc5160', 'tmc2240'] %}
    {% set ns = namespace(pairs=[]) %}

    {% if found_steppers == None %}
        # Step 1: find valid stepper-driver config sections
        {% for zstep in z_steps %}
            {% for drv in drivers %}
                {% set candidates = [drv ~ ' ' ~ zstep, drv ~ '_' ~ zstep] %}
                {% for key in candidates %}
                    {% if key in printer.configfile.settings %}
                        {% set _ = ns.pairs.append(zstep ~ ':' ~ key) %}
                    {% endif %}
                {% endfor %}
            {% endfor %}
        {% endfor %}

        {% if ns.pairs|length > 0 %}
            {% set valtosave = ns.pairs|join(',') %}
            SET_GCODE_VARIABLE MACRO=_SET_Z_STEPPER_CURRENT VARIABLE=found_steppers VALUE="{valtosave}"
        {% else %}
            RESPOND MSG="❌ No TMC Z drivers found."
        {% endif %}
    {% else %}
        {% set ns.pairs = found_steppers.split(',') %}
    {% endif %}

    {% set enable = printer.stepper_enable.steppers %}
    {% for entry in ns.pairs %}
        {% set parts = entry.split(':') %}
        {% set stepper = parts[0] %}
        {% set config_key = parts[1] %}
        {% set config = printer.configfile.settings[config_key]|default({}) %}
        {% set run = config.run_current|float %}
        {% set hold = config.hold_current|float %}
        {% set new_run = run * (duty / 100.0) %}
        {% set new_hold = hold * (duty / 100.0) %}

        {% if duty == 0 %}
            {% if stepper in enable and enable[stepper] %}
                SET_STEPPER_ENABLE STEPPER={stepper} ENABLE=0
            {% endif %}
            SET_TMC_CURRENT STEPPER={stepper} CURRENT={run} HOLDCURRENT={hold}
        {% else %}
            SET_TMC_CURRENT STEPPER={stepper} CURRENT={new_run} HOLDCURRENT={new_hold}
            {% if stepper not in enable or not enable[stepper] %}
                SET_STEPPER_ENABLE STEPPER={stepper} ENABLE=1
            {% endif %}
        {% endif %}
    {% endfor %}



#[gcode_macro M106]
#rename_existing: M106.1
#description: Override "M106" to account for multiple extruders.
#gcode:
#    {% set raw_speed = params.S|default(255)|float %}
#    {% set fan_speed = (raw_speed / 255.0)|round(2) %}
#    {% set fan_tool = 0 if (printer.toolchanger.tool_number|string) == "-1" else printer.toolchanger.tool_number|string %}
#    {% if (params.P) is defined %}
#      {% set P_fan = "part_fan_t" + params.P|string %}
#      SET_FAN_SPEED FAN={P_fan} SPEED={fan_speed}
#    {% else %}
#      SET_FAN_SPEED FAN="part_fan_t{fan_tool}" SPEED={fan_speed}
#    {% endif %}

#[gcode_macro M107]
#rename_existing: M107.1
#description: Override "M107" to account for multiple extruders.
#gcode:
#    # If we specified a fan, turn it off
#    {% if (params.P) is defined %}
#      M106 S0 P{params.P}
#    {% else %}
#      # Otherwise, turn off all part cooling fans
#      {% set num_tools = printer.toolchanger.tool_numbers|length|int %}
#      # Loop through the tools.
#      {% for i in range(num_tools) %}
#        # Turn off the fans
#        M106 S0 P{i}
#      {% endfor %}
#    {% endif %}





      #ROUNDED_G0 X={cur_pos.x + off.x} Y={safe_y//2} Z={cur_pos.z + off.z+5} F={fast} D=60#30 #todo change +10 to max limited
      #ROUNDED_G0 Y={safe_y//2} Z={cur_pos.z + off.z+10} F={fast} D=50


      #ROUNDED_G0 Y={safe_y} Z={cur_pos.z + off.z} F={fast} D=90
      # suicide {% if 'Z' in rp and 'Y' in rp and 'X' in rp %} ROUNDED_G0 X={rp.X} Y={rp.Y} Z={(rp.Z + cur_pos.z) / 2} F={fast} D=200 {% endif %}
      # suicide {% if 'Z' in rp and 'Y' in rp and 'X' in rp %} ROUNDED_G0 X={rp.X} Y={rp.Y} Z={rp.Z + 5} F={fast} D=5 {% endif %}
      # suicide {% if 'Z' in rp and 'Y' in rp and 'X' in rp %} ROUNDED_G0 X={rp.X} Y={rp.Y} Z={rp.Z} F={fast//5} D=0 {% endif %}
      
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Z={rp.Z} F={fast//5} D=0"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Z={((rp.Z + cur_pos.z) // 2)|round(3)} F={fast} D=70"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Y={rp.Y|round(3)} F={fast} D=50"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 X={rp.X|round(3)} F={fast} D=1000"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Y={safe_y//2} Z={cur_pos.z + off.z+10} F={fast} D=50"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Y={safe_y} F={fast} D=90"

#ROUNDED_G0 X={cur_pos.x + off.x} Y={safe_y} Z={cur_pos.z + off.z} F={fast} D=50 
#
#{% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z+1} F={fast} D=150 {% endif %}
#{% if 'X' in rp %} ROUNDED_G0 X={rp.X|round(3)} F={fast} D=1000 {% endif %}
#{% if 'Y' in rp %} ROUNDED_G0 Y={rp.Y|round(3)} F={fast} D=50 {% endif %}
#{% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z|round(3)} F={fast} D=5 {% endif %}
#
#{% if 'Z' in rp %} G0 Z{rp.Z} F{fast//5} {% endif %}

#
#ROUNDED_G0 Y=100 D=20
#ROUNDED_G0 Y=210 Z=350 D=100
#ROUNDED_G0 X=175 Y=175 Z=100 D=200
#ROUNDED_G0 X=175 Y=175 Z=10 D=0
#ROUNDED_G0 Y=175 X=175 D=500



#################################################################################################################
# _DETECT_OFFSET_TEMPLATE #######################################################################################
#################################################################################################################
[gcode_macro _DETECT_OFFSET_TEMPLATE]
description: "Detect common offset variable patterns and inconsistencies"
gcode:
    {% set ns = namespace(
        keys = printer|list,
        patterns = [],
        counts = [],
        zeroed = []
    ) %}

    {% for key in ns.keys %}
        {% if "_offset_" in key %}
            {% set parts = key.split('_') %}
            {% if parts|length >= 3 %}
                {% set templ = parts[0][:1] ~ '*_' ~ parts[1] ~ '_' ~ parts[2] %}
                {% set val = printer[key] %}
                {% set idx = -1 %}
                {% for i in range(ns.patterns|length) %}
                    {% if ns.patterns[i] == templ %}
                        {% set idx = i %}
                    {% endif %}
                {% endfor %}
                {% if idx == -1 %}
                    {% set ns.patterns = ns.patterns + [templ] %}
                    {% set ns.counts = ns.counts + [1 if val != 0 else 0] %}
                {% else %}
                    {% set ns.counts = ns.counts[:idx] + [ns.counts[idx] + (1 if val != 0 else 0)] + ns.counts[idx+1:] %}
                {% endif %}
                {% if val == 0 %}
                    {% set ns.zeroed = ns.zeroed + [key] %}
                {% endif %}
            {% endif %}
        {% endif %}
    {% endfor %}

    {% if ns.patterns|length > 0 %}
        {% set max_idx = 0 %}
        {% for i in range(1, ns.counts|length) %}
            {% if ns.counts[i] > ns.counts[max_idx] %}
                {% set max_idx = i %}
            {% endif %}
        {% endfor %}
        RESPOND TYPE=echo MSG="Most common offset pattern: {ns.patterns[max_idx]}"
        {% for i in range(ns.patterns|length) %}
            RESPOND TYPE=echo MSG="{ns.patterns[i]} → {ns.counts[i]} offset(s)"
        {% endfor %}
    {% else %}
        RESPOND TYPE=echo MSG="No offset-style variables found."
    {% endif %}

    {% if ns.zeroed %}
        RESPOND TYPE=echo MSG="Zero (undefined) offsets: {ns.zeroed|join(', ')}"
    {% endif %}




#################################################################################################################
# _GCODE_OFFSET_AUTODETECT ######################################################################################
#################################################################################################################
[gcode_macro _GCODE_OFFSET_AUTODETECT]
description: Autodetects offset source (tool config vs save_variables) and reports issues.
variable_gcode_offsets_in_tools: 0
variable_gcode_offsets_in_safe_vars: 0
gcode:

   {% set tool_names = printer.toolchanger.tool_names %}
    {% set svf = printer.save_variables.variables if "save_variables" in printer.configfile.config else {} %}
    {% set ns = namespace(
        config_offsets=[], svf_offsets=[], both_offsets=[], partial_svf=[], no_offsets=[]
    ) %}

    {% for tool_name in tool_names %}
        {% set tool = printer[tool_name] %}
        {% set tn = tool_name|string|replace('tool ', '', 1)|lower %}

        {% set config_has_offset = tool.gcode_x_offset != 0 or tool.gcode_y_offset != 0 or tool.gcode_z_offset != 0 %}
        {% set svf_x = tn ~ '_offset_x' %}
        {% set svf_y = tn ~ '_offset_y' %}
        {% set svf_z = tn ~ '_offset_z' %}
        {% set svf_has_all = svf_x in svf and svf_y in svf and svf_z in svf %}
        {% set svf_has_any = svf_x in svf or svf_y in svf or svf_z in svf %}

        {% if config_has_offset and not svf_has_any %}
            {% set ns.config_offsets = ns.config_offsets + [tool_name] %}
        {% elif svf_has_all and not config_has_offset %}
            {% set ns.svf_offsets = ns.svf_offsets + [tool_name] %}
        {% elif config_has_offset and svf_has_all %}
            {% set ns.both_offsets = ns.both_offsets + [tool_name] %}
        {% elif svf_has_any and not svf_has_all %}
            {% set ns.partial_svf = ns.partial_svf + [tool_name] %}
        {% else %}
            {% set ns.no_offsets = ns.no_offsets + [tool_name] %}
        {% endif %}
    {% endfor %}

    ; Report Results
    {% if ns.config_offsets %}
        _VALID_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Offsets from config for: {ns.config_offsets|join(', ')}"
    {% endif %}
    {% if ns.svf_offsets %}
        _VALID_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Offsets from save_variables for: {ns.svf_offsets|join(', ')}"
    {% endif %}
    {% if ns.both_offsets %}
        _WARNING_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Conflict: Both config and save_variables offsets for: {ns.both_offsets|join(', ')}"
    {% endif %}
    {% if ns.partial_svf %}
        _WARNING_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Partial offsets in save_variables for: {ns.partial_svf|join(', ')}"
    {% endif %}
    {% if ns.no_offsets %}
        _DEBUG_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | No offsets found for: {ns.no_offsets|join(', ')}"
    {% endif %}
        # todo: if it's present in both, tell the user, if some are present in one and some in others, tell the user. Only one shall be used.
        # todo: crawl config to look for other definitions of tool name/number offsets and report custom
        




#################################################################################################################
# _SHAPER_CONFIG_CHECK ##########################################################################################
#################################################################################################################
[gcode_macro _SHAPER_CONFIG_CHECK]
description:"checks the input shaper configuration and reports back missing settings."
variable_first_run: 1
gcode:
    {% if first_run %}
        {% if "input_shaper" in printer.configfile.config %}
            {% set input_shaper_keys = ["shaper_freq_x","shaper_freq_y","damping_ratio_x","damping_ratio_y"] %}
            {% set shaper_config = printer.configfile.config["input_shaper"] %}
            {% for key in input_shaper_keys %}
                {% if key not in shaper_config %}
                    _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} missing in [input_shaper]"
                {% else %}
                    #_VALID_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} defined in [input_shaper]"
                {% endif %}
            {% endfor %}
        {% else %}
            _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | [input_shaper] section missing in printer.cfg"
        {% endif %}
        {% set required_keys = ["params_input_shaper_freq_x","params_input_shaper_freq_y","params_input_shaper_damping_ratio_x","params_input_shaper_damping_ratio_y"] %}
        {% for name in printer.toolchanger.tool_names %}
            {% set tool_obj = printer[name] %}
            {% for key in required_keys %}
                {% if key not in tool_obj %}
                    _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} missing in [{name}]"
                {% else %}
                    #_VALID_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} defined in [{name}]"
                {% endif %}
            {% endfor %}
        {% endfor %}
        SET_GCODE_VARIABLE MACRO=_SHAPER_CONFIG_CHECK VARIABLE=first_run VALUE=0
    {% endif %}
    #TODO ADD ABILITY TO ALSO CHECK FOR DEFINITIONS IN THE SAVE_VARIABLES FILE
    #TODO ALSO CHECK THE [toolchanger] OBJECT AS AN OPTION OTHER THAN THE [input_shaper]
    #TODO _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | params_input_shaper_freq_x MUST BE EITHER DEFINED IN TOOLCHANGER OR shaper_freq_x IN INPUT SHAPER AS A FALLBACK





#################################################################################################################
# RESTORE_POSITION ##############################################################################################
#################################################################################################################
[gcode_macro RESTORE_POSITION]
description: "[X] [Y] [Z] (ABS(/GCODE/) X Y Z position)"
gcode:
  {% set actn = printer.tool_probe_endstop.active_tool_number|int %} 
  {% if actn != -1 %}
    {% set p = printer %}
    {% set svf = p.save_variables.variables %}
    # ----------------------------------------------------
    # Get old tool objects, offsets, and global z offset.
    # ----------------------------------------------------
    {% if p["gcode_macro TX"].old_tn|int != -1 %} # if no old tool, assume pos is already gcode.
      {% set old_tool = p[p.toolchanger.tool_names[p["gcode_macro TX"].old_tn|int]] %} # get from macro
      {% set old_key = 'offsets_' ~ old_tool.name|replace('tool ', '')|lower %}
      # get old offsets eiter from SVF or fallback to tool. 
      {% if old_key not in svf %} {% set old_off = {"x":old_tool.gcode_x_offset, "y":old_tool.gcode_y_offset, "z":old_tool.gcode_z_offset} %} _WARNING_RESPOND MSG="$RESTORE_POSITION$ | save variables key wasnt found, fallback to regular gcode offsets. This is highly UNRECOMMENDED!"
      {% else %} {% set old_off = svf[old_key]|default({"x":0, "y":0, "z":0}) %}{% endif %}
    {% else %} {% set old_off = {"x":0, "y":0, "z":0} %}
    {% endif %}
    {% set global_z_offset = p['gcode_macro TX'].global_z_offset|default(0)|float %}
    # -------------------------------------------------------------------------------------
    # Check if we want to restore to a different position. if not, use the values provided.
    # note that XYZ provided to the T calls should always be absolute space! 
    # absolute position is what you retrieve from printer.toolhead.position[0-2] anyways!
    # -------------------------------------------------------------------------------------
    # actual_position = restore_gcode_position - old_tool_offset + new_tool_offset
    # but since we already have new tool gcode offsets loaded here its
    # restore_gcode_position = actual_position - old_tool_offset
    # -------------------------------------------------------------------------------------
    {% set overwrite = printer["gcode_macro TX"].overwrite_next_restore_position %}
    {% set rp = dict() %}#todo figure out bed mesh stuff
    {% if overwrite and ('X' in overwrite) %}{% set _ = rp.update({'X': overwrite.X|float - old_off.x}) %}{% elif 'X' in params %}{% set _ = rp.update({'X': params.X|float - old_off.x}) %}{% endif %}
    {% if overwrite and ('Y' in overwrite) %}{% set _ = rp.update({'Y': overwrite.Y|float - old_off.y}) %}{% elif 'Y' in params %}{% set _ = rp.update({'Y': params.Y|float - old_off.y}) %}{% endif %}
    {% if overwrite and ('Z' in overwrite) %}{% set _ = rp.update({'Z': overwrite.Z|float - old_off.z - global_z_offset}) %}{% elif 'Z' in params %}{% set _ = rp.update({'Z': params.Z|float - old_off.z - global_z_offset}) %}{% endif %}
    {% if overwrite %}
      SET_GCODE_VARIABLE MACRO=TX VARIABLE=overwrite_next_restore_position VALUE="False"
    {% endif %}
    {% set new_tool = p[p.toolchanger.tool_names[actn]] %} # get from active
    {% set new_tool_fast = new_tool.params_fast_speed|float %}
    {% set new_tool_safe_y = new_tool.params_safe_y|float %}
    {% set new_tool_cur_pos = p.toolhead.position %}
    {% set new_tool_off = p.gcode_move.homing_origin %} #todo check if they are applied before we have to add them onto the restore pos
    
    # we have to move out of the docks no matter what (or else following G0 calls may rip docks)
    # note that if you add any X or Z movement before this, you should substract the current
    # gcode offsets, since tool dock space = absolute space
    # for example movement relative to the docks would be
    # G0 X{10 - new_tool_off[0]} would be absolute 10.
    ROUNDED_G0 Y={new_tool_safe_y} F={new_tool_fast} D=50
    # ----------------------------------
    # Actually restore the position now
    # ----------------------------------
    {% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z+10} F={new_tool_fast} D=150 {% endif %}
    {% if 'X' in rp %} ROUNDED_G0 X={rp.X|round(3)} F={new_tool_fast} D=1000 {% endif %}
    {% if 'Y' in rp %} ROUNDED_G0 Y={rp.Y|round(3)} F={new_tool_fast} D=20 {% endif %}
    {% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z} F={new_tool_fast//5} D=0 {% endif %}
    STATUS_READY
    ROUNDED_G0 D=0
  {% else %}
      _DEBUG_RESPOND MSG="$RESTORE_POSITION$ | cannot restore position, got no tool!"
  {% endif %}



[gcode_macro _SET_STORE]
description: M[macro] V[/VARIABLE/] K[key] S|A[value] (set/add) [/RESET/]
gcode:
  {% set p = params %}
  {% set m_name   = p.get('M', None) %}
  {% set m        = printer['gcode_macro ' ~ m_name]|default(None) %}
  {% set var_name = p.get(p.V, 'storage')%}
  {% set var = m.get(var_name, None) %}
  {% set key      = p.get('K', None) %}
  
  {% if m == None %} RESPOND TYPE=error MSG="cannot get macro '{m_name}'"
  {% elif var_name not in m %} RESPOND TYPE=error MSG="'{var_name}' not in '{m_name}'"
  {% elif p.get('RESET', None)|lower == 'true' %} SET_GCODE_VARIABLE MACRO={m_name} VARIABLE={var_name} VALUE={{}} # reset
  {% elif (m.get(var_name, None)).__class__.__name__ != "dict" %} RESPOND TYPE=error MSG="'{var_name}' in '{m_name}' is not of type 'dict'"
  {% elif ('A' in p and 'S' in p) or ('A' not in p and 'S' not in p) %} RESPOND TYPE=error MSG="either [S]'set' or [A]'add' (not both or none).
  {% elif key == None %} RESPOND TYPE=error MSG="missing [K]'key'"
  {% else %}
    {% set raw = p.get('A', p.get('S')) %}
    {% set val = raw %}
    # --------- list
    {% if raw.startswith('[') and raw.endswith(']') %}
      {% if key not in var or var.get(key, None).__class__.__name__ != "list" %} {% set _ = var.update({key: []}) %} {% endif %} # make sure it exists.
      {% set val = [] %}
      {% for t in raw[1:-1].split(',') %}
          {% set t = t.strip() %}
          {% if t and (t[0] in "-0123456789") and t.lstrip('-').replace('.','',1).isdigit() %} # parse values type
            {% set _ = val.append(t|float if '.' in t else t|int) %}
          {% elif t != '' %}
            {% set _ = val.append(t) %}
          {% else %}
            {% set _ = val.append([]) %}
          {% endif %}
      {% endfor %}
    # --------- regular number
    {% elif raw and (raw[0] in "-0123456789") and raw.lstrip('-').replace('.','',1).isdigit() %}
      {% set val = raw|float if '.' in raw else raw|int %}
    {% endif %}
    # ---------- SET ----------
    {% if 'S' in p %}
    {% set _ = var.update({key: val}) %}
    # ---------- ADD ----------
    {% elif val.__class__.__name__ == "list" %}
      {% for i in val %}{% set _ = var[key].append(i) %}{% endfor %}
    {% else %}
      RESPOND TYPE=error MSG="unable to parse"
    {% endif %}
    SET_GCODE_VARIABLE MACRO={m_name} VARIABLE={var_name} VALUE="{var}"
  {% endif %}





  [gcode_macro TEST_OFFSET_UI]
description: "Test UI for adjusting the X offset of Tool 1 by ±0.05mm"
gcode:
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set toolnum = 1 %}
  {% set toolname = p.toolchanger.tool_names[toolnum] %}
  {% set key = 'offsets_' ~ toolname|replace('tool ', '')|lower %}
  {% set stored = svf.get(key, {}) %}
  {% set current = (stored.x|default(0)|float)|round(3) %}

  # If the user clicked a button, adjust the saved X offset
  {% if params.AMOUNT is defined %}
    {% set delta = params.AMOUNT|float %}
    {% set new_val = (current + delta)|round(3) %}
    {% set _ = stored.update({'x': new_val}) %}
    SAVE_VARIABLE VARIABLE={key} VALUE="{stored}"
    {% set current = new_val %}
  {% endif %}

  # Begin a new popup titled "0.05"
  RESPOND TYPE=command MSG="action:prompt_begin 0.05"
  # Show the current X offset
  RESPOND TYPE=command MSG="action:prompt_text Current X Offset: {current} mm"
  # Two buttons: +0.05 and –0.05
  RESPOND TYPE=command MSG="action:prompt_button +0.05 |TEST_OFFSET_UI AMOUNT=0.05|primary"
  RESPOND TYPE=command MSG="action:prompt_button –0.05 |TEST_OFFSET_UI AMOUNT=-0.05|warning"
  # Show the popup
  RESPOND TYPE=command MSG="action:prompt_show"