[gcode_macro RECONSTRUCT_LITERAL_FROM_STRING]
description: "reconstructs literal from a string input as param or rawparams?"
gcode:
  {% set raw = params.DATA|default("") %}
  {% set ns = namespace(
    result=None,
    stack=[],              # List of all active containers
    key_stack=[],          # Dict keys waiting for values
    cur="",                # Current token
    quote="",              # Quote mode (' or ")
    i=0                    # Char index
  ) %}

  {% for _ in range(9999) %}
    {% if ns.i < raw|length %}
      {% set c = raw[ns.i] %}
      {% set ns.i = ns.i + 1 %}

      {% if c in [" ", "\n", "\t"] and ns.quote == "" %}
        # whitespace: do nothing

      {% elif c in ["'", '"'] %}
        {% set ns.quote = "" if ns.quote == c else c %}

      {% elif ns.quote %}
        {% set ns.cur = ns.cur ~ c %}

      {% elif c == ":" %}
        {% set _ = ns.key_stack.append(ns.cur.strip()) %}
        {% set ns.cur = "" %}

      {% elif c in [",", "]", "}"] %}
        {% if ns.cur|length > 0 %}
          {% set val_str = ns.cur.strip() %}
          {% set c0 = val_str[0] if val_str|length > 0 else "" %}
          {% set is_numberish = ("0" <= c0 <= "9") or c0 == "-" %}
          {% set is_boolish = val_str|lower in ["true", "false"] %}
          {% set val = 
            true if val_str|lower == "true" else
            false if val_str|lower == "false" else
            val_str|float if is_numberish and "." in val_str else
            val_str|int if is_numberish else
            val_str %}
          {% if ns.stack[-1].__class__.__name__ == "dict" %}
            {% set key = ns.key_stack.pop() %}
            {% set _ = ns.stack[-1].update({key: val}) %}
          {% else %}
            {% set _ = ns.stack[-1].append(val) %}
          {% endif %}
          {% set ns.cur = "" %}
        {% endif %}
        {% if c in ["]", "}"] %}
          {% set last = ns.stack.pop() %}
          {% if ns.stack|length == 0 %}
            {% set ns.result = last %}
          {% elif ns.stack[-1].__class__.__name__ == "dict" %}
            {% set key = ns.key_stack.pop() %}
            {% set _ = ns.stack[-1].update({key: last}) %}
          {% else %}
            {% set _ = ns.stack[-1].append(last) %}
          {% endif %}
        {% endif %}

      {% elif c == "[" %}
        {% set newlist = [] %}
        {% set _ = ns.stack.append(newlist) %}

      {% elif c == "{" %}
        {% set newdict = {} %}
        {% set _ = ns.stack.append(newdict) %}
        {% if ns.result == None %}
          {% set ns.result = newdict %}
        {% endif %}

      {% else %}
        {% set ns.cur = ns.cur ~ c %}
      {% endif %}
    {% endif %}
  {% endfor %}

  {action_respond_info("Parsed:\n" ~ ns.result|string)}



#########################################################################################
#    _STEPPER_Z_SOFT_TURN_ON    #########################################################
#########################################################################################
[gcode_macro _STEPPER_Z_SOFT_TURN_ON]
description: Softly ramp up Z stepper current to avoid loud bumps or PSU spikes
variable_default_steps: 5         # default ramp steps
variable_default_ramp_time: 250   # total ramp time in ms
gcode:
    {% if printer.stepper_enable.steppers.stepper_z %}
        # Already on — skip ramp
    {% else %}
        {% set steps = params.STEPS|default(default_steps)|int %}
        {% set ramp_time = params.RAMP_TIME|default(default_ramp_time)|float %}
        {% set step_delay = ramp_time / steps %}
        {% for i in range(steps) %}
            _SET_Z_STEPPER_CURRENT DUTY={i * (100 // steps)}
            G4 P{step_delay|int}
        {% endfor %}
        _SET_Z_STEPPER_CURRENT DUTY=100
    {% endif %}



#########################################################################################
#    _SET_Z_STEPPER_CURRENT    ##########################################################
#########################################################################################
[gcode_macro _SET_Z_STEPPER_CURRENT]
description: Provide a current percentage (0-100) for all Z TMC drivers
variable_found_steppers: None
gcode:
    {% set duty = params.DUTY|default(100)|int %}
    {% set z_steps = ['stepper_z', 'stepper_z1', 'stepper_z2', 'stepper_z3'] %}
    {% set drivers = ['tmc2130', 'tmc2208', 'tmc2209', 'tmc5160', 'tmc2240'] %}
    {% set ns = namespace(pairs=[]) %}

    {% if found_steppers == None %}
        # Step 1: find valid stepper-driver config sections
        {% for zstep in z_steps %}
            {% for drv in drivers %}
                {% set candidates = [drv ~ ' ' ~ zstep, drv ~ '_' ~ zstep] %}
                {% for key in candidates %}
                    {% if key in printer.configfile.settings %}
                        {% set _ = ns.pairs.append(zstep ~ ':' ~ key) %}
                    {% endif %}
                {% endfor %}
            {% endfor %}
        {% endfor %}

        {% if ns.pairs|length > 0 %}
            {% set valtosave = ns.pairs|join(',') %}
            SET_GCODE_VARIABLE MACRO=_SET_Z_STEPPER_CURRENT VARIABLE=found_steppers VALUE="{valtosave}"
        {% else %}
            RESPOND MSG="❌ No TMC Z drivers found."
        {% endif %}
    {% else %}
        {% set ns.pairs = found_steppers.split(',') %}
    {% endif %}

    {% set enable = printer.stepper_enable.steppers %}
    {% for entry in ns.pairs %}
        {% set parts = entry.split(':') %}
        {% set stepper = parts[0] %}
        {% set config_key = parts[1] %}
        {% set config = printer.configfile.settings[config_key]|default({}) %}
        {% set run = config.run_current|float %}
        {% set hold = config.hold_current|float %}
        {% set new_run = run * (duty / 100.0) %}
        {% set new_hold = hold * (duty / 100.0) %}

        {% if duty == 0 %}
            {% if stepper in enable and enable[stepper] %}
                SET_STEPPER_ENABLE STEPPER={stepper} ENABLE=0
            {% endif %}
            SET_TMC_CURRENT STEPPER={stepper} CURRENT={run} HOLDCURRENT={hold}
        {% else %}
            SET_TMC_CURRENT STEPPER={stepper} CURRENT={new_run} HOLDCURRENT={new_hold}
            {% if stepper not in enable or not enable[stepper] %}
                SET_STEPPER_ENABLE STEPPER={stepper} ENABLE=1
            {% endif %}
        {% endif %}
    {% endfor %}





[gcode_macro LOAD_SHAPERS]
description: "Loads shaper values from [save_variables] or [tool] or [input_shaper] sections.. 
variable_lastshapers: {}
variable_macro_html: "?tLoads shaper values from [save_variables] or [tool] or [input_shaper] sections.?p_LOAD_SHAPERS "
gcode:

  {% set msg = macro_html %}
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set actn = p.tool_probe_endstop.active_tool_number|int %}
  {% set ns = namespace(tns = "") %}
  {% if "input_shaper" in p.configfile.config %}

    # ──────| Get out tool/toolnumber (paramamter) |──────
    {% if rawparams %}
        {% set param0 = rawparams.split()[0] %}
        {% set ns.tns = "" %}
        {% for c in param0 %} {% set ns.tns = ns.tns ~ c if "0" <= c <= "9" %} {% endfor %}
        {% if ns.tns|length > 0 %}
              {% set tool_name = p.toolchanger.tool_names[ns.tns|int] %}
              {% set msg = msg ~ "?tTool: " ~ (tool_name|replace('tool ', '', 1)) ~ " (extracted from parameter " ~ param0 ~ ")" %}
        {% else %} {% set msg = msg ~ "?tFirst parameter provided should contain toolnumber, valid examples would be:?nABC=1?nTN=2?nT=T1?nTOOL='tool TX1'?nT=3?netc....?m?s2Provided '?c" ~ param0 ~ "?c' does not contain a valid tool number." %} {% endif %}
    {% endif %}

    # ──────| Get out tool/toolnumber (active tool) |──────
    {% if ns.tns|length == 0 and actn != -1 %}
        {% set tool_name = p.toolchanger.tool_names[actn] %}
        {% set msg = msg ~ "?tTool: " ~ tool_name|replace('tool ', '', 1) ~ " used (active tool)" %}
    {% elif ns.tns|length == 0 and actn == -1 %} {% set msg = msg ~ "?m?s3No tool parameter provided and no active tool available." %} {% endif %}
    #|────────────────────────────────────────────────────────────────────────────────────────|#
    # ──────| If we found one, load shapers from tool or config. |──────
    {% if tool_name %}
      {% set sk = ['freq_x', 'freq_y', 'damp_x', 'damp_y'] %} # names used internally here
      #🟨────────────────────────────────────────────────────────────────────────────────────────#
      #🟨 Define the sources for shaper values. 
      #🟨 feel free to add your own. dunno where else youd have them tho.
      #🟨────────────────────────────────────────────────────────────────────────────────────────#
      {% set sources = {
        "svf_tool": {"priority": 5,"data": svf.get("shapers_" ~ tool_name|replace('tool ', '', 1)|lower, {})},
        "tool_params": {"priority": 4,"data": p[tool_name]},
        "toolchanger_params": {"priority": 3,"data": p['toolchanger']},
        "svf_default": {"priority": 2,"data": svf.get("shapers_default", {})},
        "shaper_config": {"priority": 0,"data": p.configfile.config.get("input_shaper", {})}
      } %}
      # We search for keywords like shap and x and y, to map them to our values
      #🟨────────────────────────────────────────────────────────────────────────────────────────#
      #🟨 feel free to edit the ["freq", "x"] search terms.
      #🟨 do note however that terms like 'shaper' will likely result in issues if present in 
      #🟨 dampning ratio and frequency names.
      #🟨────────────────────────────────────────────────────────────────────────────────────────#
      {% set target_keys = {
        sk[0]:["freq", "x"],
        sk[1]:["freq", "y"],
        sk[2]:["damp", "x"],
        sk[3]:["damp", "y"]
      } %}

      # ──────| Build our dicts with priority. |──────
      {% set ns = namespace(available_shapers = {}, best = None, has_all=false, best_label = "", highest = -1) %}

      {% for label, obj in sources.items() %}
        {% set tmp = {"priority": obj.priority} %}
        {% for key in obj.data.keys() %}
          {% set val = obj.data.get(key, 0)|float %}
          {% for target, terms in target_keys.items() %}
            {% if terms[0] in key and terms[1] in key %}
              {% set _ = tmp.update({target: val}) %}
            {% endif %}
          {% endfor %}
        {% endfor %}
        {% if tmp|length > 1 %} # ───| means it contains at least 1 value beyond priority
          {% set _ = ns.available_shapers.update({label: tmp}) %}
        {% endif %}
      {% endfor %}
      # ---------------------------------------------------------------------- #
      # ──────| Sort our dicts for best valid found. |──────
      {% for label, entry in ns.available_shapers.items() %}
        {% set ns.has_all = true %}
        # set has_all false if its missing some (here we are just checking 0 and 1, so freq_x and freq_y)
        {% for rk in [sk[0], sk[1]] %}   
          {% if entry.get(rk, 0)|float == 0 %} {% set ns.has_all = false %} {% endif %}
        {% endfor %}
        # update the best one if its priority is higher.
        {% if ns.has_all and entry["priority"] > ns.highest %}
          {% set ns.best = entry %}
          {% set ns.best_label = label %}
          {% set ns.highest = entry["priority"] %}
        {% endif %}
      {% endfor %}

      {% if ns.best %}
        # ──────| damping to 0.1 if 0 |──────
        {% if ns.best[sk[2]]|default(0)|float == 0 %} {% set _ = ns.best.update({sk[2]: 0.1}) %} {% endif %}
        {% if ns.best[sk[3]]|default(0)|float == 0 %} {% set _ = ns.best.update({sk[3]: 0.1}) %} {% endif %}


        {% if lastshapers != ns.best %}
          {% set msg = msg ~ "?t?s0?tUpdate Status: Shaper values updated." %}
          SET_GCODE_VARIABLE MACRO=LOAD_SHAPERS VARIABLE=lastshapers VALUE="{ns.best}"
          SET_INPUT_SHAPER SHAPER_FREQ_X={ns.best[sk[0]]} SHAPER_FREQ_Y={ns.best[sk[1]]} DAMPING_RATIO_X={ns.best[sk[2]]} DAMPING_RATIO_Y={ns.best[sk[3]]}
        {% else %}
          {% set msg = msg ~ "?t?s0?tUpdate Status: Shaper values unchanged." %}
        {% endif %}
        {% set msg = msg ~ "?tFinal Values:" ~ "?n" ~ sk[0] ~ ": " ~ ns.best[sk[0]] ~ "   " ~ sk[1] ~ ": " ~ ns.best[sk[1]] ~ "?n" ~ sk[2] ~ ": " ~ ns.best[sk[2]] ~ "   " ~ sk[3] ~ ": " ~ ns.best[sk[3]] ~ "?nsource: " ~ ns.best_label|string %}
        {% set msg = msg ~ "?s0?mLoaded?c" ~ tool_name|replace('tool ', '', 1) ~ "?cshaper values from?c" ~ ns.best_label|string ~ "?c" %}
        #{% set msg = msg ~ "?D" ~ sk[0] ~ ": " ~ ns.best[sk[0]] ~ "?D" ~ sk[1] ~ ": " ~ ns.best[sk[1]] ~ "?D" ~ sk[2] ~ ": " ~ ns.best[sk[2]] ~ "?D" ~ sk[3] ~ ": " ~ ns.best[sk[3]] ~ "?Dsource: " ~ ns.best_label|string %}
      {% else %}
        {% set msg = msg ~ "?tSearched in:?n" ~ (sources.keys()|list|join('?n')) ~ "?s3?mNo valid shaper values found!" %}
      {% endif %}
    {% endif %} # i toolname
  {% else %}
    {% set msg = msg ~ "?tplease define '[input_shaper]' in order to load shapers. ?s3?m?c[input_shaper]?csection in printer is undefined." %}
  {% endif %}

  {% if params.SILENT is not defined and macro_html != msg %}
    {% if 'gcode_macro _UNIFIED_RESPOND' in printer %}
      _UNIFIED_RESPOND MSG="{msg}"
    {% else %}
      RESPOND {% if ('?s0' or '?s1') in msg %} TYPE='echo' {% else %} TYPE='error' {% endif %} MSG="{((msg|replace('?n','<br>')|replace('?m','<br>')|replace('?p','CUT_HERE')|replace('?t','<br>')|replace('?s0','')|replace('?s1','')|replace('?s2','!?')|replace('?s3','!')|replace('?s4','!!')|replace('?s5','!!!')|replace('?b',' !')|replace('?c',' *')).split('CUT_HERE'))[-1]}"
    {% endif %}
  {% endif %}


[gcode_macro HEAT_TOOLS_OLD]
description: Pre-heat multiple tools
variable_tol:           10 # ±°C band that counts as 'reached temp'
variable_default_max_heating: 2  # amount of tools to be allowed to heat at once
gcode:
  RESPOND MSG="{'HEAT_TOOLS: ' ~ rawparams}"
  {% set p          = printer %}
  {% set cfg        = p.configfile %}
  {% set tcs        = p['gcode_macro _toolchanger_settings'] %}
  {% set ps         = tcs.get('print_start', {}) %}
  {% set max_heat   = ps.get('max_tools_heating_at_once', default_max_heating)|int %}

  {% set cur_heating = [] %}
  {% set now_heating = [] %}

  # ---< small helpers
  {% macro tmp_param(n) -%}      {'T' ~ n ~ '_TEMP' if 'T' ~ n ~ '_TEMP' in params and params['T' ~ n ~ '_TEMP'] else ''} {%- endmacro %}
  {% macro is_temp_param(key) -%}{key and key.endswith('_TEMP') and key[0] == 'T' and key[1].isdigit()}                   {%- endmacro %}
  {% macro e_id(n)  -%} {'extruder' ~ (n > 0 and n|string or '')} {%- endmacro %}
  {% macro e_tmp(n) -%} {printer[e_id(n)].temperature}            {%- endmacro %}
  {% macro e_tgt(n) -%} {printer[e_id(n)].target}                 {%- endmacro %}

  # ---< get the ones that are currently heating up
  {% for tn in p.toolchanger.tool_numbers if e_id(tn) in printer %}
    {% if e_tmp(tn)|int + tol < e_tgt(tn)|int %}
      {% set _ = cur_heating.append(tn) %}
    {% endif %}
  {% endfor %}
  
  # ---< walk through parameters
  {% for key, temp in params|dictsort if is_temp_param(key) %}
    {% set tn   = key[1:-5]|int %}
    {% if 'WAIT' in params %}
      # ---< WAIT=True => heat up all sequentially, WAIT=False => force heat all
      {'M10' ~ ('9' if params.WAIT|lower == 'true' else '4') ~ 'T' ~ tn ~ ' S' ~ temp|int}
      # ---< Heat up more if we are heating less than two currently
    {% elif e_tgt(tn)|int < (temp|int - tol) and (cur_heating|length + now_heating|length) < max_heat %}
      M104 T{tn} S{temp}
      {% set _ = now_heating.append(tn) %}
    {% endif %}
  {% endfor %}



[gcode_macro _TC_UPDATE_OFFSETS_old]
description: stage tool offsets for save. Usage: _TC_UPDATE_OFFSETS TOOL=X [SAVE], stages the current 'tools_calibrate.last_result' to the toolnumber provided. 
variable_macro_html: "?tStage tool offsets for save.?nUsage: _TC_UPDATE_OFFSETS TOOL=X [SAVE]?nStages the current 'tools_calibrate.last_result' to the toolnumber provided?p_TC_UPDATE_OFFSETS "
variable_storage: {} # why all this gibberish? statistics. (and its easier to read if printed last, all at one place)
gcode:
  {% set p = printer %}
  {% set msg = macro_html %}
  {% set actn = p.tool_probe_endstop.active_tool_number|int %} 
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set oc = tcs.get('offset_calibration', {}) %}
  {% set has_probe = oc.get('probe_calibration', False) %}
  {% set r_svf = oc.get('value_rounding', 3)|int %}
  {% set svf_mode = tcs.get('svf_auto_repair', '') %}
  

  {% if actn != -1 %}
    # will run quiet if everything ok, its okay to call in same macro.
    # mainly because we will always first record some pos before saving it.
    {% if svf_mode in ['Always', 'Use'] %} _INIT_SVF_KEYS {% endif %}

    {% set svf = p.save_variables.variables %}
    {% if 'SAVE' in params %}
    #_TC_ADJUST_TTBZ_DRIFT
      {% set report = [] %}
      {% for tkey in storage %}
        # ──────────────────────────────────────────────────────────────────────────────────────────
        # Save the offsets with correct rounding.
        # ──────────────────────────────────────────────────────────────────────────────────────────
        {% set svf_key = 'offsets_' ~ tkey %}
        {% set temp_coords = storage[tkey] %} # our local queed offsets
        {% set old = svf.get(svf_key, {"x": 0.0, "y": 0.0, "z": 0.0}) %} # our current values from svf from all tools

        {% set new_rc = {
          "x": temp_coords.x|round(r_svf),
          "y": temp_coords.y|round(r_svf),
          "z": temp_coords.z|round(r_svf)
        } %}
        {% if has_probe %}
          {% set _ = new_rc.update({"probe": temp_coords.probe|round(r_svf)}) %}
        {% endif %}

        # ─────| Anything that isnt our first tool, just save, actually easy lol |─────
        {% if tkey[-1] != "0" %}
          SAVE_VARIABLE VARIABLE={svf_key} VALUE="{new_rc}"
        {% else %}
        # ─────| A bit funky here cause we have to specifically seperate probe pos from t0 offsets. |─────
          {% set old_pp = svf.get('probe_position', {}) %}
          {% set _ = old_pp.pop("probe", None) %}
          {% set pp = old_pp.copy() %}
          {% set _ = pp.update({ "x": new_rc.x, "y": new_rc.y, "z": new_rc.z }) %} 
          # ─────| Save probe pos |─────
          SAVE_VARIABLE VARIABLE=probe_position VALUE="{pp}"
          # move probe from local buffer to t0 offs.
          {% set _ = old.update({"probe": new_rc.probe}) if has_probe else None %} # update probe for t0
          # ─────| Save T0 pos |───── for t0, save the old offsets with new probe.
          SAVE_VARIABLE VARIABLE={svf_key} VALUE="{old}"  
          {% set _ = old.update(old_pp) %} # update our old positions again to do calcs later. (just overwrites xyz)
        {% endif %} # fix i think Probe 0 is missing in stats.

        # ──────────────────────────────────────────────────────────────────────────────────────────
        # After now theres just tooltips/statistics
        # ──────────────────────────────────────────────────────────────────────────────────────────
        {% set diff = { 
          "x": (old.x|default(0)|float - temp_coords.x)|round(r_svf), 
          "y": (old.y|default(0)|float - temp_coords.y)|round(r_svf), 
          "z": (old.z|default(0)|float - temp_coords.z)|round(r_svf) 
        } %}
        
        # Tooltip formatting
        {% set tooltip = "?tPos: X: " ~ temp_coords.x|round(2) ~ " Y: " ~ temp_coords.y|round(2) ~ " Z: " ~ temp_coords.z|round(2) %}
        {% set tooltip = tooltip ~ "?nDif: X: " ~ diff.x|round(2) ~ " Y: " ~ diff.y|round(2) ~ " Z: " ~ diff.z|round(2) %}
        {% if has_probe %}
          {% set probe_diff = (old.probe|default(-1)|float - temp_coords.probe|default(-1)|float)|round(2) %}
          {% set tooltip = tooltip ~ "?nZ Probe: Z: " ~ temp_coords.probe|round(2) ~ " Diff: " ~ probe_diff|round(2) %}
        {% endif %}
        # -----------------------------------------------------
        # Properly pad the results for display
        # -----------------------------------------------------
        {% set pad = "        " %}

        {% set x = temp_coords.x|round(r_svf) %}
        {% set y = temp_coords.y|round(r_svf) %}
        {% set z = temp_coords.z|round(r_svf) %}
        {% set px = temp_coords.probe|round(r_svf) if has_probe else "" %}

        # ---- stringify
        {% set xstr = x|string %} #todo rpad and {% macro %}
        {% set ystr = y|string %}
        {% set zstr = z|string %}
        {% set px_str = px|string if has_probe else "" %}

        {% set xstr_dif = diff.x|string %}
        {% set ystr_dif = diff.y|string %}
        {% set zstr_dif = diff.z|string %}
        {% set px_str_dif = probe_diff|string if has_probe else "" %}

        # ---- pad
        {% set xpad = pad[:8 - xstr|length] %}
        {% set ypad = pad[:8 - ystr|length] %}
        {% set zpad = pad[:8 - zstr|length] %}
        {% set ppad = pad[:8 - px_str|length] if has_probe else "" %}

        {% set xpad_dif = pad[:8 - xstr_dif|length] %}
        {% set ypad_dif = pad[:8 - ystr_dif|length] %}
        {% set zpad_dif = pad[:8 - zstr_dif|length] %}
        {% set ppad_dif = pad[:8 - px_str_dif|length] if has_probe else "" %}

        # ---- construct message
        {% set disp = tooltip ~ "?s0?mSaved ?c" ~ tkey|string|upper ~ "?c  offsets." %}
        {% set disp = disp ~ "?nAbs:  ?cX:" ~ xpad ~ xstr ~ "  Y:" ~ ypad ~ ystr ~ "  Z:" ~ zpad ~ zstr %}
        {% set disp = disp ~ " P:" ~ ppad ~ px_str ~ "?c?n" if has_probe else disp ~ "?c?n" %}

        {% set disp = disp ~ "Diff: ?cX:" ~ xpad_dif ~ xstr_dif ~ "  Y:" ~ ypad_dif ~ ystr_dif ~ "  Z:" ~ zpad_dif ~ zstr_dif %}
        {% set disp = disp ~ " P:" ~ ppad_dif ~ px_str_dif ~ "?c?n" if has_probe else disp ~ "?c?n" %}

        {% set _ = report.append(disp) %} # Append report
        
        # ──────────────────────────────────────────────────────────────────────────────────────────
        # Log parameters to rolling SVF if its enabled, with correct rounding
        # ──────────────────────────────────────────────────────────────────────────────────────────
        {% set logparams = "TN=" ~ tkey ~ " X=" ~ (temp_coords.x) ~ " Y=" ~ (temp_coords.y) ~ " Z=" ~ (temp_coords.z) %}
        {% set logparams = logparams ~ " PROBE=" ~ (temp_coords.probe) if has_probe else logparams %}
        _TC_LOG_OFFSET_HISTORY {logparams}
      {% endfor %}

      {% set msg = msg ~ '?s0?t?mSaved ?b' ~ storage|length|string ~ '?b  tool offsets?n' ~ report|join() %}
      SET_GCODE_VARIABLE MACRO=_TC_UPDATE_OFFSETS VARIABLE=storage VALUE={{}} # clear storage
    {% else %}
      # -----------------------------------------------------
      # This block below appends to the local macro variable
      # -----------------------------------------------------
      {% set ns = namespace(tn="", new = storage.copy()) %}
      {% if rawparams %} {% for c in rawparams.split()[0] %} {% set ns.tn = ns.tn ~ c if "0" <= c <= "9" else ns.tn %} {% endfor %} {% endif %}# retrieve number from first param provided
      {% if ns.tn|length > 0 %}  # if parameter provided
        {% set tn = p.toolchanger.tool_names[ns.tn|int]|replace("tool ", "")|lower %}
        # set last results
        {% set lastResult = p.tools_calibrate.last_result %}
        {% set temp_coords = {"x": lastResult[0], "y": lastResult[1], "z": lastResult[2]} %}
        # add probe
        {% if has_probe %} {% set _ = temp_coords.update({"probe": p.tools_calibrate.last_probe_offset|default(1)}) %} {% endif %}
        # save appended values
        {% set _ = ns.new.update({tn: temp_coords}) %}
        {% set msg = msg ~ "?s0?t" ~ temp_coords ~ "mQueed" ~ tn|upper ~ "for save..." %}
        SET_GCODE_VARIABLE MACRO=_TC_UPDATE_OFFSETS VARIABLE=storage VALUE="{ns.new}"
      {% else %}
        {% set msg = msg ~ "?s3?tFirst parameter provided should contain toolnumber, valid examples would be:?nABC=1?nTN=2?nT=T1?nTOOL='tool TX1'?netc....?mFirst parameter missing ?ctoolnum?c" %}
      {% endif %}
    {% endif %}
  {% else %}
    {% set msg = msg ~ "?s3?t?mNo active Tool, likely a crash. disabling for now." %}
  {% endif %}
  _UNIFIED_RESPOND MSG="{msg}"


#[gcode_macro M106]
#rename_existing: M106.1
#description: Override "M106" to account for multiple extruders.
#gcode:
#    {% set raw_speed = params.S|default(255)|float %}
#    {% set fan_speed = (raw_speed / 255.0)|round(2) %}
#    {% set fan_tool = 0 if (printer.toolchanger.tool_number|string) == "-1" else printer.toolchanger.tool_number|string %}
#    {% if (params.P) is defined %}
#      {% set P_fan = "part_fan_t" + params.P|string %}
#      SET_FAN_SPEED FAN={P_fan} SPEED={fan_speed}
#    {% else %}
#      SET_FAN_SPEED FAN="part_fan_t{fan_tool}" SPEED={fan_speed}
#    {% endif %}

#[gcode_macro M107]
#rename_existing: M107.1
#description: Override "M107" to account for multiple extruders.
#gcode:
#    # If we specified a fan, turn it off
#    {% if (params.P) is defined %}
#      M106 S0 P{params.P}
#    {% else %}
#      # Otherwise, turn off all part cooling fans
#      {% set num_tools = printer.toolchanger.tool_numbers|length|int %}
#      # Loop through the tools.
#      {% for i in range(num_tools) %}
#        # Turn off the fans
#        M106 S0 P{i}
#      {% endfor %}
#    {% endif %}





      #ROUNDED_G0 X={cur_pos.x + off.x} Y={safe_y//2} Z={cur_pos.z + off.z+5} F={fast} D=60#30 #todo change +10 to max limited
      #ROUNDED_G0 Y={safe_y//2} Z={cur_pos.z + off.z+10} F={fast} D=50


      #ROUNDED_G0 Y={safe_y} Z={cur_pos.z + off.z} F={fast} D=90
      # suicide {% if 'Z' in rp and 'Y' in rp and 'X' in rp %} ROUNDED_G0 X={rp.X} Y={rp.Y} Z={(rp.Z + cur_pos.z) / 2} F={fast} D=200 {% endif %}
      # suicide {% if 'Z' in rp and 'Y' in rp and 'X' in rp %} ROUNDED_G0 X={rp.X} Y={rp.Y} Z={rp.Z + 5} F={fast} D=5 {% endif %}
      # suicide {% if 'Z' in rp and 'Y' in rp and 'X' in rp %} ROUNDED_G0 X={rp.X} Y={rp.Y} Z={rp.Z} F={fast//5} D=0 {% endif %}
      
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Z={rp.Z} F={fast//5} D=0"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Z={((rp.Z + cur_pos.z) // 2)|round(3)} F={fast} D=70"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Y={rp.Y|round(3)} F={fast} D=50"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 X={rp.X|round(3)} F={fast} D=1000"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Y={safe_y//2} Z={cur_pos.z + off.z+10} F={fast} D=50"
      #_DEBUG_RESPOND MSG="$RESTORE_POSITION$ | ROUNDED_G0 Y={safe_y} F={fast} D=90"

#ROUNDED_G0 X={cur_pos.x + off.x} Y={safe_y} Z={cur_pos.z + off.z} F={fast} D=50 
#
#{% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z+1} F={fast} D=150 {% endif %}
#{% if 'X' in rp %} ROUNDED_G0 X={rp.X|round(3)} F={fast} D=1000 {% endif %}
#{% if 'Y' in rp %} ROUNDED_G0 Y={rp.Y|round(3)} F={fast} D=50 {% endif %}
#{% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z|round(3)} F={fast} D=5 {% endif %}
#
#{% if 'Z' in rp %} G0 Z{rp.Z} F{fast//5} {% endif %}

#
#ROUNDED_G0 Y=100 D=20
#ROUNDED_G0 Y=210 Z=350 D=100
#ROUNDED_G0 X=175 Y=175 Z=100 D=200
#ROUNDED_G0 X=175 Y=175 Z=10 D=0
#ROUNDED_G0 Y=175 X=175 D=500



#################################################################################################################
# _DETECT_OFFSET_TEMPLATE #######################################################################################
#################################################################################################################
[gcode_macro _DETECT_OFFSET_TEMPLATE]
description: "Detect common offset variable patterns and inconsistencies"
gcode:
    {% set ns = namespace(
        keys = printer|list,
        patterns = [],
        counts = [],
        zeroed = []
    ) %}

    {% for key in ns.keys %}
        {% if "_offset_" in key %}
            {% set parts = key.split('_') %}
            {% if parts|length >= 3 %}
                {% set templ = parts[0][:1] ~ '*_' ~ parts[1] ~ '_' ~ parts[2] %}
                {% set val = printer[key] %}
                {% set idx = -1 %}
                {% for i in range(ns.patterns|length) %}
                    {% if ns.patterns[i] == templ %}
                        {% set idx = i %}
                    {% endif %}
                {% endfor %}
                {% if idx == -1 %}
                    {% set ns.patterns = ns.patterns + [templ] %}
                    {% set ns.counts = ns.counts + [1 if val != 0 else 0] %}
                {% else %}
                    {% set ns.counts = ns.counts[:idx] + [ns.counts[idx] + (1 if val != 0 else 0)] + ns.counts[idx+1:] %}
                {% endif %}
                {% if val == 0 %}
                    {% set ns.zeroed = ns.zeroed + [key] %}
                {% endif %}
            {% endif %}
        {% endif %}
    {% endfor %}

    {% if ns.patterns|length > 0 %}
        {% set max_idx = 0 %}
        {% for i in range(1, ns.counts|length) %}
            {% if ns.counts[i] > ns.counts[max_idx] %}
                {% set max_idx = i %}
            {% endif %}
        {% endfor %}
        RESPOND TYPE=echo MSG="Most common offset pattern: {ns.patterns[max_idx]}"
        {% for i in range(ns.patterns|length) %}
            RESPOND TYPE=echo MSG="{ns.patterns[i]} → {ns.counts[i]} offset(s)"
        {% endfor %}
    {% else %}
        RESPOND TYPE=echo MSG="No offset-style variables found."
    {% endif %}

    {% if ns.zeroed %}
        RESPOND TYPE=echo MSG="Zero (undefined) offsets: {ns.zeroed|join(', ')}"
    {% endif %}




#################################################################################################################
# _GCODE_OFFSET_AUTODETECT ######################################################################################
#################################################################################################################
[gcode_macro _GCODE_OFFSET_AUTODETECT]
description: Autodetects offset source (tool config vs save_variables) and reports issues.
variable_gcode_offsets_in_tools: 0
variable_gcode_offsets_in_safe_vars: 0
gcode:

   {% set tool_names = printer.toolchanger.tool_names %}
    {% set svf = printer.save_variables.variables if "save_variables" in printer.configfile.config else {} %}
    {% set ns = namespace(
        config_offsets=[], svf_offsets=[], both_offsets=[], partial_svf=[], no_offsets=[]
    ) %}

    {% for tool_name in tool_names %}
        {% set tool = printer[tool_name] %}
        {% set tn = tool_name|string|replace('tool ', '', 1)|lower %}

        {% set config_has_offset = tool.gcode_x_offset != 0 or tool.gcode_y_offset != 0 or tool.gcode_z_offset != 0 %}
        {% set svf_x = tn ~ '_offset_x' %}
        {% set svf_y = tn ~ '_offset_y' %}
        {% set svf_z = tn ~ '_offset_z' %}
        {% set svf_has_all = svf_x in svf and svf_y in svf and svf_z in svf %}
        {% set svf_has_any = svf_x in svf or svf_y in svf or svf_z in svf %}

        {% if config_has_offset and not svf_has_any %}
            {% set ns.config_offsets = ns.config_offsets + [tool_name] %}
        {% elif svf_has_all and not config_has_offset %}
            {% set ns.svf_offsets = ns.svf_offsets + [tool_name] %}
        {% elif config_has_offset and svf_has_all %}
            {% set ns.both_offsets = ns.both_offsets + [tool_name] %}
        {% elif svf_has_any and not svf_has_all %}
            {% set ns.partial_svf = ns.partial_svf + [tool_name] %}
        {% else %}
            {% set ns.no_offsets = ns.no_offsets + [tool_name] %}
        {% endif %}
    {% endfor %}

    ; Report Results
    {% if ns.config_offsets %}
        _VALID_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Offsets from config for: {ns.config_offsets|join(', ')}"
    {% endif %}
    {% if ns.svf_offsets %}
        _VALID_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Offsets from save_variables for: {ns.svf_offsets|join(', ')}"
    {% endif %}
    {% if ns.both_offsets %}
        _WARNING_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Conflict: Both config and save_variables offsets for: {ns.both_offsets|join(', ')}"
    {% endif %}
    {% if ns.partial_svf %}
        _WARNING_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | Partial offsets in save_variables for: {ns.partial_svf|join(', ')}"
    {% endif %}
    {% if ns.no_offsets %}
        _DEBUG_RESPOND MSG="$_GCODE_OFFSET_AUTODETECT$ | No offsets found for: {ns.no_offsets|join(', ')}"
    {% endif %}
        # todo: if it's present in both, tell the user, if some are present in one and some in others, tell the user. Only one shall be used.
        # todo: crawl config to look for other definitions of tool name/number offsets and report custom
        




#################################################################################################################
# _SHAPER_CONFIG_CHECK ##########################################################################################
#################################################################################################################
[gcode_macro _SHAPER_CONFIG_CHECK]
description:"checks the input shaper configuration and reports back missing settings."
variable_first_run: 1
gcode:
    {% if first_run %}
        {% if "input_shaper" in printer.configfile.config %}
            {% set input_shaper_keys = ["shaper_freq_x","shaper_freq_y","damping_ratio_x","damping_ratio_y"] %}
            {% set shaper_config = printer.configfile.config["input_shaper"] %}
            {% for key in input_shaper_keys %}
                {% if key not in shaper_config %}
                    _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} missing in [input_shaper]"
                {% else %}
                    #_VALID_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} defined in [input_shaper]"
                {% endif %}
            {% endfor %}
        {% else %}
            _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | [input_shaper] section missing in printer.cfg"
        {% endif %}
        {% set required_keys = ["params_input_shaper_freq_x","params_input_shaper_freq_y","params_input_shaper_damping_ratio_x","params_input_shaper_damping_ratio_y"] %}
        {% for name in printer.toolchanger.tool_names %}
            {% set tool_obj = printer[name] %}
            {% for key in required_keys %}
                {% if key not in tool_obj %}
                    _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} missing in [{name}]"
                {% else %}
                    #_VALID_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | {key} defined in [{name}]"
                {% endif %}
            {% endfor %}
        {% endfor %}
        SET_GCODE_VARIABLE MACRO=_SHAPER_CONFIG_CHECK VARIABLE=first_run VALUE=0
    {% endif %}
    #TODO ADD ABILITY TO ALSO CHECK FOR DEFINITIONS IN THE SAVE_VARIABLES FILE
    #TODO ALSO CHECK THE [toolchanger] OBJECT AS AN OPTION OTHER THAN THE [input_shaper]
    #TODO _WARNING_RESPOND MSG="$_SHAPER_CONFIG_CHECK$ | params_input_shaper_freq_x MUST BE EITHER DEFINED IN TOOLCHANGER OR shaper_freq_x IN INPUT SHAPER AS A FALLBACK





#################################################################################################################
# RESTORE_POSITION ##############################################################################################
#################################################################################################################
[gcode_macro RESTORE_POSITION]
description: "[X] [Y] [Z] (ABS(/GCODE/) X Y Z position)"
gcode:
  {% set actn = printer.tool_probe_endstop.active_tool_number|int %} 
  {% if actn != -1 %}
    {% set p = printer %}
    {% set svf = p.save_variables.variables %}
    # ----------------------------------------------------
    # Get old tool objects, offsets, and global z offset.
    # ----------------------------------------------------
    {% if p["gcode_macro TX"].old_tn|int != -1 %} # if no old tool, assume pos is already gcode.
      {% set old_tool = p[p.toolchanger.tool_names[p["gcode_macro TX"].old_tn|int]] %} # get from macro
      {% set old_key = 'offsets_' ~ old_tool.name|replace('tool ', '')|lower %}
      # get old offsets eiter from SVF or fallback to tool. 
      {% if old_key not in svf %} {% set old_off = {"x":old_tool.gcode_x_offset, "y":old_tool.gcode_y_offset, "z":old_tool.gcode_z_offset} %} _WARNING_RESPOND MSG="$RESTORE_POSITION$ | save variables key wasnt found, fallback to regular gcode offsets. This is highly UNRECOMMENDED!"
      {% else %} {% set old_off = svf[old_key]|default({"x":0, "y":0, "z":0}) %}{% endif %}
    {% else %} {% set old_off = {"x":0, "y":0, "z":0} %}
    {% endif %}
    {% set global_z_offset = p['gcode_macro TX'].global_z_offset|default(0)|float %}
    # -------------------------------------------------------------------------------------
    # Check if we want to restore to a different position. if not, use the values provided.
    # note that XYZ provided to the T calls should always be absolute space! 
    # absolute position is what you retrieve from printer.toolhead.position[0-2] anyways!
    # -------------------------------------------------------------------------------------
    # actual_position = restore_gcode_position - old_tool_offset + new_tool_offset
    # but since we already have new tool gcode offsets loaded here its
    # restore_gcode_position = actual_position - old_tool_offset
    # -------------------------------------------------------------------------------------
    {% set overwrite = printer["gcode_macro TX"].overwrite_next_restore_position %}
    {% set rp = dict() %}#todo figure out bed mesh stuff
    {% if overwrite and ('X' in overwrite) %}{% set _ = rp.update({'X': overwrite.X|float - old_off.x}) %}{% elif 'X' in params %}{% set _ = rp.update({'X': params.X|float - old_off.x}) %}{% endif %}
    {% if overwrite and ('Y' in overwrite) %}{% set _ = rp.update({'Y': overwrite.Y|float - old_off.y}) %}{% elif 'Y' in params %}{% set _ = rp.update({'Y': params.Y|float - old_off.y}) %}{% endif %}
    {% if overwrite and ('Z' in overwrite) %}{% set _ = rp.update({'Z': overwrite.Z|float - old_off.z - global_z_offset}) %}{% elif 'Z' in params %}{% set _ = rp.update({'Z': params.Z|float - old_off.z - global_z_offset}) %}{% endif %}
    {% if overwrite %}
      SET_GCODE_VARIABLE MACRO=TX VARIABLE=overwrite_next_restore_position VALUE="False"
    {% endif %}
    {% set new_tool = p[p.toolchanger.tool_names[actn]] %} # get from active
    {% set new_tool_fast = new_tool.params_fast_speed|float %}
    {% set new_tool_safe_y = new_tool.params_safe_y|float %}
    {% set new_tool_cur_pos = p.toolhead.position %}
    {% set new_tool_off = p.gcode_move.homing_origin %} #todo check if they are applied before we have to add them onto the restore pos
    
    # we have to move out of the docks no matter what (or else following G0 calls may rip docks)
    # note that if you add any X or Z movement before this, you should substract the current
    # gcode offsets, since tool dock space = absolute space
    # for example movement relative to the docks would be
    # G0 X{10 - new_tool_off[0]} would be absolute 10.
    ROUNDED_G0 Y={new_tool_safe_y} F={new_tool_fast} D=50
    # ----------------------------------
    # Actually restore the position now
    # ----------------------------------
    {% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z+10} F={new_tool_fast} D=150 {% endif %}
    {% if 'X' in rp %} ROUNDED_G0 X={rp.X|round(3)} F={new_tool_fast} D=1000 {% endif %}
    {% if 'Y' in rp %} ROUNDED_G0 Y={rp.Y|round(3)} F={new_tool_fast} D=20 {% endif %}
    {% if 'Z' in rp %} ROUNDED_G0 Z={rp.Z} F={new_tool_fast//5} D=0 {% endif %}
    STATUS_READY
    ROUNDED_G0 D=0
  {% else %}
      _DEBUG_RESPOND MSG="$RESTORE_POSITION$ | cannot restore position, got no tool!"
  {% endif %}



[gcode_macro _SET_STORE]
description: M[macro] V[/VARIABLE/] K[key] S|A[value] (set/add) [/RESET/]
gcode:
  {% set p = params %}
  {% set m_name   = p.get('M', None) %}
  {% set m        = printer['gcode_macro ' ~ m_name]|default(None) %}
  {% set var_name = p.get(p.V, 'storage')%}
  {% set var = m.get(var_name, None) %}
  {% set key      = p.get('K', None) %}
  
  {% if m == None %} RESPOND TYPE=error MSG="cannot get macro '{m_name}'"
  {% elif var_name not in m %} RESPOND TYPE=error MSG="'{var_name}' not in '{m_name}'"
  {% elif p.get('RESET', None)|lower == 'true' %} SET_GCODE_VARIABLE MACRO={m_name} VARIABLE={var_name} VALUE={{}} # reset
  {% elif (m.get(var_name, None)).__class__.__name__ != "dict" %} RESPOND TYPE=error MSG="'{var_name}' in '{m_name}' is not of type 'dict'"
  {% elif ('A' in p and 'S' in p) or ('A' not in p and 'S' not in p) %} RESPOND TYPE=error MSG="either [S]'set' or [A]'add' (not both or none).
  {% elif key == None %} RESPOND TYPE=error MSG="missing [K]'key'"
  {% else %}
    {% set raw = p.get('A', p.get('S')) %}
    {% set val = raw %}
    # --------- list
    {% if raw.startswith('[') and raw.endswith(']') %}
      {% if key not in var or var.get(key, None).__class__.__name__ != "list" %} {% set _ = var.update({key: []}) %} {% endif %} # make sure it exists.
      {% set val = [] %}
      {% for t in raw[1:-1].split(',') %}
          {% set t = t.strip() %}
          {% if t and (t[0] in "-0123456789") and t.lstrip('-').replace('.','',1).isdigit() %} # parse values type
            {% set _ = val.append(t|float if '.' in t else t|int) %}
          {% elif t != '' %}
            {% set _ = val.append(t) %}
          {% else %}
            {% set _ = val.append([]) %}
          {% endif %}
      {% endfor %}
    # --------- regular number
    {% elif raw and (raw[0] in "-0123456789") and raw.lstrip('-').replace('.','',1).isdigit() %}
      {% set val = raw|float if '.' in raw else raw|int %}
    {% endif %}
    # ---------- SET ----------
    {% if 'S' in p %}
    {% set _ = var.update({key: val}) %}
    # ---------- ADD ----------
    {% elif val.__class__.__name__ == "list" %}
      {% for i in val %}{% set _ = var[key].append(i) %}{% endfor %}
    {% else %}
      RESPOND TYPE=error MSG="unable to parse"
    {% endif %}
    SET_GCODE_VARIABLE MACRO={m_name} VARIABLE={var_name} VALUE="{var}"
  {% endif %}





  [gcode_macro TEST_OFFSET_UI]
description: "Test UI for adjusting the X offset of Tool 1 by ±0.05mm"
gcode:
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set toolnum = 1 %}
  {% set toolname = p.toolchanger.tool_names[toolnum] %}
  {% set key = 'offsets_' ~ toolname|replace('tool ', '')|lower %}
  {% set stored = svf.get(key, {}) %}
  {% set current = (stored.x|default(0)|float)|round(3) %}

  # If the user clicked a button, adjust the saved X offset
  {% if params.AMOUNT is defined %}
    {% set delta = params.AMOUNT|float %}
    {% set new_val = (current + delta)|round(3) %}
    {% set _ = stored.update({'x': new_val}) %}
    SAVE_VARIABLE VARIABLE={key} VALUE="{stored}"
    {% set current = new_val %}
  {% endif %}

  # Begin a new popup titled "0.05"
  RESPOND TYPE=command MSG="action:prompt_begin 0.05"
  # Show the current X offset
  RESPOND TYPE=command MSG="action:prompt_text Current X Offset: {current} mm"
  # Two buttons: +0.05 and –0.05
  RESPOND TYPE=command MSG="action:prompt_button +0.05 |TEST_OFFSET_UI AMOUNT=0.05|primary"
  RESPOND TYPE=command MSG="action:prompt_button –0.05 |TEST_OFFSET_UI AMOUNT=-0.05|warning"
  # Show the popup
  RESPOND TYPE=command MSG="action:prompt_show"