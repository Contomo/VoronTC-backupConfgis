



#---------------------------------< Thermal, interpolating between min and max for provided tn
[display_template thermal]
param_tn: 'None'
param_min_temp: 40
param_max_temp: 120
text:
  {% set P = printer %}
  {% set min_t = param_min_temp %}
  {% set max_t = param_max_temp %}
  {% set cur_t = P[P[P.toolchanger.tool_names[param_tn|int]].extruder].temperature|float %}
  {% set colors = P['gcode_macro _toolchanger_led_vars'].get('colors', {}).get('thermal', {}) %}
  {% set c = colors.get('cold',{'r':0.0, 'g':0.0, 'b':1.0, 'w':0.0}) %}
  {% set h = colors.get('hot', {'r':1.0, 'g':0.0, 'b':0.0, 'w':0.0}) %}
  {% set p = [[0.0, (cur_t - min_t) / [(max_t - min_t)|abs, 0.01]|max]|max, 1.0]|min %}
  {% set s = 0.2 if param_tn|int != P.tool_probe_endstop.active_tool_number|int else 1.0 %}
  {(c.r + (h.r - c.r) * p )* s},{(c.g + (h.g - c.g) * p)* s},{(c.b + (h.b - c.b) * p)* s},{(c.w + (h.w - c.w) * p)* s}


#---------------------------------< name says it all
[display_template fast-equals-bright]
text:
  {% set p = printer.motion_report.live_velocity|abs/100 %}
  {p},{p},{p},{p}


#---------------------------------< change max idx for gradient (larger -> longer rainbow, shorter -> more rainbow)
[display_template rainbow]
param_idx: 0
param_max_idx: 20
text:
  {% set num_leds = param_max_idx|float + 1.0 %}
  {% set idx = param_idx|float %}
  {% set print_time = printer.toolhead.estimated_print_time|float / 30.0 %}
  {% set hue = (idx / num_leds + print_time) %}
  {% set hue = hue - (hue|int) %}
  # ---< HSV rainbow math: v=1, s=1, hue=0..1
  {% set h = hue * 6.0 %}
  {% set i = h|int %}
  {% set f = h - i %}
  {% set q = 1.0 - f %}
  {% set rgb_map = [
    [1.0, f, 0.0],
    [q, 1.0, 0.0],
    [0.0, 1.0, f],
    [0.0, q, 1.0],
    [f, 0.0, 1.0],
    [1.0, 0.0, q]
  ] %}
  {% set r = rgb_map[i % 6][0] %}
  {% set g = rgb_map[i % 6][1] %}
  {% set b = rgb_map[i % 6][2] %}
  {r},{g},{b},0


#---------------------------------< main logo template autodetects:
#---< homing, calibrating, qgl, idle, printing, used in print
#---< toolchanging
[display_template logo]
param_tn: 'None'
param_brightness: 1.0
param_idx: 0
text:
  # ---< pos/speed tolerance for autodetect.
  {% set tol     = 0.1 %}
  {% set vel_tol = 0.1 %}
  # ---< short terms
  {% set p       = printer %}
  {% set th      = p.toolhead %}
  {% set tc      = p.toolchanger %}
  {% set cfg     = p.configfile.settings %}
  {% set tool    = p[tc.tool_names[param_tn|int]] %}
  {% set ledvars = p['gcode_macro _toolchanger_led_vars'] %}

  # ---< keeping track and getting main settings
  {% set colors  = ledvars.get('colors', {}).get('logo', {}) %}
  {% set c       = {'r':0, 'g':0, 'b':0, 'w':0} %}
  {% set ns      = namespace(doing_qgl=False, at_homing_speed=False, at_probing_speed=False, out_of_bounds=False) %}
  {% set invert  = False %}

  # ---< needed variables in here.
  {% set th_pos       = th.position %}
  {% set now          = th.estimated_print_time %}
  {% set target_temp  = p[tool.extruder].target %}
  {% set qgl_points   = cfg.quad_gantry_level.points %}
  {% set probe_name   = p.tool_probe_endstop.active_tool_probe %}
  {% set actn         = p.tool_probe_endstop.active_tool_number %}
  {% set current_vel  = p.motion_report.live_velocity %}
  {% set speed_factor = p.gcode_move.speed_factor %}
  
  {% set status_overwrite = ledvars.get('status', {}).get(actn, None) %}
  {% set status = status_overwrite if status_overwrite is not none else 'standby' %}
  {% if actn == param_tn|int and status == 'standby' %}
    {% if p.idle_timeout.state != 'Ready'  %}
      # ---< busy, will be overwritten with anything specifically busy...
      {% set status = 'busy' %}

      # ---< check if at probing speed
      {% for speed_name in ['speed', 'lift_speed'] if probe_name %}
        {% set ns.at_probing_speed = True if (current_vel - (cfg[probe_name|lower][speed_name] * speed_factor))|abs < vel_tol else ns.at_probing_speed %}
      {% endfor %}

      # ---< check if at homing speed
      {% for step in ['stepper_x', 'stepper_y', 'stepper_z'] %}
        {% for speed_name in ['homing_speed', 'homing_retract_speed', 'second_homing_speed']%}
          {% set ns.at_homing_speed = True if ((cfg[step][speed_name]) - current_vel)|abs < vel_tol else ns.at_homing_speed %}
        {% endfor %}
      {% endfor %}

      # ---< check if at out of bounds (probably homing)
      {% for i in range(3) %}
          {% set ns.out_of_bounds = True if th_pos[i] <= th.axis_minimum[i] or th_pos[i] >= th.axis_maximum[i] or th_pos[i] == 0.0 else ns.out_of_bounds %}
      {% endfor %}

      # ---< check if on lines of â–¡ with some tolerance and at or below QGL move height
      {% set coords = {'x': qgl_points|map(attribute=0)|list, 'y': qgl_points|map(attribute=1)|list} %}
      {% for ax, xa in [('x','y'), ('y','x')] %}
        {% if (th_pos[ax] - coords[ax]|min)|abs < tol or (th_pos[ax] - coords[ax]|max)|abs < tol %}
          {% if (coords[xa]|min - tol) <= th_pos[xa] <= (coords[xa]|max + tol) %}
            {% set ns.doing_qgl = True if th_pos[2] <= cfg.quad_gantry_level.horizontal_move_z + tol else ns.doing_qgl %}
          {% endif %}
        {% endif %}
      {% endfor %}

      # ---< set status according to what we are checking for
      {% set status = 'homing'      if ns.at_homing_speed or ns.at_probing_speed or ns.out_of_bounds else status %}
      {% set status = 'leveling'    if ns.doing_qgl else status %}
      {% set status = 'printing'    if p.idle_timeout.state == 'printing' else status %}
      {% set status = 'calibrating' if not p.tools_calibrate.calibration_probe_inactive else status %}
      {% set status = 'changing'    if tc.status == 'changing' else status %}

      # ---< safe to assume that currently probing (works sorta okay, just updates too slow)
      #{% set invert = True if ns.at_probing_speed and status in ['leveling', 'homing'] and ns.at_qgl_point else invert %}
      
    {% endif %}
  {% elif status == 'standby' %}
    {% set status = 'busy' if target_temp != 0 else status %}
  {% endif %}
  {% set status = 'changed' if tc.status == 'changing' and actn != tc.tool_number else status %}

  # ---< update values for the status we have and invert if needed, scale brightness
  {% set status_color = colors.get(status, colors.get('standby', {})) %}

  # ---< check if its RGBW we got, or a named template to run
  {% if status_color is mapping %}
    {% for e in c.keys() %}
      {% set val = status_color.get(e, 0) %}
      {% set _ = c.update({e: ((val-1)|abs if invert else val) * param_brightness|float}) %}
    {% endfor %}
  # ---< adds 0.004 (1/255) to the largest value for 0.5 sec to force klipper to update it
  {% set kv = c|dictsort('value')|last if c.r or c.g or c.b or c.w else [] %}
  {% if kv[1] %} {% set _ = c.update({kv[0]: kv[1] + ((((now/0.5)|int % 2)*2 - 1) * 0.004)}) %} {% endif %}
  # ---< push leds out
  {c.r},{c.g},{c.b},{c.w}
  {% else %}
    {render(status_color, param_idx=param_idx)}
  {% endif %}
  
  
