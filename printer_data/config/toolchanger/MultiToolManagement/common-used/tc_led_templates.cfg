

# parameters are automatically passed onto these 
#
# param_idx, param_tn
# 
# you can use these in your templates to add special behaviour



#---------------------------------< name says it all
[display_template fast-equals-bright]
text:
  {% set p = printer.motion_report.live_velocity|abs/100 %}
  {p},{p},{p},{p}


#---------------------------------< change max idx for gradient (larger -> longer rainbow, shorter -> more rainbow)
[display_template rainbow]
param_idx: 0
param_max_idx: 20
text:
  {% set num_leds = param_max_idx|float + 1.0 %}
  {% set idx = param_idx|float %}
  {% set print_time = printer.toolhead.estimated_print_time|float / 30.0 %}
  {% set hue = (idx / num_leds + print_time) %}
  {% set hue = hue - (hue|int) %}
  # ---< HSV rainbow math: v=1, s=1, hue=0..1
  {% set h = hue * 6.0 %}
  {% set i = h|int %}
  {% set f = h - i %}
  {% set q = 1.0 - f %}
  {% set rgb_map = [
    [1.0, f, 0.0],
    [q, 1.0, 0.0],
    [0.0, 1.0, f],
    [0.0, q, 1.0],
    [f, 0.0, 1.0],
    [1.0, 0.0, q]
  ] %}
  {% set r = rgb_map[i % 6][0] %}
  {% set g = rgb_map[i % 6][1] %}
  {% set b = rgb_map[i % 6][2] %}
  {r},{g},{b},0


[display_template different-color-per-tool]
param_tn: None
text:
  {% if param_tn == 0 %}
    1,0,0,0
  {% elif param_tn == 1 %}
    0,1,0,0
  {% else %} # etc....
    0,0,1,0
  {% endif %}





####################################### MAIN LED TEMPLATES FOR NOZZLE AND LOGO #######################################

#---< main logo template autodetects: 
# - homing, calibrating, qgl, idle
# - toolchanging, printing, used in print
[display_template logo]
param_tn: 'None'
param_brightness: 1.0
param_idx: 0
text:
  # ---< pos/speed tolerance for autodetect.
  {% set tol     = 0.1 %}
  {% set vel_tol = 0.1 %}
  # ---< short terms
  {% set p       = printer %}
  {% set th      = p.toolhead %}
  {% set tc      = p.toolchanger %}
  {% set cfg     = p.configfile.settings %}
  {% set tool    = p[tc.tool_names[param_tn|int]] %}
  {% set ledvars = p['gcode_macro _toolchanger_led_vars'] %}
  {% set bright  = param_brightness|float %}
  {% set rend_pa = {} %}
  # ---< keeping track and getting main settings
  {% set colors  = ledvars.get('colors', {}).get('logo', {}) %}
  {% set c       = {'r':0, 'g':0, 'b':0, 'w':0} %}
  {% set ns      = namespace(doing_qgl=False, at_homing_speed=False, at_probing_speed=False, out_of_bounds=False) %}
  {% set invert  = False %}
  # ---< needed variables in here.
  {% set th_pos       = th.position %}
  {% set now          = th.estimated_print_time %}
  {% set target_temp  = p[tool.extruder].target %}
  {% set qgl_points   = cfg.quad_gantry_level.points %}
  {% set probe_name   = p.tool_probe_endstop.active_tool_probe %}
  {% set actn         = p.tool_probe_endstop.active_tool_number %}
  {% set current_vel  = p.motion_report.live_velocity %}
  {% set speed_factor = p.gcode_move.speed_factor %}
  
  # ----------------------------- STATUS DETECTION -----------------------------
  {% set status = ledvars.get('status', {}).get('logo', {}).get(actn, 'standby') %}
  {% if actn == param_tn|int and status == 'standby' %}
    {% if p.idle_timeout.state|lower != 'ready'  %}
      # ---< busy, will be overwritten with anything specifically busy...
      {% set status = 'busy' %}

      # ---< check if at probing speed
      {% for speed_name in ['speed', 'lift_speed'] if probe_name %}
        {% set ns.at_probing_speed = True if (current_vel - (cfg[probe_name|lower][speed_name] * speed_factor))|abs < vel_tol else ns.at_probing_speed %}
      {% endfor %}

      # ---< check if at homing speed
      {% for step in ['stepper_x', 'stepper_y', 'stepper_z'] %}
        {% for speed_name in ['homing_speed', 'homing_retract_speed', 'second_homing_speed'] if speed_name in cfg[step] %}
          {% set ns.at_homing_speed = True if ((cfg[step][speed_name]) - current_vel)|abs < vel_tol else ns.at_homing_speed %}
        {% endfor %}
      {% endfor %}

      # ---< check if at out of bounds (probably homing)
      {% for i in range(3) %}
          {% set ns.out_of_bounds = True if th_pos[i] <= th.axis_minimum[i] or th_pos[i] >= th.axis_maximum[i] or th_pos[i] == 0.0 else ns.out_of_bounds %}
      {% endfor %}

      # ---< check if on lines of â–¡ with some tolerance and at or below QGL move height
      {% set coords = {'x': qgl_points|map(attribute=0)|list, 'y': qgl_points|map(attribute=1)|list} %}
      {% for ax, xa in [('x','y'), ('y','x')] %}
        {% if (th_pos[ax] - coords[ax]|min)|abs < tol or (th_pos[ax] - coords[ax]|max)|abs < tol %}
          {% if (coords[xa]|min - tol) <= th_pos[xa] <= (coords[xa]|max + tol) %}
            {% set ns.doing_qgl = True if th_pos[2] <= cfg.quad_gantry_level.horizontal_move_z + tol else ns.doing_qgl %}
          {% endif %}
        {% endif %}
      {% endfor %}
      # ---< set status according to what we are checking for
      {% set status = 'homing'      if ns.at_homing_speed or ns.at_probing_speed or ns.out_of_bounds else status %}
      {% set status = 'leveling'    if ns.doing_qgl else status %}
      {% set status = 'printing'    if p.idle_timeout.state|lower == 'printing' else status %}
      {% set status = 'calibrating' if not p.tools_calibrate.calibration_probe_inactive else status %}
      {% set status = 'changing'    if tc.status == 'changing' else status %}

      # ---< safe to assume that currently probing (works sorta okay, just updates too slow)
      #{% set invert = True if ns.at_probing_speed and status in ['leveling', 'homing'] and ns.at_qgl_point else invert %}
    {% endif %}
  {% elif status == 'standby' %}
    {% set status = 'busy' if target_temp != 0 else status %}
  {% endif %}
  {% set status = 'changed' if tc.status == 'changing' and actn != tc.tool_number else status %}

  # ----------------------------- STATUS COLOR APPLICATION -----------------------------
  # ---< update values for the status we have and invert if needed, scale brightness
  {% set status_color = colors.get(status, colors.get('standby', {})) %}

  # ---< get the status colors if its colors.
  {% if status_color is mapping %}
    {% set _ = c.update(status_color) %}

  # ---< if its a template, render it instead.
  {% elif status_color is string and 'display_template ' ~ status_color in cfg %}
    # ---< add possible parameters.
    {% set pos_params = {'param_tn': param_tn, 'param_idx': param_idx} %}
    {% for k, v in pos_params.items() if k in cfg['display_template ' ~ status_color] %}
        {% set _ = rend_pa.update({k: v}) %}
    {% endfor %}
    # ---< render template
    {% set rgbw_list = render(status_color, **rend_pa).split(',')|map('int')|list %}
    {% if rgbw_list|length == 4 %}
      {% set _ = c.update({'r': rgbw_list[0], 'g': rgbw_list[1], 'b': rgbw_list[2], 'w': rgbw_list[3]}) %}
    {% endif %}
  {% endif %}
  # ---< Apply color inversion if needed
  {% for k,v in c.items() if invert %}{% set _ = c.update({k: (v-1)|abs}) %}{% endfor %}

  # ---< Add 0.004 (1/255) flicker to force klipper updates for static colors
  {% set kv = c|dictsort(false, 'value')|last if c.r or c.g or c.b or c.w else [] %}
  {% if kv and kv[1] > 0 %}{% set _ = c.update({kv[0]: c[kv[0]] + ((now/0.5 % 2) * 2 - 1) * 0.00392}) %}{% endif %}
  # ---< push leds out
  {c.r * bright},{c.g * bright},{c.b * bright},{c.w * bright}

  
  


#---------------------------------< Thermal, interpolating between min and max for provided tn
[display_template nozzle]
param_tn: 'None'
param_idx: 0
param_brightness: 1.0
param_min_temp: 50
param_max_temp: 160
text:
  {% set max_t = param_max_temp|float %}
  {% set min_t = param_min_temp|float %}
  #--- Short-form variables ---
  {% set p       = printer %}
  {% set cfg     = p.configfile.settings %}
  {% set tc      = p.toolchanger %}
  {% set ledvars = p['gcode_macro _toolchanger_led_vars'] %}
  {% set colors  = ledvars.get('colors', {}).get('nozzle', {}) %}
  {% set c       = {'r':0, 'g':0, 'b':0, 'w':0} %}
  {% set bright  = param_brightness|float %}
  {% set rend_pa = {} %}

  # ---< get temps etc
  {% set e_name    = cfg[tc.tool_names[param_tn|int]|lower].extruder %}
  {% set cur_t     = p[e_name].temperature|float %}
  {% set tar_t     = p[e_name].target|float %}
  {% set is_active = (param_tn|int == tc.tool_number|int) %}

  # ---< determine the status
  {% set status = ledvars.get('status', {}).get('nozzle', {}).get(param_tn, 'thermal') %}
  {% if status == 'thermal' %}
    {% if is_active %}
      {% set status = 'on' %}
    {% else %}
      {% set status = 'standby' if tar_t == 0 and cur_t <= min_t else status %}
    {% endif %}
  {% endif %}

  # ---< get the setting for that status
  {% set status_color = colors.get(status, None) %}

  {% if status == 'thermal' %}
    {% set c_cold = colors.get('cold', {'r':0.0, 'g':0.0, 'b':1.0, 'w':0.0}) %}
    {% set c_hot  = colors.get('hot',  {'r':1.0, 'g':0.0, 'b':0.0, 'w':0.0}) %}
    {% set scalar = [ [ 0.0, (cur_t - min_t) / ([ (max_t - min_t)|abs, 0.01 ]|max) ]|max, 1.0 ]|min %}
    {% for k in c %}
      {% set _ = c.update({k: c_cold[k] + (c_hot[k] - c_cold[k]) * scalar }) %}
    {% endfor %}

  # ---< get the status colors if its colors.
  {% elif status_color is mapping %}
    {% set _ = c.update(status_color) %}

  # ---< if its a template, render it instead.
  {% elif status_color is string and 'display_template ' ~ status_color in cfg %}
    # ---< add possible parameters.
    {% set pos_params = {'param_tn': param_tn, 'param_idx': param_idx} %}
    {% for k, v in pos_params.items() if k in cfg['display_template ' ~ status_color] %}
        {% set _ = rend_pa.update({k: v}) %}
    {% endfor %}
    # ---< render template
    {% set rgbw_list = render(status_color, **rend_pa).split(',')|map('int')|list %}
    {% if rgbw_list|length == 4 %}
      {% set _ = c.update({'r': rgbw_list[0], 'g': rgbw_list[1], 'b': rgbw_list[2], 'w': rgbw_list[3]}) %}
    {% endif %}
  {% endif %}

  # ---< Apply brightness scaling for this led, also flicker randomly to force updates.
  {% set kv = c|dictsort(false, 'value')|last if c.r or c.g or c.b or c.w else [] %}
  {% if kv and kv[1] > 0 %}
    {% set tick = (p.toolhead.estimated_print_time)|int %}
    {% set flicker = ((tick % 2) * 2 - 1) * 0.004 %}
    {% set _ = c.update({kv[0]: c[kv[0]] + flicker}) %}
  {% endif %}

  {(c.r * bright)|round(4)},{(c.g * bright)|round(4)},{(c.b * bright)|round(4)},{(c.w * bright)|round(4)}
