

# parameters are automatically passed onto these 
#
# param_idx, param_tn
# 
# you can use these in your templates to add special behaviour



#---------------------------------< name says it all
[display_template fast-equals-bright]
text:
  {% set p = printer.motion_report.live_velocity|abs/100 %}
  {p},{p},{p},{p}


#---------------------------------< change max idx for gradient (larger -> longer rainbow, shorter -> more rainbow)
[display_template rainbow]
param_idx: 0
param_max_idx: 20
text:
  {% set num_leds = param_max_idx|float + 1.0 %}
  {% set idx = param_idx|float %}
  {% set print_time = printer.toolhead.estimated_print_time|float / 30.0 %}
  {% set hue = (idx / num_leds + print_time) %}
  {% set hue = hue - (hue|int) %}
  # ---< HSV rainbow math: v=1, s=1, hue=0..1
  {% set h = hue * 6.0 %}
  {% set i = h|int %}
  {% set f = h - i %}
  {% set q = 1.0 - f %}
  {% set rgb_map = [
    [1.0, f, 0.0],
    [q, 1.0, 0.0],
    [0.0, 1.0, f],
    [0.0, q, 1.0],
    [f, 0.0, 1.0],
    [1.0, 0.0, q]
  ] %}
  {% set r = rgb_map[i % 6][0] %}
  {% set g = rgb_map[i % 6][1] %}
  {% set b = rgb_map[i % 6][2] %}
  {r},{g},{b},0


[display_template different-color-per-tool]
param_tn: None
text:
  {% if param_tn == 0 %}
    1,0,0,0
  {% elif param_tn == 1 %}
    0,1,0,0
  {% else %} # etc....
    0,0,1,0
  {% endif %}





####################################### MAIN LED TEMPLATES FOR NOZZLE AND LOGO #######################################

#---< main logo template autodetects: 
# - homing, calibrating, qgl, idle
# - toolchanging, printing, used in print
[display_template logo]
param_tn: 'None'
param_brightness: 1.0
param_idx: 0
param_debug: False
text:
  # ---< pos/speed tolerance for autodetect.
  {% set pos_tol, vel_tol     = 0.1, 0.1 %}
  # ---< short terms
  {% set p                = printer %}
  {% set th, tc, cfg, tpe = p.toolhead, p.toolchanger, p.configfile.settings, p.tool_probe_endstop %}
  {% set probe_name, actn = tpe.active_tool_probe, tpe.active_tool_number %}
  {% set timeout_state    = p.idle_timeout.state|lower %} # printing (does anything) ready (does nothing) idle (idle timeout triggered)
  {% set print_state      = p.print_stats.state|lower %} # standby
  {% set tool             = p[tc.tool_names[param_tn|int]] %}
  {% set ledvars, c       = p['gcode_macro _toolchanger_led_vars'], {'r':0, 'g':0, 'b':0, 'w':0} %}
  {% set bright           = param_brightness|float %}

  # ---< keeping track and getting main settings
  {% set colors          = ledvars.get('colors', {}).get('logo', {}) %}
  {% set invert, rend_pa = False, {} %}
  {% set ns              = namespace(doing_qgl=False, 
                                     at_homing_speed=False, 
                                     at_probing_speed=False, 
                                     at_probing_lift_speed=False, 
                                     out_of_bounds=False,
                                     at_qgl_point=False
                                     ) %}


  # ---< needed variables in here.
  {% set th_pos, now  = th.position, th.estimated_print_time %}
  {% set target_temp  = p[tool.extruder].target %}
  {% set qgl_points   = cfg.quad_gantry_level.points %}
  {% set live_pos     = p.motion_report.live_position %}
  {% set current_vel  = p.motion_report.live_velocity %}
  {% set speed_factor = p.gcode_move.speed_factor %}
  
  # ----------------------------- STATUS DETECTION -----------------------------
  {% set status = ledvars.get('status', {}).get('logo', {}).get(actn, 'ready') %}
  {% if actn == param_tn|int %}
    {% if timeout_state == 'printing'  %}
      # ---< busy, will be overwritten with anything specifically busy...
      {% set status = 'busy' %}

      # ---< check if at probing speed
      {% for speed, flag in [('speed', ns.at_probing_speed), ('lift_speed', ns.at_probing_lift_speed)] %}
        {% set flag = (current_vel - (cfg[probe_name|lower][speed] * speed_factor))|abs < vel_tol or flag %}
      {% endfor %}
      
      # ---< check if at homing speed
      {% for step in ['stepper_x', 'stepper_y', 'stepper_z'] %}
        {% for speed_name in ['homing_speed', 'homing_retract_speed', 'second_homing_speed'] if speed_name in cfg[step] %}
          {% set ns.at_homing_speed  = ((cfg[step][speed_name]) - current_vel)|abs < vel_tol or ns.at_homing_speed %}
          {% set ns.at_probing_speed = ((cfg[step][speed_name]) - current_vel)|abs < vel_tol and 'z' in step or ns.at_probing_speed %}
        {% endfor %}
      {% endfor %}

      # ---< check if at out of bounds (probably homing)
      {% for i in range(3) %}
          {% set ns.out_of_bounds = th_pos[i] <= th.axis_minimum[i] or th_pos[i] >= th.axis_maximum[i] or th_pos[i] == 0.0 or ns.out_of_bounds %}
      {% endfor %}

      # ---< check if on lines of â–¡ with some tolerance and at or below QGL move height
      {% set coords = {'x': qgl_points|map(attribute=0)|list, 'y': qgl_points|map(attribute=1)|list} %}
      {% for ax, xa in [('x','y'), ('y','x')] %}
        {% if (th_pos[ax] - coords[ax]|min)|abs < pos_tol or (th_pos[ax] - coords[ax]|max)|abs < pos_tol %}
          {% if (coords[xa]|min - pos_tol) <= th_pos[xa] <= (coords[xa]|max + pos_tol) %}
            {% set ns.doing_qgl = th_pos[2] <= cfg.quad_gantry_level.horizontal_move_z + pos_tol or ns.doing_qgl %}
          {% endif %}
        {% endif %}
      {% endfor %}
      # ---< check if exactly on point.
      {% for pt in qgl_points %}
        {% set ns.at_qgl_point = (live_pos[0] - pt[0])|abs < pos_tol and (live_pos[1] - pt[1])|abs < pos_tol or ns.at_qgl_point %}
      {% endfor %}

      # ---< set status according to what we are checking for \/ lower higher priority.
      {% set status = 'printing'    if print_state == 'printing' else status %}
      {% set status = 'homing'      if ns.at_homing_speed or ns.at_probing_speed or ns.out_of_bounds else status %}
      {% set status = 'leveling'    if ns.doing_qgl else status %}
      {% set status = 'calibrating' if not p.tools_calibrate.calibration_probe_inactive else status %}
      {% set status = 'changing'    if tc.status == 'changing' else status %}

      # ---< safe to assume that currently probing (works sorta okay, just updates too slow)
      #{% set invert = True if (ns.at_probing_speed or ns.at_qgl_point) and status in ['leveling', 'homing'] else invert %}
      {% set invert = (ns.at_probing_speed or (ns.at_qgl_point and not ns.at_probing_lift_speed)) and status in ['leveling', 'homing'] or invert %}
    {% endif %}
    
    # ---< active tool, but doesnt have to do something rn
    {% set status = 'paused'  if p.pause_resume.is_paused if pause_resume in p else status %}

  {% else %} #status == 'ready' %}
    {% set status = 'busy' if target_temp != 0 else status %}
  {% endif %}
  {% set status = 'changed' if tc.status == 'changing' and actn != tc.tool_number else status %}
  {% set status = 'idle'    if timeout_state == 'idle' else status %}
  {% set status = 'error'   if tc.status == 'error' or timeout_state == 'shutdown' else status %}


  # ----------------------------- STATUS COLOR APPLICATION -----------------------------
  # ---< update values for the status we have and invert if needed, scale brightness
  {% set status_color = colors.get(status, colors.get('ready', {})) %}

  # ---< get the status colors if its colors.
  {% if status_color is mapping %}
    {% set _ = c.update(status_color) %}

  # ---< if its a template, render it instead.
  {% elif status_color is string and 'display_template ' ~ status_color in cfg %}

    # ---< add possible parameters.
    {% set pos_params = {'param_tn': param_tn, 'param_idx': param_idx} %}
    {% for k, v in pos_params.items() if k in cfg['display_template ' ~ status_color] %}
        {% set _ = rend_pa.update({k: v}) %}
    {% endfor %}

    # ---< render template
    {% set rgbw_list = render(status_color, **rend_pa).split(',')|map('float')|list %}
    {% if rgbw_list|length == 4 %}
      {% set _ = c.update({'r': rgbw_list[0], 'g': rgbw_list[1], 'b': rgbw_list[2], 'w': rgbw_list[3]}) %}
    {% endif %}
  {% endif %}

  # ---< Apply color inversion if needed
  {% for k,v in c.items() if invert and ledvars.get('invert', False) %}{% set _ = c.update({k: (v-1)|abs}) %}{% endfor %}

  # ---< Add 0.004 (1/255) flicker to force klipper updates for static colors
  {% set kv = c|dictsort(false, 'value')|last if c.r or c.g or c.b or c.w else [] %}
  {% if kv and kv[1] > 0 %}{% set _ = c.update({kv[0]: c[kv[0]] + ((now/0.5 % 2) * 2 - 1) * 0.00392}) %}{% endif %}

  # ---< push leds out
  {c.r * bright},{c.g * bright},{c.b * bright},{c.w * bright}

  #{action_respond_info("timeout_state: " ~ timeout_state ~ '  print_state: ' ~ print_state) if actn == param_tn|int and ((now*2)|int % 2) == 0 and param_idx == 0 and param_debug}
  {action_respond_info("pos: " ~ th_pos ~ '  ns.at_qgl_point: ' ~ ns.at_qgl_point ~ '  ns.at_probing_speed: ' ~ ns.at_probing_speed ~ '  current_vel: ' ~ current_vel) if actn == param_tn|int and ((now*2)|int % 2) == 0 and param_idx == 0 and param_debug}


#---------------------------------< Thermal, interpolating between min and max for provided tn
[display_template nozzle]
param_tn: 'None'
param_idx: 0
param_brightness: 1.0
param_min_temp: 50
param_max_temp: 160
text:
  {% set max_t = param_max_temp|float %}
  {% set min_t = param_min_temp|float %}
  #--- Short-form variables ---
  {% set p       = printer %}
  {% set cfg     = p.configfile.settings %}
  {% set tc      = p.toolchanger %}
  {% set ledvars = p['gcode_macro _toolchanger_led_vars'] %}
  {% set colors  = ledvars.get('colors', {}).get('nozzle', {}) %}
  {% set c       = {'r':0, 'g':0, 'b':0, 'w':0} %}
  {% set bright  = param_brightness|float %}
  {% set rend_pa = {} %}

  # ---< get temps etc
  {% set e_name    = cfg[tc.tool_names[param_tn|int]|lower].extruder %}
  {% set cur_t     = p[e_name].temperature|float %}
  {% set tar_t     = p[e_name].target|float %}
  {% set is_active = (param_tn|int == tc.tool_number|int) %}

  # ---< determine the status
  {% set status = ledvars.get('status', {}).get('nozzle', {}).get(param_tn, 'thermal') %}
  {% if status == 'thermal' %}
    {% if is_active %}
      {% set status = 'on' %}
    {% else %}
      {% set status = 'ready' if tar_t == 0 and cur_t <= min_t else status %}
    {% endif %}
  {% endif %}

  # ---< get the setting for that status
  {% set status_color = colors.get(status, None) %}

  {% if status == 'thermal' %}
    {% set c_cold = colors.get('cold', {'r':0.0, 'g':0.0, 'b':1.0, 'w':0.0}) %}
    {% set c_hot  = colors.get('hot',  {'r':1.0, 'g':0.0, 'b':0.0, 'w':0.0}) %}
    {% set scalar = [ [ 0.0, (cur_t - min_t) / ([ (max_t - min_t)|abs, 0.01 ]|max) ]|max, 1.0 ]|min %}
    {% for k in c %}
      {% set _ = c.update({k: c_cold[k] + (c_hot[k] - c_cold[k]) * scalar }) %}
    {% endfor %}

  # ---< get the status colors if its colors.
  {% elif status_color is mapping %}
    {% set _ = c.update(status_color) %}

  # ---< if its a template, render it instead.
  {% elif status_color is string and 'display_template ' ~ status_color in cfg %}
    # ---< add possible parameters.
    {% set pos_params = {'param_tn': param_tn, 'param_idx': param_idx} %}
    {% for k, v in pos_params.items() if k in cfg['display_template ' ~ status_color] %}
        {% set _ = rend_pa.update({k: v}) %}
    {% endfor %}
    # ---< render template
    {% set rgbw_list = render(status_color, **rend_pa).split(',')|map('float')|list %}
    {% if rgbw_list|length == 4 %}
      {% set _ = c.update({'r': rgbw_list[0], 'g': rgbw_list[1], 'b': rgbw_list[2], 'w': rgbw_list[3]}) %}
    {% endif %}
  {% endif %}

  # ---< Apply brightness scaling for this led, also flicker randomly to force updates.
  {% set kv = c|dictsort(false, 'value')|last if c.r or c.g or c.b or c.w else [] %}
  {% if kv and kv[1] > 0 %}
    {% set tick = (p.toolhead.estimated_print_time)|int %}
    {% set flicker = ((tick % 2) * 2 - 1) * 0.004 %}
    {% set _ = c.update({kv[0]: c[kv[0]] + flicker}) %}
  {% endif %}

  {(c.r * bright)|round(4)},{(c.g * bright)|round(4)},{(c.b * bright)|round(4)},{(c.w * bright)|round(4)}
