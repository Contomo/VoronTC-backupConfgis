# ğŸŸ©â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#
#                          TOOL PROBE CALIBRATION SETTINGS                      #
# ğŸŸ©â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#
#
# This section defines parameters used by your tool probing system to
# calibrate tool XYZ and or probe offsets.
#
# ğŸ› ï¸ Hardware:
#   Nudge, sexball, z endstop, any modifcations inbetween.
#   basicall a buttom that also gets pressed from left right front back.
# 
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#
# ğŸ”Œ 'pin': GPIO pin (e.g., '^PG11')
#     The pin Klipper will monitor to detect a probe trigger.
#
# ğŸ§­ 'spread': X/Y distance from center for probing sequence (in mm)
#     This defines how far the tool moves during the touch pattern.
#     - For large pins (â‰¥5mm), use 3.5â€“4.0
#     - Larger values = more overtravel, takes longer, safer for larger variance in tools or larger pins
#     - Smaller values = less overtravel but may hit too early for large variance tools/large pins
#
# â†˜ï¸ 'lower_z': Distance to lower the nozzle to hit. (0 -> slides over, 3-4 -> hits silicone sock)
#     - 0.1â€“0.2 = minimal travel, may work, usually cleaner nozzle around here
#     - 0.4â€“0.5 = safer hit margin, possibly less accurate.
#
# ğŸš€ Motion Speeds:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 'travel_speed': Move speed between probes (mm/s)
# 'speed': move speed during probes 
# 'lift_speed':
# 'final_lift_z': Distance to raise Z after final probe
#
# ğŸ” Sampling:
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# 'sample_retract_dist': Z retract between samples (Z) (mm)
# 'samples': Number of probe samples to take (usually 3â€“5)
# 'samples_tolerance': Max variance (mm) allowed between samples (will abort if exceeded)
# 'samples_result': Aggregation method (e.g., 'median', 'average')
#
# ğŸ”¢ 'trigger_to_bottom_z': Used in trigger calibration calculations.
#     Defines Z distance from probe *trigger* to mechanical bottom out.
#     sort of like the distance from when your keyboard key registers a hit, to where it actually hits the bottom.
#     Get accurate value using 'TC_GET_PROBE_TRIGGER_TO_BOTTOM'.
# 
# ğŸ“ Hint: To disable probing functionality change: 'variable_enable_probe_calibration' to False
#
# ğŸŸ©â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#


[tools_calibrate]
pin: ^PG11
spread: 3 #7
lower_z: 0.4 #0.2 #0.5
travel_speed: 100 #20
speed: 2.5 #1.5
lift_speed: 4 #8
final_lift_z: 4 #6
sample_retract_dist: 3
samples_tolerance: 0.15 #0.05
samples: 4 #5
samples_result: median
trigger_to_bottom_z: 2.0733
# todo, include in nudge dict, only use -1, 1 to enable or disable probing functionality. with the dict probe offset being defined always from T0

#  Change this path to somewhere in your config folder
[save_variables]
filename: ~/printer_data/config/variables.cfg

#####################################################################
#   _MOVE_OVER_PROBE
#####################################################################
[gcode_macro _MOVE_OVER_PROBE]
description: Move tool head to probing position defined in [save_variables].
variable_macro_html: "?tMoves 3mm above the saved probe position.?nThis value is saved in SVF as 'probe_position' or set using TC_FIND_FIRST_CALIBRATION_PROBE_POSITION.?p_MOVE_OVER_PROBE "
gcode: # todo check home abort or home
  {% set p = printer %}
  {% set msg = macro_html %}
  {% set restoreAccel = p.toolhead.max_accel|float %}
  # â”€â”€â”€â”€â”€| Repair if wanted |â”€â”€â”€â”€â”€
  {% set svf_mode = printer['gcode_macro _toolchanger_settings'].get('svf_auto_repair', '') %}
  {% if svf_mode in ['Always', 'Use'] %}
    _INIT_SVF_KEYS
  {% endif %}
  # â”€â”€â”€â”€â”€| Home if wanted |â”€â”€â”€â”€â”€
  {% if p.toolhead.homed_axes != "xyz" and p.configfile.settings.toolchanger.on_axis_not_homed == 'home' %}
      _DEBUG_RESPOND MSG="$_MOVE_OVER_PROBE$ | homing first."
      G28
    {% endif %}
  {% if p.toolhead.homed_axes != "xyz" and p.configfile.settings.toolchanger.on_axis_not_homed != 'home' %}
    {% set msg = msg ~ "?s3?tchange on_axis_not_homed to change behaviour on abort or home if not homed?mNot homed, aborting." %}
  # â”€â”€â”€â”€â”€| Check if we got a tool |â”€â”€â”€â”€â”€
  {% elif p.tool_probe_endstop.active_tool_number|int != -1 %}
    {% set svf = p.save_variables.variables %}
    {% set feed = p.toolchanger.params_fast_speed  %}
    # Pull Nudge location from the save file position
    {% if 'probe_position' in svf %}
      {% if svf.probe_position.x|int == 0 and svf.probe_position.y|int == 0 and svf.probe_position.z|int == 0 %}
        {% set msg = msg ~ "?s3?tMissing calibration?nRun TC_FIND_FIRST_CALIBRATION_PROBE_POSITION to set probe position properly.?mKey 'probe_position' is set but its values are all 0.0.?nX=0 Y=0 Z=0" %}
      {% else %}
        # â”€â”€â”€â”€â”€| if position valid, go there |â”€â”€â”€â”€â”€
        SET_VELOCITY_LIMIT ACCEL={p.configfile.config.printer.max_accel|float // p.toolchanger.params_macro_accel_divider|default(12)|float}
        {% if p.toolhead.position[2] < svf.probe_position.z + 3 %} ROUNDED_G0 Z={svf.probe_position.z + 8} D=10 F={feed//2}{% endif %}
        #ğŸŸ¨â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#
        #ğŸŸ¨ The actual path to the probe position. change this based on your printer.
        #ğŸŸ¨â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#
        ROUNDED_G0 X={svf.probe_position.x} D=100 F={feed}
        ROUNDED_G0 Y={svf.probe_position.y} D=100 F={feed}
        ROUNDED_G0 Z={svf.probe_position.z + 3} D=0 F={feed//2}
        #{% set msg = msg ~ "?s0?tMoved above saved probe position?nTool is now positioned 3mm above SVF 'probe_position'.?mX={pos.x|round(3)} Y={pos.y|round(3)} Z={pos.z + 3|round(3)}" %}
      {% endif %}
    {% else %}
      {% set msg = msg ~ "?s4?tMissing probe_position key?nCould not find probe coordinates in SVF.?mDefine 'probe_position' via TC_FIND_FIRST_CALIBRATION_PROBE_POSITION or SVF like: ?c{'x': 219.644, 'y': 4.43, 'z': 8.066}?c" %}
    {% endif %}
  {% else %}
    {% set msg = msg ~ "?s3?tNo active tool?mNo active tool, cannot move over probe." %}
  {% endif %}
  {% if msg != macro_html %}
    _UNIFIED_RESPOND MSG="{msg}"
  {% endif %}
  SET_VELOCITY_LIMIT ACCEL={restoreAccel}

#####################################################################
#   TC_FIND_TOOL_OFFSETS
#####################################################################
[gcode_macro TC_FIND_TOOL_OFFSETS]
description: Calibrates the offsetts of the specified tool or tools. Usage: TC_FIND_TOOL_OFFSETS TOOL=x,x,x
variable_probe_temp: 150
variable_macro_html: "?tCalibrates the offsets of the specified tool or tools.?nUsage: TC_FIND_TOOL_OFFSETS TOOL=n,n,n?pTC_FIND_TOOL_OFFSETS "
variable_clean_macro_name: "CLEAN_NOZZLE"
gcode:
  {% set p = printer %}
  {% set call_pos = p.toolhead.position %} # absolute
  {% set ns = namespace(prstmac = p["gcode_macro PRINT_START"], clean_macro = False, msg=macro_html) %}
  # -----------------------------------------------------
  # Gets the list provided or uses all.
  # -----------------------------------------------------
  {% if params.TOOL is defined %} # params[0]?
    {% set tool_nums = "0," + params.TOOL|default("") %}
    {% set tools_to_adjust = [] %}
    {% for t in tool_nums.split(",") %} 
      {% if t >= '0' and t < '99' and t|int <= p.toolchanger.tool_names|length %}
        {% set _ = tools_to_adjust.append(t|int) %}
      {% else %}
        {% set ns.msg = ns.msg ~ "?s3?t?m?c" ~ t ~ "?c  is not a valid toolnumber" %}
      {% endif %}
    {% endfor %}
  {% else %}
    # no param provided, assume all.
    {% set tools_to_adjust = p.toolchanger.tool_numbers %}
  {% endif %}
  
  {% set current_tool = p.tool_probe_endstop.active_tool_number|int %}
  {% set clean_macro = "gcode_macro " ~ clean_macro_name %}
  {% set ns.clean_macro = p[clean_macro] if clean_macro in p else False %}
  # -----------------------------------------------------
  # Check if homed, and if it is, go do the thing.
  # -----------------------------------------------------
  {% if p.toolhead.homed_axes != "xyz" and p.configfile.settings.toolchanger.on_axis_not_homed == 'home' %}
    _DEBUG_RESPOND MSG="$TC_FIND_TOOL_OFFSETS$ | homing first."
    G28
  {% endif %}
  {% if "xyz" not in p.toolhead.homed_axes and p.configfile.settings.toolchanger.on_axis_not_homed != 'home' %}
     {% set ns.msg = ns.msg ~ "?s3?tPlease home prior to running 'TC_FIND_TOOL_OFFSETS'?mPrinter isnt homed." %}
  {% else %}
    {% if current_tool != -1 %}
      {% set ns.msg = ns.msg ~ "?s0?tFound ?c" ~ tools_to_adjust|length ~ "?c  tools to get the offsets for." %}
      _UNIFIED_RESPOND MSG="{ns.msg}"
      {% for tool_num in tools_to_adjust %}
        # -------------------------------------------------------
        # If we have a clean macro, restore to its brush instead
        # -------------------------------------------------------
        {% if ns.clean_macro %} # clean the nozzle if the macro exists
          # if the clean nozzle macro exists, try to restore to its position if its set.
          T{tool_num} {% if 'x' in ns.clean_macro %} X={ns.clean_macro.x} {% endif %} {% if 'y' in ns.clean_macro %} Y={ns.clean_macro.y} {% endif %} {% if 'z' in ns.clean_macro %} Z={ns.clean_macro.z+3} {% endif %}
          CLEAN_NOZZLE
        {% else %}
          M104 S{probe_temp} T{tool_num}
          T{tool_num}
        {% endif %}
        # heat up
        M109 S{probe_temp} MIN{probe_temp} T{tool_num} MAX{probe_temp+50}
        # if not last, preheat next
        {% set next_tool = tools_to_adjust[loop.index] if not loop.last else None %}
        {% if next_tool is not none %} M104 S{probe_temp - probe_temp * 0.1} T{next_tool} {% endif %}
        # if T0 make sure off are 0
        {% if tool_num == 0 %} SET_GCODE_OFFSET X=0 Y=0 Z=0 {% endif %}
        # calibrate XYZ
        UPDATE_DELAYED_GCODE ID=_SAVE_OFFSETS_ON_FAILURE DURATION=120
        _TC_FIND_CALIBRATION_PROBE 
        UPDATE_DELAYED_GCODE ID=_SAVE_OFFSETS_ON_FAILURE DURATION=0
        #if defined calibrate probe
        # que for save
        _TC_UPDATE_OFFSETS TOOL={tool_num} 
        M104 S0 T{tool_num} # cool
      {% endfor %}
      T0 X={call_pos[0]} Y={call_pos[1]} Z={call_pos[2]}
      _TC_UPDATE_OFFSETS SAVE=1 # save the offsets
      # reheat all tools if required.
      {% for tool_num in tools_to_adjust %}
        {% if ns.prstmac["params_T" ~ tool_num|string ~ "TEMP"] is defined %}
          M104 S{ns.prstmac["params_T" ~ tool_num|string ~ "TEMP"]|int - 50} T{tool_num} # todo this may be gibberish
        {% endif %}
      {% endfor %}
    {% else %}
      {% set ns.msg = ns.msg ~ "?s3?tRun 'DETECT_ACTIVE_TOOL_PROBE' if you think this message is a fault.?mNo active Tool, likely a crash. disabling for now." %}
    {% endif %}
  {% endif %}
  {% if '?s3' in ns.msg %}
    _UNIFIED_RESPOND MSG="{ns.msg}"
  {% endif %}



[delayed_gcode _SAVE_OFFSETS_ON_FAILURE]
gcode:
  _UNIFIED_RESPOND MSG="?t?p_SAVE_OFFSETS_ON_FAILURE ?t?s3?m?bProbing failed early. Saving offsets.?b"
  _TC_UPDATE_OFFSETS SAVE=YES

#####################################################################
#   _TC_UPDATE_OFFSETS
#####################################################################
[gcode_macro _TC_UPDATE_OFFSETS]
description: stage tool offsets for save. Usage: _TC_UPDATE_OFFSETS TOOL=X [SAVE], stages the current 'tools_calibrate.last_result' to the toolnumber provided. 
variable_macro_html: "?tStage tool offsets for save.?nUsage: _TC_UPDATE_OFFSETS TOOL=X [SAVE]?nStages the current 'tools_calibrate.last_result' to the toolnumber provided?p_TC_UPDATE_OFFSETS "
variable_storage: {} # why all this gibberish? statistics. (and its easier to read if printed last, all at one place)
gcode:
  {% set p = printer %}
  {% set msg = macro_html %}
  {% set actn = p.tool_probe_endstop.active_tool_number|int %} 
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set has_probe = tcs.get('enable_probe_calibration', False) %}
  {% set svf_mode = tcs.get('svf_auto_repair', '') %}
  {% set r_svf = tcs.get('save_tool_offset_rounding', 3)|int %}
  {% set r_log = tcs.get('entries_offset_history_rounding', 5)|int %}

  {% if actn != -1 %}
    # will run quiet if everything ok, its okay to call in same macro.
    # mainly because we will always first record some pos before saving it.
    {% if svf_mode in ['Always', 'Use'] %}
      _INIT_SVF_KEYS
    {% endif %}

    {% set save_mode = true if 'SAVE' in params else false %}
    {% set svf = p.save_variables.variables %}
    {% if save_mode %}
      {% set report = [] %}
      {% for tkey in storage %}
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Save the offsets with correct rounding.
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {% set svf_key = 'offsets_' ~ tkey %}
        {% set temp_coords = storage[tkey] %} # our local queed offsets
        {% set old = svf.get(svf_key, {"x": 0.0, "y": 0.0, "z": 0.0}) %} # our current values from svf from all tools

        {% set rounded_coords = {
          "x": temp_coords.x|round(r_svf),
          "y": temp_coords.y|round(r_svf),
          "z": temp_coords.z|round(r_svf)
        } %}
        {% if has_probe %}
          {% set _ = rounded_coords.update({"probe": temp_coords.probe|round(r_svf)}) %}
        {% endif %}

        # â”€â”€â”€â”€â”€| Anything that isnt our first tool, just save, actually easy lol |â”€â”€â”€â”€â”€
        {% if tkey[-1] != "0" %}
          SAVE_VARIABLE VARIABLE={svf_key} VALUE="{rounded_coords}"
        {% else %}

        # â”€â”€â”€â”€â”€| A bit funky here cause we have to specifically seperate probe pos from t0 offsets. |â”€â”€â”€â”€â”€
          {% set old_probe_position = svf.get('probe_position', {"x": 0.0, "y": 0.0, "z": 0.0}) %}
          {% set _ = old_probe_position.pop("probe") if "probe" in old_probe_position else None %}
          {% set probe_position = rounded_coords.copy() %} # set probe pros = temp_coords to retain temp_coords for calcs later.
          {% set _ = probe_position.pop("probe") if has_probe else None %} # remove probe from probe pos
          # â”€â”€â”€â”€â”€| Save probe pos |â”€â”€â”€â”€â”€
          SAVE_VARIABLE VARIABLE=probe_position VALUE="{probe_position}"
          # move probe from local buffer to t0 offs.
          {% set _ = old.update({"probe": rounded_coords.probe}) if has_probe else None %} # update probe for t0
          # â”€â”€â”€â”€â”€| Save T0 pos |â”€â”€â”€â”€â”€ for t0, save the old offsets instead without nulling them.
          SAVE_VARIABLE VARIABLE={svf_key} VALUE="{old}"  
          {% set _ = old.update(old_probe_position) %} # update our old positions again to do calcs later. (just overwrites xyz)
        {% endif %}

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # After now theres just tooltips/statistics
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {% set diff = { 
          "x": (old.x|default(0)|float - temp_coords.x)|round(r_svf), 
          "y": (old.y|default(0)|float - temp_coords.y)|round(r_svf), 
          "z": (old.z|default(0)|float - temp_coords.z)|round(r_svf) 
        } %}
        
        # Tooltip formatting
        {% set tooltip = "?tPos: X: " ~ temp_coords.x|round(2) ~ " Y: " ~ temp_coords.y|round(2) ~ " Z: " ~ temp_coords.z|round(2) %}
        {% set tooltip = tooltip ~ "?nDif: X: " ~ diff.x|round(2) ~ " Y: " ~ diff.y|round(2) ~ " Z: " ~ diff.z|round(2) %}
        {% if has_probe %}
          {% set probe_diff = (old.probe|default(-1)|float - temp_coords.probe|default(-1)|float)|round(2) %}
          {% set tooltip = tooltip ~ "?nZ Probe: Z: " ~ temp_coords.probe|round(2) ~ " Diff: " ~ probe_diff|round(2) %}
        {% endif %}
        # -----------------------------------------------------
        # Properly pad the results for display
        # -----------------------------------------------------
        {% set pad = "        " %}

        {% set x = temp_coords.x|round(r_svf) %}
        {% set y = temp_coords.y|round(r_svf) %}
        {% set z = temp_coords.z|round(r_svf) %}
        {% set px = temp_coords.probe|round(r_svf) if has_probe else "" %}

        # ---- stringify
        {% set xstr = x|string %}
        {% set ystr = y|string %}
        {% set zstr = z|string %}
        {% set px_str = px|string if has_probe else "" %}

        {% set xstr_dif = diff.x|string %}
        {% set ystr_dif = diff.y|string %}
        {% set zstr_dif = diff.z|string %}
        {% set px_str_dif = probe_diff|string if has_probe else "" %}

        # ---- pad
        {% set xpad = pad[:8 - xstr|length] %}
        {% set ypad = pad[:8 - ystr|length] %}
        {% set zpad = pad[:8 - zstr|length] %}
        {% set ppad = pad[:8 - px_str|length] if has_probe else "" %}

        {% set xpad_dif = pad[:8 - xstr_dif|length] %}
        {% set ypad_dif = pad[:8 - ystr_dif|length] %}
        {% set zpad_dif = pad[:8 - zstr_dif|length] %}
        {% set ppad_dif = pad[:8 - px_str_dif|length] if has_probe else "" %}

        # ---- construct message
        {% set disp = tooltip ~ "?s0?mSaved ?c" ~ tkey|string|upper ~ "?c  offsets." %}
        {% set disp = disp ~ "?nAbs:  ?cX:" ~ xpad ~ xstr ~ "  Y:" ~ ypad ~ ystr ~ "  Z:" ~ zpad ~ zstr %}
        {% set disp = disp ~ " P:" ~ ppad ~ px_str ~ "?c?n" if has_probe else disp ~ "?c?n" %}

        {% set disp = disp ~ "Diff: ?cX:" ~ xpad_dif ~ xstr_dif ~ "  Y:" ~ ypad_dif ~ ystr_dif ~ "  Z:" ~ zpad_dif ~ zstr_dif %}
        {% set disp = disp ~ " P:" ~ ppad_dif ~ px_str_dif ~ "?c?n" if has_probe else disp ~ "?c?n" %}

        {% set _ = report.append(disp) %} # Append report
        
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Log parameters to rolling SVF if its enabled, with correct rounding
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {% set logparams = "TN=" ~ tkey ~
          " X=" ~ (temp_coords.x|round(r_log)) ~
          " Y=" ~ (temp_coords.y|round(r_log)) ~
          " Z=" ~ (temp_coords.z|round(r_log)) %}

        {% set logparams = logparams ~ " PROBE=" ~ (temp_coords.probe|round(r_log)) if has_probe else logparams %}
        _TC_LOG_OFFSET_HISTORY {logparams}
      {% endfor %}

      {% set msg = msg ~ report|join() %}
      SET_GCODE_VARIABLE MACRO=_TC_UPDATE_OFFSETS VARIABLE=storage VALUE={{}} # clear storage
    {% else %}
      # -----------------------------------------------------
      # This block below appends to the local macro variable
      # -----------------------------------------------------
      {% set ns = namespace(tn="", new = storage.copy()) %}
      {% if rawparams %} {% for c in rawparams.split()[0] %} {% set ns.tn = ns.tn ~ c if "0" <= c <= "9" else ns.tn %} {% endfor %} {% endif %}# retrieve number from first param provided
      {% if ns.tn|length > 0 %}  # if parameter provided
        {% set tn = p.toolchanger.tool_names[ns.tn|int]|replace("tool ", "")|lower %}
        # set last results
        {% set lastResult = p.tools_calibrate.last_result %}
        {% set temp_coords = {"x": lastResult[0], "y": lastResult[1], "z": lastResult[2]} %}
        # add probe
        {% if has_probe %} {% set _ = temp_coords.update({"probe": p.tools_calibrate.last_probe_offset|default(1)}) %} {% endif %}
        # save appended values
        {% set _ = ns.new.update({tn: temp_coords}) %}
        {% set msg = msg ~ "?s0?t" ~ temp_coords ~ "mQueed" ~ tn|upper ~ "for save..." %}
        SET_GCODE_VARIABLE MACRO=_TC_UPDATE_OFFSETS VARIABLE=storage VALUE="{ns.new}"
      {% else %}
        {% set msg = msg ~ "?s3?tFirst parameter provided should contain toolnumber, valid examples would be:?nABC=1?nTN=2?nT=T1?nTOOL='tool TX1'?netc....?mFirst parameter missing ?ctoolnum?c" %}
      {% endif %}
    {% endif %}
  {% else %}
    {% set msg = msg ~ "?s3?t?mNo active Tool, likely a crash. disabling for now." %}
  {% endif %}
  _UNIFIED_RESPOND MSG="{msg}"

#####################################################################
#   _TC_FIND_CALIBRATION_PROBE
#####################################################################
[gcode_macro _TC_FIND_CALIBRATION_PROBE]
variable_macro_html: "?tCalls a macro to move over the calibration probe, and the correct internal command based on tool number selected.?nRefer to '_MOVE_OVER_PROBE' for more info?pTC_ADJUST_HOME_OFFSET"
gcode:
  {% set atn = printer.tool_probe_endstop.active_tool_number|int %}
  {% set epc = printer['gcode_macro _toolchanger_settings'].enable_probe_calibration %}
  {% if atn == -1 %}
    {% set msg = macro_html ~ "?s3?t'tool_probe_endstop.active_tool_number' is: " ~ atn ~ ", run 'DETECT_ACTIVE_TOOLPROBE' to update it.?mNo active tool, aborting" %}
    _UNIFIED_RESPOND MSG="{msg}"
  {% elif atn == 0 %} # If we are T0
    STATUS_CALIBRATING_Z
    _MOVE_OVER_PROBE
    TOOL_LOCATE_SENSOR
    {% if epc %} TOOL_CALIBRATE_PROBE_OFFSET PROBE="tool_probe T{atn}" {% endif %} # todo get probe from tool instead of doing T
  {% else %}
    STATUS_CALIBRATING_Z
    _MOVE_OVER_PROBE
    TOOL_CALIBRATE_TOOL_OFFSET
    {% if epc %} TOOL_CALIBRATE_PROBE_OFFSET PROBE="tool_probe T{atn}" {% endif %} 
  {% endif %}

[gcode_macro TC_ADJUST_OFFSETS_UI]
description: Tool offset adjuster and tool selector with prompt UI integration
variable_selected_tool_for_offset: -1
gcode:
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set act = p.tool_probe_endstop.active_tool_number|int %}
  {% set stored = selected_tool_for_offset|default(act)|int %}
  {% set max_off = tcs.get('max_allowed_offsets', 999)|float %}
  {% set msg = "" %}

  {% if params.TOOL is defined %}
    SET_GCODE_VARIABLE MACRO=TC_ADJUST_OFFSETS_UI VARIABLE=selected_tool_for_offset VALUE={params.TOOL|int}
  {% elif params.AXIS is defined and params.AMOUNT is defined %}
    {% set axis = params.AXIS|lower %}
    {% set amount = params.AMOUNT|float|round(3) %}
    {% if axis in ['x', 'y', 'z'] and amount != 0 %}
      {% set toolname = p.toolchanger.tool_names[stored] %}
      {% set key = 'offsets_' ~ toolname|replace('tool ', '', 1)|lower %}
      {% set val = svf[key]|default({}) %}
      {% if val is not mapping %}{% set val = {} %}{% endif %}
      {% set newval = val.copy() %}
      {% set current = val[axis]|default(0)|float %}
      {% set updated = current + amount %}
      {% set updated = (-max_off if updated < -max_off else (max_off if updated > max_off else updated))|round(3) %}
      {% set _ = newval.update({axis: updated}) %}
      SAVE_VARIABLE VARIABLE={key} VALUE="{newval}"
      {% if p.toolchanger.tool_number == stored %}
        SET_GCODE_OFFSET {axis|upper}={updated} MOVE=1
      {% endif %}
      {% set msg = "Adjusted offset for " ~ toolname ~ " " ~ axis ~ " by " ~ amount ~ " â†’ " ~ updated %}
    {% else %}
      {% set msg = "Invalid AXIS or AMOUNT" %}
    {% endif %}
  {% else %}
    RESPOND TYPE=command MSG="action:prompt_begin Adjust Tool Offsets"

    {% set toolnames = p.toolchanger.tool_names %}
    {% set increments = [0.1, 0.05, 0.01, -0.1, -0.05, -0.01] %}

    {% for i in range(toolnames|length) %}
      {% if i % 3 == 0 %}RESPOND TYPE=command MSG="action:prompt_button_group_start"{% endif %}
      {% set name = toolnames[i]|replace('tool ', '') %}
      {% set color = 'primary' if i == stored else '' %}
      RESPOND TYPE=command MSG="action:prompt_button {name}|TC_ADJUST_OFFSETS_UI TOOL={i}|{color}"
      {% if i % 3 == 2 or i == toolnames|length - 1 %}RESPOND TYPE=command MSG="action:prompt_button_group_end"{% endif %}
    {% endfor %}

    {% for ax in ['X', 'Y', 'Z'] %}
      RESPOND TYPE=command MSG="action:prompt_text {ax} offset"
      {% for i in range(increments|length) %}
        {% if i % 3 == 0 %}RESPOND TYPE=command MSG="action:prompt_button_group_start"{% endif %}
        {% set val = increments[i] %}
        {% set sign = '+' if val > 0 else '' %}
        {% set color = 'info' if ax == 'X' else ('warning' if ax == 'Y' else 'error') %}
        RESPOND TYPE=command MSG="action:prompt_button {sign}{val}|TC_ADJUST_OFFSETS_UI AXIS={ax} AMOUNT={val}|{color}"
        {% if i % 3 == 2 or i == increments|length - 1 %}RESPOND TYPE=command MSG="action:prompt_button_group_end"{% endif %}
      {% endfor %}
    {% endfor %}

    RESPOND TYPE=command MSG="action:prompt_footer_button CLOSE|RESPOND TYPE=command MSG=action:prompt_end"
    RESPOND TYPE=command MSG="action:prompt_show"
  {% endif %}

  {% if msg and params.SILENT is not defined %}
    RESPOND TYPE=echo MSG="{msg}"
  {% endif %}



[gcode_macro TC_ADJUST_OFFSET]
description: Adjust an offset by specifying tool, axis, and amount to adjust.
             TC_ADJUST_OFFSET TOOL=1 AXIS=X AMOUNT=0.050
variable_macro_html: "?tTC_ADJUST_OFFSET TOOL=1 AXIS=X AMOUNT=0.050?pTC_ADJUST_OFFSET "
gcode:
  {% set ns = namespace(msg = macro_html|string) %}
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set max_off = tcs.get('max_allowed_offsets', 999)|float %}

  {% set actn = p.tool_probe_endstop.active_tool_number|int %}
  {% set tn = (params.TOOL|int if params.TOOL is defined else actn) %}
  {% set axis = params.AXIS|default("")|lower %}
  {% set amount = params.AMOUNT|default(0.000)|float|round(3) %}

  {% if tn >= 0 and axis in ['x', 'y', 'z'] and amount != 0 %}
    # get key
    {% set toolname = p.toolchanger.tool_names[tn] %}
    {% set key = 'offsets_' ~ toolname|replace('tool ', '', 1)|lower %}
    {% set val = svf[key]|default({}) %}
    {% set val = {} if val is not mapping else val %}
    {% set newval = val.copy() %}
    {% set current = val[axis]|default(0)|float %}
    {% set updated = (current + amount)|round(3) %}
    # clamp
    {% set updated = (-max_off if updated < -max_off else (max_off if updated > max_off else updated))|round(3) %}
    # update dict and save
    {% set _ = newval.update({axis: updated}) %}
    SAVE_VARIABLE VARIABLE={key} VALUE="{newval}"
    {% if p.toolchanger.tool_number == tn %}
      SET_GCODE_OFFSET {axis|upper}={updated} MOVE=1
    {% endif %}
    {% set ns.msg = ns.msg ~ "?s0?mAdjusted offset for?c" ~ toolname ~ "?c axis ?c" ~ axis ~ "?c by " ~ amount ~ "mm â†’ new: " ~ updated %}
  {% elif tn == -1 %}
    {% set ns.msg = ns.msg ~ "?s4?mNo tool number provided and no active tool available." %}
  {% elif axis not in ['x', 'y', 'z'] %}
    {% set ns.msg = ns.msg ~ "?s4?mUnknown or missing axis: ?c" ~ axis ~ "?c. Only x, y, or z supported." %}
  {% elif amount == 0 %}
    {% set ns.msg = ns.msg ~ "?s4?mAdjustment amount must be non-zero." %}
  {% endif %}
  {% if params.SILENT is not defined %}
    _UNIFIED_RESPOND MSG="{ns.msg}"
  {% endif %}

#####################################################################
#   TC_GET_PROBE_TRIGGER_TO_BOTTOM
#####################################################################
[gcode_macro TC_GET_PROBE_TRIGGER_TO_BOTTOM]
description: Calculates correct trigger_to_bottom_z using trusted z_offset (trusted = current tool)
gcode:
  {% if printer.tool_probe_endstop.active_tool_number|int != -1 %}
    {% set probe = printer.probe.active_tool_probe %}
    {% set cur_probe_offset = printer.tool_probe_endstop.active_tool_probe_z_offset|float %}
    _MOVE_OVER_PROBE
    {% if probe == "tool_probe T0" %}
      TOOL_LOCATE_SENSOR
    {% else %}
      TOOL_CALIBRATE_TOOL_OFFSET
    {% endif %}
    TOOL_CALIBRATE_PROBE_OFFSET
    _TC_GET_PROBE_TRIGGER_TO_BOTTOM
    {% set feed = printer['configfile'].config["tools_calibrate"]["travel_speed"]|int * 60  %}
    G0 X{printer.configfile.config.stepper_x.position_max|float / 2} Y{printer.configfile.config.stepper_y.position_max|float / 2} F{feed}
  {% endif %}

[gcode_macro _TC_GET_PROBE_TRIGGER_TO_BOTTOM]
gcode:
  {% if printer.tool_probe_endstop.active_tool_number|int != -1 %}
    {% set cur_probe_offset = printer.tool_probe_endstop.active_tool_probe_z_offset|float %}
    {% set last_probe_offset = printer.tools_calibrate.last_probe_offset|float %}
    {% set ttb_old = printer.configfile.settings.tools_calibrate.trigger_to_bottom_z|float %}
    {% set ttb_new = cur_probe_offset - (last_probe_offset - ttb_old) %}
    {% set nl = '\u0026\u0023\u0031\u0030\u003b' %}
    {% set hover_text ="ğŸŸ  z_offset: " ~ cur_probe_offset|round(3)|string ~ nl ~"ğŸ”µ last_offset: " ~ last_probe_offset|round(3)|string ~ nl ~"ğŸŸ£ old trigger_to_bottom_z: " ~ ttb_old|round(3)|string%}
    RESPOND MSG="<span title='{hover_text}'><b style='color:rgb(0,255,150)'>ğŸŸ¢ trigger_to_bottom_z: {ttb_new|round(4)}</b></span>"
  {% else %}
    RESPOND TYPE=error MSG="No active tool selected for probe calibration."
  {% endif %}


#####################################################################
#   TC_FIND_FIRST_CALIBRATION_PROBE_POSITION
#####################################################################
[gcode_macro TC_FIND_FIRST_CALIBRATION_PROBE_POSITION]
description: "Manually jog tool over probe, then call me and it gets saved to SVF 'probe_position'"
gcode:
  TOOL_LOCATE_SENSOR
  _TC_FIND_FIRST_CALIBRATION_PROBE_POSITION

[gcode_macro _TC_FIND_FIRST_CALIBRATION_PROBE_POSITION]
variable_macro_html: "?tManually jog tool over probe, then call me and it gets saved to SVF 'probe_position' ?pTC_FIND_FIRST_CALIBRATION_PROBE_POSITION "
gcode:
  {% set msg = macro_html %}
  {% set svf = printer.save_variables.variables %}
  {% set probe_pos = printer.tools_calibrate.last_result %}
  {% set pos = {"x": probe_pos[0]|round(2), "y": probe_pos[1]|round(2), "z": probe_pos[2]|round(2)} %}
  {% set msg = msg ~ "?t?mPosition recorded and stored in svf?n?c" ~ pos ~ "?c?ddd" %}
  _UNIFIED_RESPOND MSG="{msg}"
  SAVE_VARIABLE VARIABLE=probe_position VALUE="{pos}"
#####################################################################
#   _INIT_SVF_KEYS   # Initializes and or repairs all the keys we need.
#####################################################################
[gcode_macro _INIT_SVF_KEYS] # TODO add ability to resort to x y z probe, be more quiet, less console spam
description: Ensure all required tool offset keys exist and are valid in save_variables
gcode:
  {% set svf = printer.save_variables.variables %}
  {% set nl = '\u0026\u0023\u0031\u0030\u003b' %}
  {% set toolnames = printer.toolchanger.tool_names %}
  {% set zprobe_required = printer['gcode_macro _toolchanger_settings'].get(enable_probe_calibration, True) %}
  {% set remove_invalid = printer['gcode_macro _toolchanger_settings'].get('svf_remove_invalid', True) %}
  {% set keys_to_check_tool = ["x", "y", "z"] + ["probe"] if zprobe_required else ["x", "y", "z"] %}
  {% set missing = [] %}
  {% set repaired = [] %}
  {% set removed = [] %}
  {% set warnings = [] %}
  # Nudge position dick handling
  {% set nudge = svf['probe_position']|default({}) %}
  {% if 'probe_position' not in svf %}
    SAVE_VARIABLE VARIABLE=probe_position VALUE="{ {'x': 0.0, 'y': 0.0, 'z': 0.0} }"
    {% set _ = repaired.append("probe_position (new)") %}
  {% endif %}

  {% if nudge is not mapping %} {% set nudge = {} %} {% endif %}
  {% set nudgerepair = nudge.copy() %}
  {% set remove_keys = [] %}
  {% for k in nudgerepair %}
    {% if k not in ["x", "y", "z"] %}
      {% set _ = remove_keys.append(k) %}
    {% endif %}
  {% endfor %}
  {% for k in remove_keys %}
    {% if remove_invalid %}
      {% set _ = nudgerepair.pop(k) %}
    {% endif %}
    {% set _ = removed.append("probe_position." ~ k) %}
  {% endfor %}
  {% for k in nudgerepair %} {% if k not in ["x", "y", "z"] %}
      {% set _ = nudgerepair.pop(k) %}
      {% set _ = removed.append("probe_position." ~ k) %}
  {% endif %} {% endfor %}
  {% if nudgerepair != nudge %}
    SAVE_VARIABLE VARIABLE=probe_position VALUE="{nudgerepair}"
    {% set _ = repaired.append("probe_position") %}
  {% endif %}
  # Check tool offsets
  {% for i in range(toolnames|length) %}
    {% set rawname = toolnames[i] %}
    {% set toolname = rawname|replace("tool ", "")|lower %}
    {% set key = 'offsets_' ~ toolname %}
    {% set val = svf[key]|default({}) %}
    {% if val is not mapping %} {% set val = {} %} {% endif %}
    {% set newval = val.copy() %}
    {% for k in keys_to_check_tool %} {% if k not in val %}
        {% set _ = newval.update({k: 0.0}) %}
        {% set _ = missing.append(key ~ "." ~ k) %}
    {% endif %} {% endfor %}
    {% for k in val %} {% if k not in keys_to_check_tool %}
        {% set _ = newval.pop(k) %}
        {% set _ = removed.append(key ~ "." ~ k ~ "=" ~ val[k]|string) %}
    {% endif %} {% endfor %}
    {% if newval != val %}
      SAVE_VARIABLE VARIABLE={key} VALUE="{newval}"
      {% set _ = repaired.append(key) %}
    {% endif %}
    # Warn if T0 has any non-zero offsets
    {% set _ = warnings.append(toolnames[0] ~ " gcode offset should always be (0,0,0)!") if (newval.x|default(0)|float != 0 or newval.y|default(0)|float != 0 or newval.z|default(0)|float != 0) and i == 0 %}
  {% endfor %}
  {% if missing|length == 0 and warnings|length == 0 and removed|length == 0 %}
    #RESPOND MSG="<span style='color:green;'>All tool offsets and calibration probe keys are valid.</span>"
  {% else %}
    {% set out = [] %}
    {% if repaired|length > 0 %} {% set _ = out.append("<span style='color:orange;'>Fixed: " ~ repaired|join(", ") ~ "</span>") %} {% endif %}
    {% if missing|length > 0 %} {% set _ = out.append("<span style='color:secondary;'>created the missing keys:  " ~ missing|join(", ") ~ "</span>") %} {% endif %}
    {% if removed|length > 0 %} {% set _ = out.append("<span style='color:error;'> Removed invalid entry: " ~ removed|join(", ") ~ "</span>") %} {% endif %}
    {% for w in warnings %} {% set _ = out.append("<span style='color:warning;'>" ~ w ~ "</span>") %} {% endfor %}
    RESPOND MSG="{out|join(nl)}"
  {% endif %}

