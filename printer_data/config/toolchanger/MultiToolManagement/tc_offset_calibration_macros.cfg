

#####################################################################
#   _MOVE_OVER_PROBE
#####################################################################
[gcode_macro _MOVE_OVER_PROBE]
description: Move tool head to probing position defined in [save_variables].
variable_macro_html: "?tMoves 3mm above the saved probe position.?nThis value is saved in SVF as 'probe_position' or set using TC_FIND_FIRST_CALIBRATION_PROBE_POSITION.?p_MOVE_OVER_PROBE "
gcode: # todo check home abort or home
  {% set p = printer %}
  {% set msg = macro_html %}
  {% set restoreAccel = p.toolhead.max_accel|float %}
  # â”€â”€â”€â”€â”€| Repair if wanted |â”€â”€â”€â”€â”€
  {% set svf_mode = printer['gcode_macro _toolchanger_settings'].get('svf_auto_repair', '') %}
  {% if svf_mode in ['Always', 'Use'] %}
    _INIT_SVF_KEYS
  {% endif %}
  # â”€â”€â”€â”€â”€| Home if wanted |â”€â”€â”€â”€â”€
  {% if p.toolhead.homed_axes != "xyz" and p.configfile.settings.toolchanger.on_axis_not_homed == 'home' %}
      _DEBUG_RESPOND MSG="$_MOVE_OVER_PROBE$ | homing first."
      G28
    {% endif %}
  {% if p.toolhead.homed_axes != "xyz" and p.configfile.settings.toolchanger.on_axis_not_homed != 'home' %}
    {% set msg = msg ~ "?s3?tchange on_axis_not_homed to change behaviour on abort or home if not homed?mNot homed, aborting." %}
  # â”€â”€â”€â”€â”€| Check if we got a tool |â”€â”€â”€â”€â”€
  {% elif p.tool_probe_endstop.active_tool_number|int != -1 %}
    {% set svf = p.save_variables.variables %}
    {% set feed = p.toolchanger.params_fast_speed  %}
    # Pull Nudge location from the save file position
    {% if 'probe_position' in svf %}
      {% if svf.probe_position.x|int == 0 and svf.probe_position.y|int == 0 and svf.probe_position.z|int == 0 %}
        {% set msg = msg ~ "?s3?tMissing calibration?nRun TC_FIND_FIRST_CALIBRATION_PROBE_POSITION to set probe position properly.?mKey 'probe_position' is set but its values are all 0.0.?nX=0 Y=0 Z=0" %}
      {% else %}
        # â”€â”€â”€â”€â”€| if position valid, go there |â”€â”€â”€â”€â”€
        SET_VELOCITY_LIMIT ACCEL={p.configfile.config.printer.max_accel|float // p.toolchanger.params_macro_accel_divider|default(12)|float}
        {% if p.toolhead.position[2] < svf.probe_position.z + 3 %} ROUNDED_G0 Z={svf.probe_position.z + 8} D=10 F={feed//2}{% endif %}
        #ðŸŸ¨â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#
        #ðŸŸ¨ The actual path to the probe position. change this based on your printer.
        #ðŸŸ¨â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€#
        ROUNDED_G0 X={svf.probe_position.x} D=100 F={feed}
        ROUNDED_G0 Y={svf.probe_position.y} D=100 F={feed}
        ROUNDED_G0 Z={svf.probe_position.z + 3} D=0 F={feed//2}
        #{% set msg = msg ~ "?s0?tMoved above saved probe position?nTool is now positioned 3mm above SVF 'probe_position'.?mX={pos.x|round(3)} Y={pos.y|round(3)} Z={pos.z + 3|round(3)}" %}
      {% endif %}
    {% else %}
      {% set msg = msg ~ "?s4?tMissing probe_position key?nCould not find probe coordinates in SVF.?mDefine 'probe_position' via TC_FIND_FIRST_CALIBRATION_PROBE_POSITION or SVF like: ?c{'x': 219.644, 'y': 4.43, 'z': 8.066}?c" %}
    {% endif %}
  {% else %}
    {% set msg = msg ~ "?s3?tNo active tool?mNo active tool, cannot move over probe." %}
  {% endif %}
  {% if msg != macro_html %}
    _UNIFIED_RESPOND MSG="{msg}"
  {% endif %}
  SET_VELOCITY_LIMIT ACCEL={restoreAccel}

#####################################################################
#   TC_FIND_TOOL_OFFSETS
#####################################################################
[gcode_macro TC_FIND_TOOL_OFFSETS]
description: Calibrates the offsetts of the specified tool or tools. Usage: TC_FIND_TOOL_OFFSETS TOOL=x,x,x
variable_probe_temp: 150
variable_macro_html: "?tCalibrates the offsets of the specified tool or tools.?nUsage: TC_FIND_TOOL_OFFSETS TOOL=n,n,n?pTC_FIND_TOOL_OFFSETS "
variable_clean_macro_name: "CLEAN_NOZZLE"
gcode:
  {% set p = printer %}
  {% set call_pos = p.toolhead.position %} # absolute
  {% set ns = namespace(prstmac = p["gcode_macro PRINT_START"], clean_macro = False, msg=macro_html) %}
  # -----------------------------------------------------
  # Gets the list provided or uses all.
  # -----------------------------------------------------
  {% if params.TOOL is defined %} # params[0]?
    {% set tool_nums = "0," + params.TOOL|default("") %}
    {% set tools_to_adjust = [] %}
    {% for t in tool_nums.split(",") %} 
      {% if t >= '0' and t < '99' and t|int <= p.toolchanger.tool_names|length %}
        {% set _ = tools_to_adjust.append(t|int) %}
      {% else %}
        {% set ns.msg = ns.msg ~ "?s3?t?m?c" ~ t ~ "?c  is not a valid toolnumber" %}
      {% endif %}
    {% endfor %}
  {% else %}
    # no param provided, assume all.
    {% set tools_to_adjust = p.toolchanger.tool_numbers %}
  {% endif %}
  
  {% set current_tool = p.tool_probe_endstop.active_tool_number|int %}
  {% set clean_macro = "gcode_macro " ~ clean_macro_name %}
  {% set ns.clean_macro = p[clean_macro] if clean_macro in p else False %}
  # -----------------------------------------------------
  # Check if homed, and if it is, go do the thing.
  # -----------------------------------------------------
  {% if p.toolhead.homed_axes != "xyz" and p.configfile.settings.toolchanger.on_axis_not_homed == 'home' %}
    _DEBUG_RESPOND MSG="$TC_FIND_TOOL_OFFSETS$ | homing first."
    G28
  {% endif %}
  {% if "xyz" not in p.toolhead.homed_axes and p.configfile.settings.toolchanger.on_axis_not_homed != 'home' %}
     {% set ns.msg = ns.msg ~ "?s3?tPlease home prior to running 'TC_FIND_TOOL_OFFSETS'?mPrinter isnt homed." %}
  {% else %}
    {% if current_tool != -1 %}
      {% set ns.msg = ns.msg ~ "?s0?tFound ?c" ~ tools_to_adjust|length ~ "?c  tools to get the offsets for." %}
      _UNIFIED_RESPOND MSG="{ns.msg}"
      {% for tool_num in tools_to_adjust %}
        # -------------------------------------------------------
        # If we have a clean macro, restore to its brush instead
        # -------------------------------------------------------
        {% if ns.clean_macro %} # clean the nozzle if the macro exists
          # if the clean nozzle macro exists, try to restore to its position if its set.
          T{tool_num} {% if 'x' in ns.clean_macro %} X={ns.clean_macro.x} {% endif %} {% if 'y' in ns.clean_macro %} Y={ns.clean_macro.y} {% endif %} {% if 'z' in ns.clean_macro %} Z={ns.clean_macro.z+3} {% endif %}
          CLEAN_NOZZLE
        {% else %}
          M104 S{probe_temp} T{tool_num}
          T{tool_num}
        {% endif %}
        # heat up
        M109 S{probe_temp} MIN{probe_temp} T{tool_num} MAX{probe_temp+50}
        # if not last, preheat next
        {% set next_tool = tools_to_adjust[loop.index] if not loop.last else None %}
        {% if next_tool is not none %} M104 S{probe_temp - probe_temp * 0.1} T{next_tool} {% endif %}
        # if T0 make sure off are 0
        {% if tool_num == 0 %} SET_GCODE_OFFSET X=0 Y=0 Z=0 {% endif %}
        # calibrate XYZ
        UPDATE_DELAYED_GCODE ID=_SAVE_OFFSETS_ON_FAILURE DURATION=120
        _TC_FIND_CALIBRATION_PROBE 
        UPDATE_DELAYED_GCODE ID=_SAVE_OFFSETS_ON_FAILURE DURATION=0
        #if defined calibrate probe
        # que for save
        _TC_UPDATE_OFFSETS TOOL={tool_num} 
        M104 S0 T{tool_num} # cool
      {% endfor %}
      T0 X={call_pos[0]} Y={call_pos[1]} Z={call_pos[2]}
      _TC_ADJUST_TTBZ_DRIFT
      _TC_UPDATE_OFFSETS SAVE=1 # save the offsets
      # reheat all tools if required.
      {% for tool_num in tools_to_adjust %}
        {% if ns.prstmac["params_T" ~ tool_num|string ~ "TEMP"] is defined %}
          M104 S{ns.prstmac["params_T" ~ tool_num|string ~ "TEMP"]|int - 50} T{tool_num} # todo this may be gibberish
        {% endif %}
      {% endfor %}
    {% else %}
      {% set ns.msg = ns.msg ~ "?s3?tRun 'DETECT_ACTIVE_TOOL_PROBE' if you think this message is a fault.?mNo active Tool, likely a crash. disabling for now." %}
    {% endif %}
  {% endif %}
  {% if '?s3' in ns.msg %}
    _UNIFIED_RESPOND MSG="{ns.msg}"
  {% endif %}



[delayed_gcode _SAVE_OFFSETS_ON_FAILURE]
gcode:
  _UNIFIED_RESPOND MSG="?t?p_SAVE_OFFSETS_ON_FAILURE ?t?s3?m?bProbing failed early. Saving offsets.?b"
  _TC_UPDATE_OFFSETS SAVE=YES

#####################################################################
#   _TC_UPDATE_OFFSETS
#####################################################################
[gcode_macro _TC_UPDATE_OFFSETS]
description: stage tool offsets for save. Usage: _TC_UPDATE_OFFSETS TOOL=X [SAVE], stages the current 'tools_calibrate.last_result' to the toolnumber provided. 
variable_macro_html: "?tStage tool offsets for save.?nUsage: _TC_UPDATE_OFFSETS TOOL=X [SAVE]?nStages the current 'tools_calibrate.last_result' to the toolnumber provided?p_TC_UPDATE_OFFSETS "
variable_storage: {} # why all this gibberish? statistics. (and its easier to read if printed last, all at one place)
gcode:
  {% set p = printer %}
  {% set msg = macro_html %}
  {% set actn = p.tool_probe_endstop.active_tool_number|int %} 
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set has_probe = tcs.get('enable_probe_calibration', False) %}
  {% set svf_mode = tcs.get('svf_auto_repair', '') %}
  {% set r_svf = tcs.get('save_tool_offset_rounding', 3)|int %}

  {% if actn != -1 %}
    # will run quiet if everything ok, its okay to call in same macro.
    # mainly because we will always first record some pos before saving it.
    {% if svf_mode in ['Always', 'Use'] %} _INIT_SVF_KEYS {% endif %}

    {% set svf = p.save_variables.variables %}
    {% if 'SAVE' in params %}
    _TC_ADJUST_TTBZ_DRIFT
      {% set report = [] %}
      {% for tkey in storage %}
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Save the offsets with correct rounding.
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {% set svf_key = 'offsets_' ~ tkey %}
        {% set temp_coords = storage[tkey] %} # our local queed offsets
        {% set old = svf.get(svf_key, {"x": 0.0, "y": 0.0, "z": 0.0}) %} # our current values from svf from all tools

        {% set rounded_coords = {
          "x": temp_coords.x|round(r_svf),
          "y": temp_coords.y|round(r_svf),
          "z": temp_coords.z|round(r_svf)
        } %}
        {% if has_probe %}
          {% set _ = rounded_coords.update({"probe": temp_coords.probe|round(r_svf)}) %}
        {% endif %}

        # â”€â”€â”€â”€â”€| Anything that isnt our first tool, just save, actually easy lol |â”€â”€â”€â”€â”€
        {% if tkey[-1] != "0" %}
          SAVE_VARIABLE VARIABLE={svf_key} VALUE="{rounded_coords}"
        {% else %}

        # â”€â”€â”€â”€â”€| A bit funky here cause we have to specifically seperate probe pos from t0 offsets. |â”€â”€â”€â”€â”€
          {% set old_probe_position = svf.get('probe_position', {}) %}
          {% set _ = old_probe_position.pop("probe") if "probe" in old_probe_position else None %}

          {% set probe_position = old_probe_position.copy() %}
          {% set _ = probe_position.update({ "x": rounded_coords.x, "y": rounded_coords.y, "z": rounded_coords.z }) %} 
          #{% set _ = probe_position.pop("probe") if has_probe else None %} # remove probe from probe pos
          
          # â”€â”€â”€â”€â”€| Save probe pos |â”€â”€â”€â”€â”€
          SAVE_VARIABLE VARIABLE=probe_position VALUE="{probe_position}"
          # move probe from local buffer to t0 offs.
          {% set _ = old.update({"probe": rounded_coords.probe}) if has_probe else None %} # update probe for t0
          # â”€â”€â”€â”€â”€| Save T0 pos |â”€â”€â”€â”€â”€ for t0, save the old offsets with new probe.
          SAVE_VARIABLE VARIABLE={svf_key} VALUE="{old}"  
          {% set _ = old.update(old_probe_position) %} # update our old positions again to do calcs later. (just overwrites xyz)
        {% endif %}

        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # After now theres just tooltips/statistics
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {% set diff = { 
          "x": (old.x|default(0)|float - temp_coords.x)|round(r_svf), 
          "y": (old.y|default(0)|float - temp_coords.y)|round(r_svf), 
          "z": (old.z|default(0)|float - temp_coords.z)|round(r_svf) 
        } %}
        
        # Tooltip formatting
        {% set tooltip = "?tPos: X: " ~ temp_coords.x|round(2) ~ " Y: " ~ temp_coords.y|round(2) ~ " Z: " ~ temp_coords.z|round(2) %}
        {% set tooltip = tooltip ~ "?nDif: X: " ~ diff.x|round(2) ~ " Y: " ~ diff.y|round(2) ~ " Z: " ~ diff.z|round(2) %}
        {% if has_probe %}
          {% set probe_diff = (old.probe|default(-1)|float - temp_coords.probe|default(-1)|float)|round(2) %}
          {% set tooltip = tooltip ~ "?nZ Probe: Z: " ~ temp_coords.probe|round(2) ~ " Diff: " ~ probe_diff|round(2) %}
        {% endif %}
        # -----------------------------------------------------
        # Properly pad the results for display
        # -----------------------------------------------------
        {% set pad = "        " %}

        {% set x = temp_coords.x|round(r_svf) %}
        {% set y = temp_coords.y|round(r_svf) %}
        {% set z = temp_coords.z|round(r_svf) %}
        {% set px = temp_coords.probe|round(r_svf) if has_probe else "" %}

        # ---- stringify
        {% set xstr = x|string %}
        {% set ystr = y|string %}
        {% set zstr = z|string %}
        {% set px_str = px|string if has_probe else "" %}

        {% set xstr_dif = diff.x|string %}
        {% set ystr_dif = diff.y|string %}
        {% set zstr_dif = diff.z|string %}
        {% set px_str_dif = probe_diff|string if has_probe else "" %}

        # ---- pad
        {% set xpad = pad[:8 - xstr|length] %}
        {% set ypad = pad[:8 - ystr|length] %}
        {% set zpad = pad[:8 - zstr|length] %}
        {% set ppad = pad[:8 - px_str|length] if has_probe else "" %}

        {% set xpad_dif = pad[:8 - xstr_dif|length] %}
        {% set ypad_dif = pad[:8 - ystr_dif|length] %}
        {% set zpad_dif = pad[:8 - zstr_dif|length] %}
        {% set ppad_dif = pad[:8 - px_str_dif|length] if has_probe else "" %}

        # ---- construct message
        {% set disp = tooltip ~ "?s0?mSaved ?c" ~ tkey|string|upper ~ "?c  offsets." %}
        {% set disp = disp ~ "?nAbs:  ?cX:" ~ xpad ~ xstr ~ "  Y:" ~ ypad ~ ystr ~ "  Z:" ~ zpad ~ zstr %}
        {% set disp = disp ~ " P:" ~ ppad ~ px_str ~ "?c?n" if has_probe else disp ~ "?c?n" %}

        {% set disp = disp ~ "Diff: ?cX:" ~ xpad_dif ~ xstr_dif ~ "  Y:" ~ ypad_dif ~ ystr_dif ~ "  Z:" ~ zpad_dif ~ zstr_dif %}
        {% set disp = disp ~ " P:" ~ ppad_dif ~ px_str_dif ~ "?c?n" if has_probe else disp ~ "?c?n" %}

        {% set _ = report.append(disp) %} # Append report
        
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Log parameters to rolling SVF if its enabled, with correct rounding
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        {% set logparams = "TN=" ~ tkey ~ " X=" ~ (temp_coords.x) ~ " Y=" ~ (temp_coords.y) ~ " Z=" ~ (temp_coords.z) %}
        {% set logparams = logparams ~ " PROBE=" ~ (temp_coords.probe) if has_probe else logparams %}
        _TC_LOG_OFFSET_HISTORY {logparams}
      {% endfor %}

      {% set msg = msg ~ '?s0?t?mSaved ?b' ~ storage|length|string ~ ' ?btool offsets?n' ~ report|join() %}
      SET_GCODE_VARIABLE MACRO=_TC_UPDATE_OFFSETS VARIABLE=storage VALUE={{}} # clear storage
    {% else %}
      # -----------------------------------------------------
      # This block below appends to the local macro variable
      # -----------------------------------------------------
      {% set ns = namespace(tn="", new = storage.copy()) %}
      {% if rawparams %} {% for c in rawparams.split()[0] %} {% set ns.tn = ns.tn ~ c if "0" <= c <= "9" else ns.tn %} {% endfor %} {% endif %}# retrieve number from first param provided
      {% if ns.tn|length > 0 %}  # if parameter provided
        {% set tn = p.toolchanger.tool_names[ns.tn|int]|replace("tool ", "")|lower %}
        # set last results
        {% set lastResult = p.tools_calibrate.last_result %}
        {% set temp_coords = {"x": lastResult[0], "y": lastResult[1], "z": lastResult[2]} %}
        # add probe
        {% if has_probe %} {% set _ = temp_coords.update({"probe": p.tools_calibrate.last_probe_offset|default(1)}) %} {% endif %}
        # save appended values
        {% set _ = ns.new.update({tn: temp_coords}) %}
        {% set msg = msg ~ "?s0?t" ~ temp_coords ~ "mQueed" ~ tn|upper ~ "for save..." %}
        SET_GCODE_VARIABLE MACRO=_TC_UPDATE_OFFSETS VARIABLE=storage VALUE="{ns.new}"
      {% else %}
        {% set msg = msg ~ "?s3?tFirst parameter provided should contain toolnumber, valid examples would be:?nABC=1?nTN=2?nT=T1?nTOOL='tool TX1'?netc....?mFirst parameter missing ?ctoolnum?c" %}
      {% endif %}
    {% endif %}
  {% else %}
    {% set msg = msg ~ "?s3?t?mNo active Tool, likely a crash. disabling for now." %}
  {% endif %}
  _UNIFIED_RESPOND MSG="{msg}"


#####################################################################
#   _TC_ADJUST_TTBZ_DRIFT
#####################################################################
[gcode_macro _TC_ADJUST_TTBZ_DRIFT]
description: "Auto-adjust probe trigger_to_bottom_z drift across staged tools. Run after _TC_UPDATE_OFFSETS to apply drift correction."
variable_macro_html: "?tAuto-adjust probe trigger_to_bottom_z drift across tools?p_TC_ADJUST_TTBZ_DRIFT "
variable_key_name: "ttbz_drift"
gcode:
  {% set p = printer %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% if 'ttbz_drift_autoadjust' in tcs %}
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Load userâ€‘config & staged offsets
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    {% set cfg          = tcs.get('ttbz_drift_autoadjust', {}) %}
    {% set min_tools    = cfg.get('min_tools', 2)|int %}
    {% set max_drift    = cfg.get('max_drift', 0.4)|float %}
    {% set k_mad        = cfg.get('mad_k', 3)|float %}
    {% set hist_span    = cfg.get('weight_history', 0.3)|float %}
    {% set debug_mode   = cfg.get('debug', True) %}
    {% set storage      = p['gcode_macro _TC_UPDATE_OFFSETS'].storage %}
    {% if storage|length == 0 %}
      _UNIFIED_RESPOND MSG="{macro_html}?s3?t?mNo staged offsets, run _TC_UPDATE_OFFSETS first."
    {% else %}
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Build current diffs & historyâ€‘weights
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {% set svf_vars   = p.save_variables.variables %}
      {% set prev_pos   = svf_vars.get('probe_position', {}) %}
      {% set prev_drift = prev_pos.get(key_name, 0)|float %}
      {% set keys       = storage.keys()|list %}
      {% set diffs  = [] %}
      {% set hw_arr = [] %}
      {% set dbg    = namespace(spans=[]) %}
      {% for key in keys %}
        {% set cur = storage[key] %}
        {% if 'probe' in cur %}
          {% set old = svf_vars.get('offsets_' ~ key, {}).get('probe', 0)|float %}
          {% set _ = diffs.append(cur.probe|float - old) %}
          # history weight
          {% set span = 0.0 %}
          {% set hw   = 0.5 %}
          {% set hdict = svf_vars.get('offsets_history_' ~ key, {}) %}
          {% if hdict and 'probe' in hdict and hdict.probe|length > 1 %}
            {% set h_recent = hdict.probe[:3] %}
            {% set span = (h_recent|max - h_recent|min)|float %}
            {% set hw = span >= hist_span and 0.0 or (1 - span / hist_span) %}
          {% endif %}
          {% set hw = hw < 0 and 0.0 or hw %}
          {% set hw = hw > 1 and 1.0 or hw %}
          {% set _ = hw_arr.append(hw) %}
          {% if debug_mode %}{% set _ = dbg.spans.append(span) %}{% endif %}
        {% endif %}
      {% endfor %}
      {% set count = diffs|length %}

      # guard
      {% if count == 0 %}
        _UNIFIED_RESPOND MSG="{macro_html}?s3?t?mNo probe entries found in staged offsets."
      {% endif %}

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Median & MAD
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {% set sorted_d = diffs|sort %}
      {% set m = count % 2 == 1 and sorted_d[count//2] or (sorted_d[count//2-1] + sorted_d[count//2]) / 2.0 %}
      {% set absdev   = [] %}
      {% for d in diffs %}{% set _ = absdev.append((d - m)|abs) %}{% endfor %}
      {% set sorted_dev = absdev|sort %}
      {% set MAD = count % 2 == 1 and sorted_dev[count//2] or (sorted_dev[count//2-1] + sorted_dev[count//2]) / 2.0 %}
      {% if MAD == 0 %}{% set MAD = 0.000001 %}{% endif %}

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Combine weights (history Ã— MAD gate)
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {% set ns = namespace(w_sum=0.0, wd_sum=0.0) %}
      {% set weights = [] %}
      {% set reject  = [] %}
      {% for i in range(count) %}
        {% set dev   = absdev[i] %}
        {% set w_var = dev >= k_mad * MAD and 0.0 or 1 - dev / (k_mad * MAD) %}
        {% set w     = (hw_arr[i] * w_var)|float %}
        {% if w < 0 %}{% set w = 0.0 %}{% endif %}
        {% if w > 1 %}{% set w = 1.0 %}{% endif %}
        {% set _ = weights.append(w) %}
        {% if w < 0.05 %}{% set _ = reject.append(i) %}{% endif %}
        {% set ns.w_sum  = ns.w_sum + w %}
        {% set ns.wd_sum = ns.wd_sum + (w * diffs[i]) %}
      {% endfor %}

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Compute new drift
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {% if ns.w_sum == 0 or (weights|select('>',0.05)|list)|length < min_tools %}
        {% set adj    = prev_drift %}
        {% set status = 2 %}
        {% set reason = 'too much spread' %}
      {% else %}
        {% set drift  = ns.wd_sum / ns.w_sum %}
        {% if drift > max_drift %}{% set drift = max_drift %}{% elif drift < -max_drift %}{% set drift = -max_drift %}{% endif %}
        {% set adj    = drift %}
        {% set status = (drift|round(5)) == (prev_drift|round(5)) and 1 or 0 %}
      {% endif %}

      {% set r_save = tcs.get('save_tool_offset_rounding', 4)|int %}

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Save drift & history
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {% set hist_cfg  = tcs.get('offset_history', {}) %}
      {% set rnd_hist  = hist_cfg.get('rounding',3)|int %}
      {% set max_ent   = hist_cfg.get('max_entries',10)|int %}
      {% set prev_hist = svf_vars.get('offsets_history_probe', {}).get(key_name, []) %}
      {% set new_hist  = (prev_hist + [adj|round(rnd_hist)])[-max_ent:] %}
      {% set hvars     = p.save_variables.variables.get('offsets_history_probe', {}) %}
      {% set _         = hvars.update({key_name: new_hist}) %}
      SAVE_VARIABLE VARIABLE=offsets_history_probe VALUE="{hvars}"

      {% set pos = prev_pos.copy() %}
      {% set _   = pos.update({key_name: adj|round(r_save)}) %}
      SAVE_VARIABLE VARIABLE=probe_position VALUE="{pos}"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Apply correction to staged offsets
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {% for key in keys %}
        {% set ent = storage[key] %}
        {% if 'probe' in ent %}
          {% set _ = ent.update({'probe': ent.probe|float - adj}) %}
        {% endif %}
      {% endfor %}
      SET_GCODE_VARIABLE MACRO=_TC_UPDATE_OFFSETS VARIABLE=storage VALUE="{storage}"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Build operator report
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      {% set diag = macro_html ~ '?s1?t?m[med:' ~ (m|round(r_save)|string) ~ ' MAD:' ~ (MAD|round(r_save)|string) ~ ' Î£w:' ~ (ns.w_sum|round(2)|string) ~ ']' %}
      {% if debug_mode %}
        {% for i in range(count) %}
          {% set dbg_line = '?s2?t?mDBG ' ~ keys[i] ~ ' span:' ~ (dbg.spans[i]|round(4)|string) ~ ' hw:' ~ (hw_arr[i]|round(2)|string) ~ ' w:' ~ (weights[i]|round(2)|string) %}
          {% set diag = diag ~ dbg_line %}
        {% endfor %}
      {% endif %}

      {% set msg_lines = [] %}
      {% for i in range(count) %}
        {% set tool  = keys[i] %}
        {% set delta = diffs[i]|round(r_save) %}
        {% set w_pct = (weights[i]*100)|round(0) %}
        {% set pct   = m == 0 and 0 or (((diffs[i]-m)/m*100)|round(1)) %}
        {% set wrapper_start = i in reject and '?c' or '' %}
        {% set wrapper_end   = i in reject and '?c' or '' %}
        {% set line = wrapper_start ~ tool ~ ': ' ~ delta|string ~ ' mm [' ~ w_pct|string ~ '%] (' ~ pct|string ~ '%)' ~ wrapper_end %}
        {% set _    = msg_lines.append('?s0?t?m' ~ line) %}
      {% endfor %}

      {% if status == 0 %}
        {% set header = '?t?s0?mDrift updated: ?c' ~ (adj|round(r_save)|string) ~ ' mm?c' %}
      {% elif status == 1 %}
        {% set header = '?t?s0?mDrift unchanged (same): ?c' ~ (adj|round(r_save)|string) ~ ' mm?c' %}
      {% else %}
        {% set header = '?t?s0?mDrift unchanged: ?c' ~ (adj|round(r_save)|string) ~ ' mm?c (' ~ reason ~ ')' %}
      {% endif %}
      {% set msg = diag ~ header ~ msg_lines|join('') %}
      _UNIFIED_RESPOND MSG="{msg}"
    {% endif %}
  {% endif %}



#####################################################################
#   _TC_FIND_CALIBRATION_PROBE
#####################################################################
[gcode_macro _TC_FIND_CALIBRATION_PROBE]
variable_macro_html: "?tCalls a macro to move over the calibration probe, and the correct internal command based on tool number selected.?nRefer to '_MOVE_OVER_PROBE' for more info?pTC_ADJUST_HOME_OFFSET"
gcode:
  {% set atn = printer.tool_probe_endstop.active_tool_number|int %}
  {% set epc = printer['gcode_macro _toolchanger_settings'].enable_probe_calibration %}
  {% if atn == -1 %}
    {% set msg = macro_html ~ "?s3?t'tool_probe_endstop.active_tool_number' is: " ~ atn ~ ", run 'DETECT_ACTIVE_TOOLPROBE' to update it.?mNo active tool, aborting" %}
    _UNIFIED_RESPOND MSG="{msg}"
  {% elif atn == 0 %} # If we are T0
    STATUS_CALIBRATING_Z
    _MOVE_OVER_PROBE
    TOOL_LOCATE_SENSOR
    {% if epc %} TOOL_CALIBRATE_PROBE_OFFSET PROBE="tool_probe T{atn}" {% endif %} # todo get probe from tool instead of doing T
  {% else %}
    STATUS_CALIBRATING_Z
    _MOVE_OVER_PROBE
    TOOL_CALIBRATE_TOOL_OFFSET
    {% if epc %} TOOL_CALIBRATE_PROBE_OFFSET PROBE="tool_probe T{atn}" {% endif %} 
  {% endif %}



#####################################################################
#   TC_ADJUST_OFFSETS_UI
#####################################################################
[gcode_macro TC_ADJUST_OFFSETS_UI]
description: Tool offset adjuster and tool selector with prompt UI integration
variable_selected_tool_for_offset: -1
gcode:
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set act = p.tool_probe_endstop.active_tool_number|int %}
  {% set stored = selected_tool_for_offset|default(act)|int %}
  {% set max_off = tcs.get('max_allowed_offsets', 999)|float %}
  {% set msg = "" %}

  {% if params.TOOL is defined %}
    SET_GCODE_VARIABLE MACRO=TC_ADJUST_OFFSETS_UI VARIABLE=selected_tool_for_offset VALUE={params.TOOL|int}
  {% elif params.AXIS is defined and params.AMOUNT is defined %}
    {% set axis = params.AXIS|lower %}
    {% set amount = params.AMOUNT|float|round(3) %}
    {% if axis in ['x', 'y', 'z'] and amount != 0 %}
      {% set toolname = p.toolchanger.tool_names[stored] %}
      {% set key = 'offsets_' ~ toolname|replace('tool ', '', 1)|lower %}
      {% set val = svf[key]|default({}) %}
      {% if val is not mapping %}{% set val = {} %}{% endif %}
      {% set newval = val.copy() %}
      {% set current = val[axis]|default(0)|float %}
      {% set updated = current + amount %}
      {% set updated = (-max_off if updated < -max_off else (max_off if updated > max_off else updated))|round(3) %}
      {% set _ = newval.update({axis: updated}) %}
      SAVE_VARIABLE VARIABLE={key} VALUE="{newval}"
      {% if p.toolchanger.tool_number == stored %}
        SET_GCODE_OFFSET {axis|upper}={updated} MOVE=1
      {% endif %}
      {% set msg = "Adjusted offset for " ~ toolname ~ " " ~ axis ~ " by " ~ amount ~ " â†’ " ~ updated %}
    {% else %}
      {% set msg = "Invalid AXIS or AMOUNT" %}
    {% endif %}
  {% else %}
    RESPOND TYPE=command MSG="action:prompt_begin Adjust Tool Offsets"

    {% set toolnames = p.toolchanger.tool_names %}
    {% set increments = [0.1, 0.05, 0.01, -0.1, -0.05, -0.01] %}

    {% for i in range(toolnames|length) %}
      {% if i % 3 == 0 %}RESPOND TYPE=command MSG="action:prompt_button_group_start"{% endif %}
      {% set name = toolnames[i]|replace('tool ', '') %}
      {% set color = 'primary' if i == stored else '' %}
      RESPOND TYPE=command MSG="action:prompt_button {name}|TC_ADJUST_OFFSETS_UI TOOL={i}|{color}"
      {% if i % 3 == 2 or i == toolnames|length - 1 %}RESPOND TYPE=command MSG="action:prompt_button_group_end"{% endif %}
    {% endfor %}

    {% for ax in ['X', 'Y', 'Z'] %}
      RESPOND TYPE=command MSG="action:prompt_text {ax} offset"
      {% for i in range(increments|length) %}
        {% if i % 3 == 0 %}RESPOND TYPE=command MSG="action:prompt_button_group_start"{% endif %}
        {% set val = increments[i] %}
        {% set sign = '+' if val > 0 else '' %}
        {% set color = 'info' if ax == 'X' else ('warning' if ax == 'Y' else 'error') %}
        RESPOND TYPE=command MSG="action:prompt_button {sign}{val}|TC_ADJUST_OFFSETS_UI AXIS={ax} AMOUNT={val}|{color}"
        {% if i % 3 == 2 or i == increments|length - 1 %}RESPOND TYPE=command MSG="action:prompt_button_group_end"{% endif %}
      {% endfor %}
    {% endfor %}

    RESPOND TYPE=command MSG="action:prompt_footer_button CLOSE|RESPOND TYPE=command MSG=action:prompt_end"
    RESPOND TYPE=command MSG="action:prompt_show"
  {% endif %}

  {% if msg and params.SILENT is not defined %}
    RESPOND TYPE=echo MSG="{msg}"
  {% endif %}



[gcode_macro TC_ADJUST_OFFSET]
description: Adjust an offset by specifying tool, axis, and amount to adjust.
             TC_ADJUST_OFFSET TOOL=1 AXIS=X AMOUNT=0.050
variable_macro_html: "?tTC_ADJUST_OFFSET TOOL=1 AXIS=X AMOUNT=0.050?pTC_ADJUST_OFFSET "
gcode:
  {% set ns = namespace(msg = macro_html|string) %}
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set max_off = tcs.get('max_allowed_offsets', 999)|float %}

  {% set actn = p.tool_probe_endstop.active_tool_number|int %}
  {% set tn = (params.TOOL|int if params.TOOL is defined else actn) %}
  {% set axis = params.AXIS|default("")|lower %}
  {% set amount = params.AMOUNT|default(0.000)|float|round(3) %}

  {% if tn >= 0 and axis in ['x', 'y', 'z'] and amount != 0 %}
    # get key
    {% set toolname = p.toolchanger.tool_names[tn] %}
    {% set key = 'offsets_' ~ toolname|replace('tool ', '', 1)|lower %}
    {% set val = svf[key]|default({}) %}
    {% set val = {} if val is not mapping else val %}
    {% set newval = val.copy() %}
    {% set current = val[axis]|default(0)|float %}
    {% set updated = (current + amount)|round(3) %}
    # clamp
    {% set updated = (-max_off if updated < -max_off else (max_off if updated > max_off else updated))|round(3) %}
    # update dict and save
    {% set _ = newval.update({axis: updated}) %}
    SAVE_VARIABLE VARIABLE={key} VALUE="{newval}"
    {% if p.toolchanger.tool_number == tn %}
      SET_GCODE_OFFSET {axis|upper}={updated} MOVE=1
    {% endif %}
    {% set ns.msg = ns.msg ~ "?s0?mAdjusted offset for?c" ~ toolname ~ "?c axis ?c" ~ axis ~ "?c by " ~ amount ~ "mm â†’ new: " ~ updated %}
  {% elif tn == -1 %}
    {% set ns.msg = ns.msg ~ "?s4?mNo tool number provided and no active tool available." %}
  {% elif axis not in ['x', 'y', 'z'] %}
    {% set ns.msg = ns.msg ~ "?s4?mUnknown or missing axis: ?c" ~ axis ~ "?c. Only x, y, or z supported." %}
  {% elif amount == 0 %}
    {% set ns.msg = ns.msg ~ "?s4?mAdjustment amount must be non-zero." %}
  {% endif %}
  {% if params.SILENT is not defined %}
    _UNIFIED_RESPOND MSG="{ns.msg}"
  {% endif %}

#####################################################################
#   TC_GET_PROBE_TRIGGER_TO_BOTTOM
#####################################################################
[gcode_macro TC_GET_PROBE_TRIGGER_TO_BOTTOM]
description: Calculates correct trigger_to_bottom_z using trusted z_offset (trusted = current tool)
gcode:
  {% if printer.tool_probe_endstop.active_tool_number|int != -1 %}
    {% set probe = printer.probe.active_tool_probe %}
    {% set cur_probe_offset = printer.tool_probe_endstop.active_tool_probe_z_offset|float %}
    _MOVE_OVER_PROBE
    {% if probe == "tool_probe T0" %}
      TOOL_LOCATE_SENSOR
    {% else %}
      TOOL_CALIBRATE_TOOL_OFFSET
    {% endif %}
    TOOL_CALIBRATE_PROBE_OFFSET
    _TC_GET_PROBE_TRIGGER_TO_BOTTOM
    {% set feed = printer['configfile'].config["tools_calibrate"]["travel_speed"]|int * 60  %}
    G0 X{printer.configfile.config.stepper_x.position_max|float / 2} Y{printer.configfile.config.stepper_y.position_max|float / 2} F{feed}
  {% endif %}

[gcode_macro _TC_GET_PROBE_TRIGGER_TO_BOTTOM]
gcode:
  {% if printer.tool_probe_endstop.active_tool_number|int != -1 %}
    {% set cur_probe_offset = printer.tool_probe_endstop.active_tool_probe_z_offset|float %}
    {% set last_probe_offset = printer.tools_calibrate.last_probe_offset|float %}
    {% set ttb_old = printer.configfile.settings.tools_calibrate.trigger_to_bottom_z|float %}
    {% set ttb_new = cur_probe_offset - (last_probe_offset - ttb_old) %}
    {% set nl = '\u0026\u0023\u0031\u0030\u003b' %}
    {% set hover_text ="ðŸŸ  z_offset: " ~ cur_probe_offset|round(3)|string ~ nl ~"ðŸ”µ last_offset: " ~ last_probe_offset|round(3)|string ~ nl ~"ðŸŸ£ old trigger_to_bottom_z: " ~ ttb_old|round(3)|string%}
    RESPOND MSG="<span title='{hover_text}'><b style='color:rgb(0,255,150)'>ðŸŸ¢ trigger_to_bottom_z: {ttb_new|round(4)}</b></span>"
  {% else %}
    RESPOND TYPE=error MSG="No active tool selected for probe calibration."
  {% endif %}


#####################################################################
#   TC_FIND_FIRST_CALIBRATION_PROBE_POSITION
#####################################################################
[gcode_macro TC_FIND_FIRST_CALIBRATION_PROBE_POSITION]
description: "Manually jog tool over probe, then call me and it gets saved to SVF 'probe_position'"
gcode:
  TOOL_LOCATE_SENSOR
  _TC_FIND_FIRST_CALIBRATION_PROBE_POSITION

[gcode_macro _TC_FIND_FIRST_CALIBRATION_PROBE_POSITION]
variable_macro_html: "?tManually jog tool over probe, then call me and it gets saved to SVF 'probe_position' ?pTC_FIND_FIRST_CALIBRATION_PROBE_POSITION "
gcode:
  {% set msg = macro_html %}
  {% set svf = printer.save_variables.variables %}
  {% set probe_pos = printer.tools_calibrate.last_result %}
  {% set pos = {"x": probe_pos[0]|round(2), "y": probe_pos[1]|round(2), "z": probe_pos[2]|round(2)} %}
  {% set msg = msg ~ "?t?mPosition recorded and stored in svf?n?c" ~ pos ~ "?c?ddd" %}
  _UNIFIED_RESPOND MSG="{msg}"
  SAVE_VARIABLE VARIABLE=probe_position VALUE="{pos}"


#####################################################################
#   _INIT_SVF_KEYS   # Initializes and or repairs all the keys we need.
#####################################################################
[gcode_macro _INIT_SVF_KEYS]
description: Ensure all required SVF keys exist (and remove invalid ones)
variable_macro_html: "?tInitializes, and or repairs the offsets keys saved in the save variables file.?p_INIT_SVF_KEYS "
gcode:
  {% set p = printer %}
  {% set svf = p.save_variables.variables %}
  {% set tcs = p['gcode_macro _toolchanger_settings'] %}
  {% set entries = namespace(to_check=[]) %}
  {% set missing  = [] %}
  {% set repaired = [] %}
  {% set removed  = [] %}
  {% set warnings = [] %}

  {% set drift_key   = p['gcode_macro _TC_ADJUST_TTBZ_DRIFT'].get('key_name', 'drift') %}
  {% set probe_keys  = ['x', 'y', 'z', drift_key|string] if (tcs.get('ttbz_drift_autoadjust', {}) != {}) else ['x', 'y', 'z'] %}
  {% set tool_keys   = ['x', 'y', 'z', 'probe'] if tcs.get('enable_probe_calibration', True) else ['x', 'y', 'z']  %}

  #â€”â€”â€”â€”|  Build list of SVF entries to check
  {% set _ = entries.to_check.append({'entry_name':'probe_position','entry_keys':probe_keys}) %}
  {% for name in p.toolchanger.tool_names %}
    {% set _   = entries.to_check.append({'entry_name':'offsets_' ~ name|replace('tool ','')|lower,'entry_keys':tool_keys}) %}
  {% endfor %}

  #â€”â€”â€”â€”|  If offset history is enabled, also add that to check
  {% if tcs.get('offset_history', {}) != {} %}
    {% set _ = entries.to_check.append({'entry_name':'offsets_history_probe','entry_keys':probe_keys,'list_values':True}) %}
    {% for name in p.toolchanger.tool_names %}
      {% set _   = entries.to_check.append({'entry_name':'offsets_history_' ~ name|replace('tool ','')|lower,'entry_keys':tool_keys,'list_values':True}) %}
    {% endfor %}
  {% endif %}
  
  #â€”â€”â€”â€”|  Iterate every SVF entry
  {% for e in entries.to_check %}
    {% set dict_name = e.entry_name %}
    {% set allowed   = e.entry_keys %}
    {% set is_list   = e.get('list_values', False) %}
    {% set cur       = svf.get(dict_name, {}) %}
    {% if cur is not mapping %}{% set cur = {} %}{% endif %}
    {% set new       = cur.copy() %}

    #â€”â€”â€”â€”| Add any missing entry_keys
    {% for k in allowed %}
      {% if k not in new %}
        {% if is_list %}
          {% set _ = new.update({k: []}) %}
        {% else %}
          {% set _ = new.update({k: 0.0}) %}
        {% endif %}
        {% set _ = missing.append(dict_name ~ '.' ~ k) %}
      {% endif %}
    {% endfor %}

    #â€”â€”â€”â€”| Remove any extras
    {% for k in new.keys()|list %}
      {% if k not in allowed %}
        {% if tcs.get('svf_remove_invalid', True) %}{% set _ = new.pop(k) %}{% endif %}
        {% set _ = removed.append(dict_name ~ '.' ~ k) %}
      {% endif %}
    {% endfor %}

    #â€”â€”â€”â€”| Ensure lists are lists.
    {% if is_list %}
      {% for k in allowed %}
        {% if new[k] is not sequence %}
          {% set _ = new.update({k: []}) %}
          {% set _ = repaired.append(dict_name ~ '.' ~ k ~ ' reset to list') %}
        {% endif %}
      {% endfor %}
    {% endif %}

    #â€”â€”â€”â€”| Save back if changed
    {% if new != cur %}
      SAVE_VARIABLE VARIABLE={dict_name} VALUE="{new}"
      #{% set _ = repaired.append(dict_name) %}
    {% endif %}

    #â€”â€”â€”â€”| Warn if this is the first tool and any axis != 0
    {% if dict_name == 'offsets_' ~ p.toolchanger.tool_names[0]|replace('tool ','')|lower and
          (new.x|default(0)|float != 0 or new.y|default(0)|float != 0 or new.z|default(0)|float != 0) %}
      {% set _ = warnings.append('Tool 0 offsets should always be (0,0,0)!') %}
    {% endif %}
  {% endfor %}

  #â€”â€”â€”â€”|  Final console report
  {% if missing|length !=0 or removed|length!=0 or repaired|length!=0 or warnings|length!=0 %}
    {% set out = [] %}
    {% set _ = out.append("?s0?t?mUpdated your ?bsave variables file?b") %}
    {% if repaired %} {% set _ = out.append("?s2?t?m?cRepaired the following dicts:?c?n  -> " ~ repaired|join("?n  -> ")) %}{% endif %}
    {% if missing %}  {% set _ = out.append("?s0?t?m?cAdded the missing keys:?c?n  -> " ~ missing|join("?n  -> ")) %}{% endif %}
    {% if removed %}  {% set _ = out.append("?s4?t?m?cRemoved:?c?n  -> " ~ removed|join("?n  -> ")) %}{% endif %}
    {% if warnings %} {% set _ = out.append("?s4?t?m?cWarning: ?c" ~ warnings|join("?n  -> ")) %}{% endif %}
    _UNIFIED_RESPOND MSG="{macro_html ~ out|join('')}"
  {% endif %}

