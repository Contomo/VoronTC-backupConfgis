#   ini, twig, liquid, vento, smarty, salt, yaml, hcl, jinja2
#
#   ^Stats\s+\d+(\.\d+)?[^\r\n]*\r?\n?




    # ╭────────────────── helpers ──────────────────╮
    # ╰──────────────────────────────────────────────╯
# ↻


# DEBUG_OUTPUT STEPPER_NAMES="{% for s in printer.printer.lookup_object('toolhead').get_kinematics().get_steppers() %}{ action_respond_info(s.get_name())} {% endfor %}"

# {action_respond_info(printer.printer.lookup_object('toolhead').get_kinematics().get_steppers()[0]|attr('__dict__').keys()|string)}
# {action_respond_info(printer.printer.lookup_object('toolhead').get_kinematics().get_steppers()[0].keys()|string)}






    
[gcode_macro TEST_XY]
gcode:
    {% set feeeed = params.FEED|default(10000)|int %}
    {%- macro cycle(cmd='G0', feed=10000) -%}
        {%- set s = '=' if cmd != 'G0' else '' -%}
        {%- set d = 'D=100' if s else '' -%}
        {cmd} X{s}50  Y{s}100 F{s}{feed} {d}
        {cmd} X{s}300 Y{s}100 F{s}{feed/2} {d}
        {cmd} X{s}300 Y{s}320 F{s}{feed/2} {d}
        {cmd} X{s}50  Y{s}320 F{s}{feed} {'D=0' if d else ''}
    {%- endmacro -%}
    MOVE_TO_CENTER Z=15
    {cycle(feed=feeeed)}
    {cycle(cmd='ROUNDED_G0', feed=feeeed)}

# [autotune_tmc stepper_x]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_y]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z1]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z2]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z3]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto


                     # ORCA REFRENCE
                     # 'length_slow': 20,
                     # 'length_fast': 40,
                     # 'feed_slow':   600,
                     # 'feed_fast':   6420,

    #    {%- macro point_distance(p1, p2) -%}
    #        {%- set squared_diffs = [] -%}
    #        {%- set iter = p1.keys()|select('in', p2)|list if p1 is mapping else range([p1|length, p2|length]|min) -%}
    #        {%- for it in iter -%}
    #            {%- set _ = squared_diffs.append( (p2[it]|float - p1[it]|float) **2 ) -%}
    #        {%- endfor -%}
    #        { (squared_diffs|sum) **0.5 }
    #    {%- endmacro -%}





[gcode_macro TESTICLE]
gcode:
    #M82
    #G92 E0
    #G0 X100 Y100 F1000
    #ROUNDED_G0 X=150 D=50 F=1000
    #ROUNDED_G0 Y=150 D=50 F=1000 E=5
    #ROUNDED_G0 X=50 D=50 F=1000
    #ROUNDED_G0 Y=200 D=50 F=1000
    #ROUNDED_G0 X=150 D=50 F=1000
    #ROUNDED_G0 Y=250 D=0 F=1000 E=20
    {action_respond_info(self.name|string)}

[gcode_macro DEBUG_TEMPLATE_OBJECT]
gcode:
    {%- set helpers = printer.printer.lookup_object('gcode_macro _global_helper_macros') -%}
    {%- set dirlist = helpers.template.__dir__() -%}
    RESPOND MSG="template.__dir__={dirlist}"
    {%- if 'module' in dirlist -%}
        {%- set moddir = helpers.template.module.__dir__() -%}
        RESPOND MSG="template.module.__dir__={moddir}"
    {%- endif -%}
    {%- if 'template' in dirlist -%}
        {%- set templdir = helpers.template.template.__dir__() -%}
        RESPOND MSG="template.template.__dir__={templdir}"
    {%- endif -%}







[gcode_macro TIMER]
description: 
variable_start_time: 0
gcode:
    {% if params.START %}
        SET_GCODE_VARIABLE MACRO=TIMER VARIABLE=start_time VALUE="{printer.printer.reactor.monotonic()}"
    {% else %}
        {% set duration = printer.printer.reactor.monotonic() - start_time %}
        {action_respond_info("Operation took: %.6f seconds" % duration)}
    {% endif %}

###############################################
#  Unified inspection / debugging macro
###############################################
[gcode_macro INSPECT_CONTEXT]
description: "Comprehensive dump of the macro 'self' object and its template context."
variable_test_var     = "Hello from test_var"
variable_config_var   = "This is from config_var"
gcode:
    { action_respond_info("=== START CONTEXT INSPECTION ===") }

    # --- build function / variable lists -----------------------------------
    {% set funcs = [] %}
    {% set vars  = [] %}

    {% for item in self.__dir__()|sort %}
        {% set attr = self|attr(item) %}
        {% if attr is callable %}
            {% set _ = funcs.append(item) %}
        {% else %}
            {% set _ = vars.append(item) %}
        {% endif %}
    {% endfor %}

    # --- assemble output ----------------------------------------------------
    {% set out = [] %}
    {% set _ = out.append("--- Self overview ---") %}
    {% set _ = out.append("Actual class: " ~ self.__class__.__name__) %}
    {% set _ = out.append("test_var     : " ~ self.test_var) %}
    {% set _ = out.append("config_var   : " ~ self.config_var) %}

    {% set _ = out.append("\n--- Callables / macros ---") %}
    {% set _ = out.append(funcs|join(", ")) %}
    {% set _ = out.append("\n--- Plain attributes ---") %}
    {% set _ = out.append(vars|join(", ")) %}

    # --- inspect the template render context, if available ------------------
    {% if self._TemplateReference__context is defined %}
        {% set ctx = self._TemplateReference__context %}
        {% if ctx is mapping %}
            {% set _ = out.append("\n--- _TemplateReference__context keys & types ---") %}
            {% for key in ctx.keys()|sort %}
                {% set typename = ctx[key].__class__.__name__ %}
                {% set _ = out.append("  " ~ key ~ " (" ~ typename ~ ")") %}
            {% endfor %}
        {% else %}
            {% set _ = out.append("\n_note_: _TemplateReference__context exists but is not a mapping") %}
        {% endif %}
    {% else %}
        {% set _ = out.append("\n_note_: _TemplateReference__context attribute is missing") %}
    {% endif %}

    # --- spit everything out -------------------------------------------------
    { action_respond_info(out|join("\n")) }
    { action_respond_info("=== END CONTEXT INSPECTION ===") }

[gcode_macro REACTOR_TEST2]
gcode:
    {% import toolchanger_helper as tch with context %}
    {% set reactor      = printer.printer.reactor %}
    {% set start_time   = reactor.monotonic() %}
    {action_respond_info("started: " ~ start_time)}
    {% set _            = tch.get_mounted_tn() %}
    {% set end_time     = reactor.monotonic() %}
    {action_respond_info("end: " ~ (end_time - start_time))}

[delayed_gcode REACTOR_TEST]
gcode:
    RESPOND MSG="reactor triggyniggy"

[gcode_macro JINJA_REACTOR_HOOK]
gcode:
    {% set delay_seconds = params.DELAY|default(5)|float %}
    {action_respond_info("--- JINJA REACTOR HOOK ---")}
    
    # Get the reactor object
    {% set reactor = printer.printer.reactor %}

    # Get our payload object
    {% set payload_obj = printer.printer.lookup_object('delayed_gcode REACTOR_PAYLOAD') %}

    # Get the handle to the INTERNAL method that is designed
    # to be called by the reactor. This will prevent the crash.
    {% set callback_func = payload_obj._gcode_timer_event %}
    {action_respond_info("Using the CORRECT callback function: %s" % callback_func)}

    # Calculate fire time
    {% set fire_time = reactor.monotonic() + delay_seconds %}

    # Register the timer
    {% set _ = reactor.register_timer(callback_func, fire_time) %}

    {action_respond_info("--- TIMER REGISTERED ---")}

[gcode_macro DEBUG_LIST_HEATER_DETAILS]
description: Dumps all available info about each registered heater object.
gcode:
    {action_respond_info("--- DEBUG_LIST_HEATER_DETAILS ---")}

    # Get the 'heaters' manager object
    {% set heater_manager = printer.printer.lookup_object('heaters') %}
    {action_respond_info("Heater Manager Object: %s" % heater_manager)}

    # Check if the list of heaters exists and is not empty
    {% if heater_manager.heaters %}
        {action_respond_info("Found %d heaters in the manager. Details below:" % (heater_manager.heaters|length))}
        
        # Loop through the list and print details for each heater
        {% for heater_obj in heater_manager.heaters %}
            {action_respond_info("--- New Heater Found ---")}
            {action_respond_info("Raw Object String: %s" % heater_obj)}
            {action_respond_info("Object's '.name' attribute: %s" % heater_obj.name)}
        {% endfor %}
    {% else %}
        {action_respond_info("ERROR: Could not find the '.heaters' list within the heater manager object.")}
    {% endif %}
    {action_respond_info("--- End of Debug ---")}




#  {% set curz       = printer.toolhead.position[2] %}
#  {% set increments = [0.05, 0.01, 0.005, -0.05, -0.01, -0.005] %}  
#  #───< macro/short helpers
#
#    #───< move by that amount
#    SAVE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
#    G91
#    G0 Z{amount} #───< move by amount, convince printer we didnt.
#    SET_KINEMATIC_POSITION Z={curz}
#    RESTORE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
#    #───< update every probe in our offsets 
#    {% for tname in p.toolchanger.tool_names if off_key(tname) in svf %}
#      {% set offsets    = svf.get(off_key(tname), {}) %}
#      {% set probe_val  = offsets.get('probe', -1) %}
#      {% set _          = offsets.update({'probe': (probe_val - amount)|round(r_save)}) %}
#      SAVE_VARIABLE VARIABLE={off_key(tname)} VALUE="{offsets}"
#    {% endfor %}
#    #───< update our probes ttbz offset shift
#    {% set pp        = svf.get('probe_position', {}) %}
#    {% set c_ttbz    = pp.get('ttbz', 0) %}
#    {% set _         = pp.update({'ttbz': (c_ttbz - amount)|round(r_save)}) %}
#    {tc.svf_update()} VARIABLE=probe_position VALUE="{pp}"
##########################################################################################
#    {% set start_time, names = printer.printer.reactor.monotonic(), [] %}
#    {% set gcode_macro_obj = printer.printer.objects['gcode_macro'] %}
#    {% for name, helper_obj in printer.printer.objects.items() if name.startswith('gcode_macro ') %}
#        {% set macro_name = name.split(' ', 1)[1] %}
#        {% if macro_name.startswith('_') and macro_name.endswith('_helper') %}
#            {% set _ = names.append(macro_name) %}
#            {% set lib_string = printer.configfile.settings[name].gcode %}
#            {% set compiled_lib = gcode_macro_obj.env.from_string(lib_string, globals=self._TemplateReference__context).module %}
#            {% set _ = helper_obj.__setattr__('lib', compiled_lib) %}
#        {% endif %}
#    {% endfor %}
#    {% set duration = printer.printer.reactor.monotonic() - start_time %}
#    {% if names %}
#        {action_respond_info("Compiled and cached %d helper(s) in %.4f seconds: %s" % (names|length, duration, names|join(', ')))}
#    {% else %}
#        {action_respond_info("Found no helper macros matching '_*_helper' to cache.")}
#    {% endif %}




#{params.items()|map('join', '="')|join('" ') ~ '"'}


#[gcode_macro ACCEPT]
#gcode:
#    {% set config = printer.printer.lookup_object('configfile') %}
#    {% set pending = config.autosave.pending_items %}
#    {% if 'tool_probe_endstop' in pending and 'z_offset' in pending['tool_probe_endstop'] %}
#        {% set offset = pending['tool_probe_endstop'].pop('z_offset', None) %}  
#        {% set _ = pending.pop('tool_probe_endstop', None) %}
#        {% set _ = config.set(printer.tool_probe_endstop.active_tool_probe, 'z_offset', offset) %}
#    {% endif %}


[gcode_macro LOOKUP_OBJECT]
gcode:
  {% set msg = [] %}
  {% set obj = printer.printer.lookup_object(params.OBJECT|default(None), default=None) %}
  {% if obj %}
    {% for name in obj.__dir__()|sort if not name.startswith('_') %}
      {% set attr = obj|attr(name) %}
      {% if attr is callable %}
        {% set _ = msg.append(name ~ " (callable)") %}
      {% else %}
        {% set _ = msg.append(name ~ " (attribute)") %}
      {% endif %}
    {% endfor %}
    {% if params.CALL is defined %}
      RESPOND MSG="{obj|attr(params.CALL)()}"
    {% else %}
      RESPOND MSG="{msg|join('<br>')}"
    {% endif %}
  {% else %}
    RESPOND MSG="no object found named: {obj}"
  {% endif %}


[gcode_macro WAIT_HEAT_SOAK]
variable_duration: 5        # in minutes
variable_threshold_temp: 45 #in °C
gcode:
  {% if printer.heater_bed.temperature <= threshold_temp %}
    HEAT_SOAK_BED
    G4 P{duration * 60 * 1000}
  {% else %}
    RESPOND MSG="skipping heat soak... ({printer.heater_bed.temperature} > {threshold_temp}) "
  {% endif %}

[delayed_gcode _WAIT_HEAT_SOAK]
gcode:
  PRINT_START CONTINUE="True"


[gcode_macro BFS]
description: "A fast, flat, and reliable search for the Klipper object tree. Usage: BFS S=<search> E=<exclude>"
variable_path_color:      "rgb(200,200,200)"
variable_val_color:       "rgb(255,200,50)"
variable_type_color:      "rgb(150,150,150)"
variable_match_color:     "rgb(255,100,150)"
variable_long_limit:      150
variable_max_depth:       10
variable_delimiter:       "°"
variable_timeout:         20 # timeout in seconds
gcode:
    {% set S = params.S|default("")|string %}
    {% if not S %}
        {action_respond_info("BFS Usage: S=<search>°<terms> [E=<exclude>]. Example: BFS S=toolhead°position")}
    {% else %}
        {% set E = params.E|default("")|string %}
        {% set nl = '\n' %}
        {% set search_terms = [] %}{%- for t in (S|lower).split(delimiter) -%}{%- if t -%}{%- set _ = search_terms.append(t) -%}{%- endif -%}{%- endfor -%}
        {% set exclude_terms = [] %}{%- for t in (E|lower).split(delimiter) -%}{%- if t -%}{%- set _ = exclude_terms.append(t) -%}{%- endif -%}{%- endfor -%}

        ; --------------------------------------------------------------------------
        ; STAGE 1: YOUR ORIGINAL, PROVEN SEARCH AND GROUPING LOGIC.
        ; This works. It is left untouched.
        ; --------------------------------------------------------------------------
        {% set queue = namespace(data=[(printer, 'printer')]) %}
        {% set visited = namespace(paths=[]) %}
        {% set results_grouped = namespace(data={}) %}
        {% set total_found = namespace(count=0) %}

        {% set timed = namespace(out=False) %}
        {%- set start_time = printer.printer.reactor.monotonic() -%}
        {% for _ in range(10000) if not timed.out %}
            {% set timed.out = printer.printer.reactor.monotonic() - start_time > timeout %}
            {% if queue.data and total_found.count < 1500 %}
                {% set task = queue.data.pop(0) %}
                {% set current_obj, current_path = task %}

                {% if current_path not in visited.paths %}
                    {% set _ = visited.paths.append(current_path) %}
                    {% set items_to_process = namespace(data=[]) %}
                    {% if current_obj is mapping %}{% for key, value in current_obj.items() %}{% set _ = items_to_process.data.append((key, value)) %}{% endfor %}
                    {% elif current_obj|attr('__dict__') is defined %}{% for key, value in (current_obj|attr('__dict__')).items() %}{% set _ = items_to_process.data.append((key, value)) %}{% endfor %}
                    {% endif %}

                    {% for key, child_obj in items_to_process.data %}
                        {% if not (key|string).startswith('_') %}
                            {% set new_path = current_path ~ '.' ~ key|string %}
                            {% set typ_str = child_obj.__class__.__name__|string %}
                            {% set val_str = "method()" if child_obj is callable else (child_obj|string|e)|truncate(long_limit) %}
                            {% set haystack = (new_path ~ "=" ~ val_str)|lower %}
                            
                            {% set is_excluded = namespace(val=false) %}
                            {% for term in exclude_terms %}{% if term and term in haystack %}{% set is_excluded.val=true %}{% endif %}{% endfor %}
                            
                            {% if not is_excluded.val %}
                                {% set all_found = namespace(val=true) %}
                                {% for term in search_terms %}{% if term not in haystack %}{% set all_found.val=false %}{% endif %}{% endfor %}
                                
                                {% if all_found.val %}
                                    {% set total_found.count = total_found.count + 1 %}
                                    {% if current_path not in results_grouped.data %}{% set _ = results_grouped.data.update({current_path: []}) %}{% endif %}
                                    {% set leaf = {'name': key|string, 'val': val_str, 'typ': typ_str} %}
                                    {% set _ = results_grouped.data[current_path].append(leaf) %}
                                {% endif %}
                            {% endif %}

                            {% if (key != 'printer' and (child_obj is mapping or child_obj|attr('__dict__') is defined)) or loop.first %}
                                {% if (current_path.split('.')|length) < max_depth and new_path not in visited.paths %}
                                    {% set _ = queue.data.append((child_obj, new_path)) %}
                                {% endif %}
                            {% endif %}
                        {% endif %}
                    {% endfor %}
                {% endif %}
            {% endif %}
        {% endfor %}

        ; --------------------------------------------------------------------------
        ; STAGE 2: SIMPLE, FAST, FLAT, SORTED RENDERING.
        ; No recursion, no tree building. Just sorting and printing.
        ; --------------------------------------------------------------------------
        {%- macro highlight(text, terms, color) -%}
            {%- set ns = namespace(current_text=text) -%}
            {%- for term in terms -%}
                {%- if term and term|lower in (ns.current_text)|lower -%}
                    {%- set text_lc = (ns.current_text)|lower -%}
                    {%- set term_lc = term|lower -%}
                    {%- set start = text_lc.find(term_lc) -%}
                    {%- set L = term_lc|length -%}
                    {%- set old_text = ns.current_text -%}
                    {%- set ns.current_text = old_text[:start]~"<span style='background-color:rgba(255,100,150,0.2);color:"~color~";'>"~old_text[start:start+L]~"</span>"~old_text[start+L:] -%}
                {%- endif -%}
            {%- endfor -%}
            {ns.current_text}
        {%- endmacro -%}
        
        {% if total_found.count == 0 %}
            {action_respond_info("BFS: No results found for S='" ~ S ~ "' E='" ~ E ~ "'")}
        {% else %}
            {% set summary = "BFS: Found " ~ total_found.count ~ " results in " ~ (results_grouped.data|length) ~ " objects for S='" ~ S ~ "' E='" ~ E ~ "'" %}
            {% set html = namespace(data="") %}
            
            ; --- Iterate through the PARENT paths, sorted alphabetically to create a visual hierarchy. ---
            {% for path, leaves in results_grouped.data|dictsort %}
                {% set h_path = highlight(path, search_terms, path_color) %}
                
                {% set details_content = namespace(data='') %}
                {% for leaf in leaves|sort(attribute='name') %}
                    {% set h_leaf_name = highlight(leaf.name, search_terms, path_color) %}
                    {% set h_val = highlight(leaf.val, search_terms, val_color) %}
                    {% set leaf_html = "<div style='font-family:monospace;white-space:nowrap;padding-left:15px;'><span style='color:" ~ path_color ~ ";'>" ~ h_leaf_name ~ "</span>=<span style='color:" ~ val_color ~ ";'>" ~ h_val ~ "</span><span style='color:" ~ type_color ~ ";'>(" ~ leaf.typ ~ ")</span></div>" %}
                    {% set details_content.data = details_content.data ~ leaf_html %}
                {% endfor %}
                
                {% set group_html = "<details><summary style='cursor:pointer;'>" ~ h_path ~ " (" ~ (leaves|length) ~ " matches)</summary>" ~ details_content.data ~ "</details>" %}
                {% set html.data = html.data ~ group_html %}
            {% endfor %}

            {action_respond_info(summary ~ nl ~ html.data)}
        {% endif %}
    {% endif %}