







[gcode_macro DROPOFF_TEST]
description: "Calculates and prints a dynamically optimized docking path."
gcode:
    {% set k90 = 0.4142 %}# D = k90 · R  (ligma for 90°)
    {% set tool = printer[printer.toolchanger.tool] if not params.T else printer[printer.toolchanger.tool_names[params.T|int]] %}
    #───< get all our variables from the old tool
    {% set safe_y    = tool.params_safe_y|float %}
    {% set path_speed = tool.params_path_speed|float %}
    {% set tool_size = tool.params_tool_size|default({'x': 60, 'y': 60, 'z': 90}) %}  
    {% set min_D     = tool.params_min_D      |default(25)|float %}
    {% set fast      = tool.params_fast_speed|float %}
    {% set path      = tool.params_dropoff_path %}
    {% set cur = printer.toolhead.position %} 
    {% set dock, limit = {}, {} %} 
    {% set dock      = {'x': tool.get('params_park_x'), 'y': tool.get('params_park_y'), 'z': tool.get('params_park_z')} %}
    
    # ---< build axis limit and dock dict for easy access
    {% for ax in ['x', 'y', 'z'] %}
      {% for lim in ['min', 'max'] %}
        {% set _ = limit.update({lim ~ '_' ~ ax: printer.configfile.config["stepper_" ~ ax]["position_" ~ lim]|float}) %}
      {% endfor %}
    {% endfor %}

    {%- macro _distance(p1, p2) -%}{((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)**0.5}{%- endmacro -%}


    {% set plan = namespace(
        points=[
            (cur.x,               cur.y,                cur.z + 1),
            (cur.x,               safe_y,               cur.z),
            (dock.x,              safe_y,               cur.z),
            (dock.x,              safe_y,               dock.z),
            (dock.x,              dock.y + tool_size.y, dock.z),
            (dock.x,              dock.y,               dock.z)
        ]
    ) %}

    ; --- Check if optimization is needed ---
    {% set p_y_retreat = plan.points[1] %}
    {% set p_x_traverse = plan.points[2] %}
    {% set dx_traverse = (p_x_traverse[0] - p_y_retreat[0])|abs %}
    {% set max_d_for_x_leg = dx_traverse * k90 %}

    {% if max_d_for_x_leg < min_D %}
        { action_respond_info("Path Optimization: X-leg (%.1fmm) is too short for min_D=%.1f. Merging moves." % (dx_traverse, min_D)) }
        {% set new_points = [] %}
        {% for point in plan.points %}{% if loop.index0 != 2 %}
        {% set _ = new_points.append(point) %}{% endif %}{% endfor %}
        {% set plan.points = new_points %}
    {% else %}
        { action_respond_info("Path is long enough. No optimization needed.") }
    {% endif %}
  
    {% set d_values = [] %}
    ; Iterate through the CORNERS of the path (all points except start and end)
    {% for i in range(1, plan.points|length - 1) %}
        {% set p_prev = plan.points[i-1] %}
        {% set p_curr = plan.points[i] %}
        {% set p_next = plan.points[i+1] %}
        {% set len_in = _distance(p_prev, p_curr)|float %}
        {% set len_out = _distance(p_curr, p_next)|float %}
        {% set d_for_corner = [len_in, len_out]|min * k90 %}
        
        {% set _ = d_values.append(d_for_corner) %}
    {% endfor %}
    
    {% set _ = d_values.append(0) %} ; Final move is always D=0

    
    {% set gcode_lines = [] %}
    {% for i in range(1, plan.points|length) %}
        {% set p_prev = plan.points[i-1] %}
        {% set p_curr = plan.points[i] %}
        {% set d_val = d_values[i-1] %}
        
        {% set x_val = " X=%.3f" % p_curr[0] if p_curr[0] != p_prev[0] else "" %}
        {% set y_val = " Y=%.3f" % p_curr[1] if p_curr[1] != p_prev[1] else "" %}
        {% set z_val = " Z=%.3f" % p_curr[2] if p_curr[2] != p_prev[2] else "" %}
        
        {% set gcode_line = "ROUNDED_G0%s%s%s D=%.2f F=%.0f" % (x_val, y_val, z_val, d_val, fast) %}
        {% set _ = gcode_lines.append(gcode_line) %}
    {% endfor %}

    { action_respond_info(gcode_lines|join('\n')) }


