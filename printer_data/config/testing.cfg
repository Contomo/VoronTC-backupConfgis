#   ini, twig, liquid, vento, smarty, salt, yaml, hcl, jinja2
#
#   ^Stats\s+\d+(\.\d+)?[^\r\n]*\r?\n?




    # ╭────────────────── helpers ──────────────────╮
    # ╰──────────────────────────────────────────────╯
# ↻



#######################################################################
# Endstop repeatability test – solid syntax edition
#
# Usage:
#   TEST_ENDSTOP_REPEATABILITY AXIS=X CYCLES=15 RETRACT=4
#######################################################################

[gcode_macro TEST_ENDSTOP_REPEATABILITY]
description: "Homes repeatedly, logs MCU steps, then prints statistics."
variable_results: []                       # persistent list of step values
gcode:
    {% set axis    = params.get('AXIS','')|upper %}
    {% set cycles  = params.get('CYCLES',10)|int %}
    {% set retract = params.get('RETRACT',5)|float %}

    {% if axis not in ['X','Y','Z'] %}
        { action_respond_info("AXIS must be X, Y or Z") }
    {% elif cycles < 2 %}
        { action_respond_info("CYCLES must be ≥ 2") }
    {% else %}
        {% set stepper_cfg    = printer.configfile.settings['stepper_' ~ axis|lower] %}
        {% set homes_positive = stepper_cfg.get('homing_positive_dir', False) %}
        {% set retract_sign   = '-' if homes_positive else '' %}

        { action_respond_info("▶ Repeatability test on %s-axis — %d cycles, retract %.2f mm" % (axis, cycles, retract)) }

        {% for i in range(cycles) %}
            G28 {axis}
            M400
            G0 {axis}{retract_sign}{retract}
            M400

            # --- Grab MCU position for the correct stepper object ---
            {% set toolhead  = printer.printer.lookup_object('toolhead') %}
            {% set kin       = toolhead.get_kinematics() %}
            {% set ns = namespace(stepper=None) %}
            {% for s in kin.get_steppers() %}
                {% if s.get_name() == 'stepper_' ~ axis|lower %}
                    {% set ns.stepper = s %}
                {% endif %}
            {% endfor %}
            {% if ns.stepper is none %}
                { action_raise_error("Could not locate stepper for axis " ~ axis) }
            {% endif %}
            {% set mcu_pos = ns.stepper.get_mcu_position() %}

            # --- Append to shared list ---
            {% set res = printer['gcode_macro TEST_ENDSTOP_REPEATABILITY'].results %}
            {% set _ = res.append(mcu_pos) %}
        {% endfor %}
            SET_GCODE_VARIABLE MACRO=TEST_ENDSTOP_REPEATABILITY VARIABLE=results VALUE="{res}"
        _PROCESS_ENDSTOP_RESULTS AXIS={axis}
    {% endif %}


[gcode_macro _PROCESS_ENDSTOP_RESULTS]
description: "Analyzes the collected step list and prints a single report."
gcode:
  {% set axis  = params.get('AXIS','')|upper %}
  {% set data  = printer['gcode_macro TEST_ENDSTOP_REPEATABILITY'].results %}
  {% set count = data|length %}

  {% if count < 2 %}
      { action_respond_info("Not enough samples — got %d, need at least 2." % count) }
  {% else %}
      # --- Step distance (one-liner) ---
      {% set cfg = printer.configfile.settings['stepper_' ~ axis|lower] %}
      {% set step_dist = cfg.rotation_distance|float /
                         (cfg.get('full_steps_per_rotation',200)|float *
                          cfg.microsteps|float) %}

      # --- Stats ---
      {% set min_s   = data|min %}
      {% set max_s   = data|max %}
      {% set range_s = max_s - min_s %}
      {% set avg_s   = (data|sum) / count %}
      {% set ns = namespace(ssd=0.0) %}
      {% for v in data %}
          {% set diff = v - avg_s %}
          {% set ns.ssd = ns.ssd + diff*diff %}
      {% endfor %}
      {% set std_s  = (ns.ssd / count)**0.5 %}

      {% set range_mm = range_s * step_dist %}
      {% set std_mm   = std_s  * step_dist %}

      # --- One-block report ---
      {% set report = [
          "="*40,
          "Endstop Repeatability Results — %s-axis" % axis,
          "Cycles Run         : %d" % count,
          "-"*20,
          "Range (Max-Min)    : %.6f mm  (%d steps)" % (range_mm, range_s),
          "Standard Deviation : %.6f mm  (%.2f steps)" % (std_mm, std_s),
          "-"*20,
          "Raw MCU steps      : %s" % data,
          "="*40
      ] %}

      { action_respond_info(report|join('\n')) }
  {% endif %}


[gcode_macro TEST_XY]
gcode:
    {% set feeeed = params.FEED|default(10000)|int %}
    {%- macro cycle(cmd='G0', feed=10000) -%}
        {%- set s = '=' if cmd != 'G0' else '' -%}
        {%- set d = 'D=100' if s else '' -%}
        {cmd} X{s}50  Y{s}100 F{s}{feed} {d}
        {cmd} X{s}300 Y{s}100 F{s}{feed/2} {d}
        {cmd} X{s}300 Y{s}320 F{s}{feed/2} {d}
        {cmd} X{s}50  Y{s}320 F{s}{feed} {'D=0' if d else ''}
    {%- endmacro -%}
    MOVE_TO_CENTER Z=15
    {cycle(feed=feeeed)}
    {cycle(cmd='ROUNDED_G0', feed=feeeed)}

# [autotune_tmc stepper_x]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_y]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z1]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z2]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto
# 
# [autotune_tmc stepper_z3]
# motor: omc-17he19-2004s
# voltage: 48
# tuning_goal: auto


[gcode_macro DRAW_LINE]
gcode:
    {% set SPEED = params.SPEED|default(900)|int %}
    G92 E0 ;Reset Extruder
    G1 Z2.0 F1800 ;Move Z Axis up
    G1 X5.1 Y40 Z0.3 F5000 ;Move to start position
    G1 X5.1 Y140.0 Z0.3 F{SPEED} E15 ;Draw the first line
    G1 X5.4 Y140.0 Z0.3 F{SPEED} ;Move to side a little
    G1 X5.4 Y40 Z0.3 F{SPEED}.0 E30 ;Draw the second line
    G92 E0 ;Reset Extruder
    G1 Z2.0 F3000 ;Move Z Axis up
    G4 P2000


# EXCLUDE_OBJECT_DEFINE NAME=axolotl.stl_id_0_copy_0 CENTER=176.699,175.953 POLYGON=[[156.732,156.558],[156.751,156.431],[156.784,156.312],[156.818,156.205],[156.873,156.059],[156.917,155.954],[156.979,155.828],[157.058,155.679],[159.161,151.814],[164.76,142.194],[165.052,141.715],[165.254,141.411],[165.47,141.099],[165.667,140.831],[165.944,140.476],[166.197,140.174],[166.51,139.817],[166.864,139.444],[167.096,139.215],[167.34,138.989],[167.506,138.838],[167.693,138.675],[167.826,138.56],[168.124,138.314],[168.47,138.048],[168.804,137.807],[169.076,137.623],[169.497,137.354],[170.058,137.025],[170.506,136.793],[170.613,136.739],[170.992,136.556],[171.533,136.324],[172.034,136.132],[172.51,135.969],[172.917,135.847],[173.219,135.765],[173.572,135.677],[173.999,135.585],[174.622,135.473],[175.3,135.388],[175.777,135.349],[176.072,135.333],[176.387,135.321],[176.96,135.319],[177.458,135.34],[177.533,135.343],[177.996,135.378],[178.395,135.423],[178.805,135.478],[179.313,135.569],[179.326,135.572],[179.791,135.671],[179.948,135.706],[180.292,135.794],[180.574,135.873],[181.069,136.029],[181.572,136.21],[181.991,136.378],[182.029,136.393],[182.439,136.573],[182.744,136.717],[183.098,136.899],[183.484,137.108],[183.759,137.269],[184.145,137.509],[184.323,137.625],[184.614,137.822],[185.003,138.104],[185.505,138.502],[185.86,138.81],[186.093,139.018],[186.451,139.362],[186.817,139.744],[187.123,140.084],[187.361,140.363],[187.54,140.587],[187.799,140.923],[188.026,141.238],[188.236,141.547],[188.506,141.974],[188.746,142.382],[194.236,151.814],[196.339,155.679],[196.418,155.828],[196.48,155.954],[196.524,156.059],[196.579,156.205],[196.613,156.312],[196.646,156.431],[196.665,156.558],[196.657,156.666],[196.651,156.738],[196.645,156.813],[191.574,187.919],[191.506,188.187],[191.419,188.375],[178.025,215.685],[177.837,216.008],[177.599,216.261],[177.321,216.442],[177.017,216.551],[176.699,216.587],[176.38,216.551],[176.076,216.442],[175.798,216.261],[175.56,216.008],[175.372,215.685],[161.979,188.377],[161.891,188.186],[161.823,187.92],[156.752,156.813],[156.746,156.738],[156.74,156.666],[156.732,156.558]]


[gcode_macro TESTICLE]
gcode:
    M82
    G92 E0
    G0 X100 Y100 F1000
    ROUNDED_G0 X=150 D=50 F=1000
    ROUNDED_G0 Y=150 D=50 F=1000 E=5
    ROUNDED_G0 X=50 D=50 F=1000
    ROUNDED_G0 Y=200 D=50 F=1000
    ROUNDED_G0 X=150 D=50 F=1000
    ROUNDED_G0 Y=250 D=0 F=1000 E=20


[gcode_macro DEBUG_TEMPLATE_OBJECT]
gcode:
    {%- set helpers = printer.printer.lookup_object('gcode_macro _global_helper_macros') -%}
    {%- set dirlist = helpers.template.__dir__() -%}
    RESPOND MSG="template.__dir__={dirlist}"
    {%- if 'module' in dirlist -%}
        {%- set moddir = helpers.template.module.__dir__() -%}
        RESPOND MSG="template.module.__dir__={moddir}"
    {%- endif -%}
    {%- if 'template' in dirlist -%}
        {%- set templdir = helpers.template.template.__dir__() -%}
        RESPOND MSG="template.template.__dir__={templdir}"
    {%- endif -%}







[gcode_macro TIMER]
description: 
variable_start_time: 0
gcode:
    {% if params.START %}
        SET_GCODE_VARIABLE MACRO=TIMER VARIABLE=start_time VALUE="{printer.printer.reactor.monotonic()}"
    {% else %}
        {% set duration = printer.printer.reactor.monotonic() - start_time %}
        {action_respond_info("Operation took: %.6f seconds" % duration)}
    {% endif %}

###############################################
#  Unified inspection / debugging macro
###############################################
[gcode_macro INSPECT_CONTEXT]
description: "Comprehensive dump of the macro 'self' object and its template context."
variable_test_var     = "Hello from test_var"
variable_config_var   = "This is from config_var"
gcode:
    { action_respond_info("=== START CONTEXT INSPECTION ===") }

    # --- build function / variable lists -----------------------------------
    {% set funcs = [] %}
    {% set vars  = [] %}

    {% for item in self.__dir__()|sort %}
        {% set attr = self|attr(item) %}
        {% if attr is callable %}
            {% set _ = funcs.append(item) %}
        {% else %}
            {% set _ = vars.append(item) %}
        {% endif %}
    {% endfor %}

    # --- assemble output ----------------------------------------------------
    {% set out = [] %}
    {% set _ = out.append("--- Self overview ---") %}
    {% set _ = out.append("Actual class: " ~ self.__class__.__name__) %}
    {% set _ = out.append("test_var     : " ~ self.test_var) %}
    {% set _ = out.append("config_var   : " ~ self.config_var) %}

    {% set _ = out.append("\n--- Callables / macros ---") %}
    {% set _ = out.append(funcs|join(", ")) %}
    {% set _ = out.append("\n--- Plain attributes ---") %}
    {% set _ = out.append(vars|join(", ")) %}

    # --- inspect the template render context, if available ------------------
    {% if self._TemplateReference__context is defined %}
        {% set ctx = self._TemplateReference__context %}
        {% if ctx is mapping %}
            {% set _ = out.append("\n--- _TemplateReference__context keys & types ---") %}
            {% for key in ctx.keys()|sort %}
                {% set typename = ctx[key].__class__.__name__ %}
                {% set _ = out.append("  " ~ key ~ " (" ~ typename ~ ")") %}
            {% endfor %}
        {% else %}
            {% set _ = out.append("\n_note_: _TemplateReference__context exists but is not a mapping") %}
        {% endif %}
    {% else %}
        {% set _ = out.append("\n_note_: _TemplateReference__context attribute is missing") %}
    {% endif %}

    # --- spit everything out -------------------------------------------------
    { action_respond_info(out|join("\n")) }
    { action_respond_info("=== END CONTEXT INSPECTION ===") }




[delayed_gcode REACTOR_PAYLOAD]
gcode:
    RESPOND MSG="reactor triggyniggy"

[gcode_macro JINJA_REACTOR_HOOK]
gcode:
    {% set delay_seconds = params.DELAY|default(5)|float %}
    {action_respond_info("--- JINJA REACTOR HOOK ---")}
    
    # Get the reactor object
    {% set reactor = printer.printer.reactor %}

    # Get our payload object
    {% set payload_obj = printer.printer.lookup_object('delayed_gcode REACTOR_PAYLOAD') %}

    # Get the handle to the INTERNAL method that is designed
    # to be called by the reactor. This will prevent the crash.
    {% set callback_func = payload_obj._gcode_timer_event %}
    {action_respond_info("Using the CORRECT callback function: %s" % callback_func)}

    # Calculate fire time
    {% set fire_time = reactor.monotonic() + delay_seconds %}

    # Register the timer
    {% set _ = reactor.register_timer(callback_func, fire_time) %}

    {action_respond_info("--- TIMER REGISTERED ---")}

[gcode_macro DEBUG_LIST_HEATER_DETAILS]
description: Dumps all available info about each registered heater object.
gcode:
    {action_respond_info("--- DEBUG_LIST_HEATER_DETAILS ---")}

    # Get the 'heaters' manager object
    {% set heater_manager = printer.printer.lookup_object('heaters') %}
    {action_respond_info("Heater Manager Object: %s" % heater_manager)}

    # Check if the list of heaters exists and is not empty
    {% if heater_manager.heaters %}
        {action_respond_info("Found %d heaters in the manager. Details below:" % (heater_manager.heaters|length))}
        
        # Loop through the list and print details for each heater
        {% for heater_obj in heater_manager.heaters %}
            {action_respond_info("--- New Heater Found ---")}
            {action_respond_info("Raw Object String: %s" % heater_obj)}
            {action_respond_info("Object's '.name' attribute: %s" % heater_obj.name)}
        {% endfor %}
    {% else %}
        {action_respond_info("ERROR: Could not find the '.heaters' list within the heater manager object.")}
    {% endif %}
    {action_respond_info("--- End of Debug ---")}


[gcode_macro DROPOFF_TEST]
description: "Calculates and prints a dynamically optimized docking path."
gcode:
    {% set k90 = 0.4142 %}# D = k90 · R  (ligma for 90°)
    {% set tool = printer[printer.toolchanger.tool] if not params.T else printer[printer.toolchanger.tool_names[params.T|int]] %}
    #───< get all our variables from the old tool
    {% set safe_y    = tool.params_safe_y|float %}
    {% set path_speed = tool.params_path_speed|float %}
    {% set tool_size = tool.params_tool_size|default({'x': 60, 'y': 60, 'z': 90}) %}  
    {% set min_D     = tool.params_min_D      |default(25)|float %}
    {% set fast      = tool.params_fast_speed|float %}
    {% set path      = tool.params_dropoff_path %}
    {% set cur = printer.toolhead.position %} 
    {% set dock, limit = {}, {} %} 
    {% set dock      = {'x': tool.get('params_park_x'), 'y': tool.get('params_park_y'), 'z': tool.get('params_park_z')} %}
    
    # ---< build axis limit and dock dict for easy access
    {% for ax in ['x', 'y', 'z'] %}
      {% for lim in ['min', 'max'] %}
        {% set _ = limit.update({lim ~ '_' ~ ax: printer.configfile.config["stepper_" ~ ax]["position_" ~ lim]|float}) %}
      {% endfor %}
    {% endfor %}

    {%- macro _distance(p1, p2) -%}{((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)**0.5}{%- endmacro -%}


    {% set plan = namespace(
        points=[
            (cur.x,               cur.y,                cur.z + 1),
            (cur.x,               safe_y,               cur.z),
            (dock.x,              safe_y,               cur.z),
            (dock.x,              safe_y,               dock.z),
            (dock.x,              dock.y + tool_size.y, dock.z),
            (dock.x,              dock.y,               dock.z)
        ]
    ) %}

    ; --- Check if optimization is needed ---
    {% set p_y_retreat = plan.points[1] %}
    {% set p_x_traverse = plan.points[2] %}
    {% set dx_traverse = (p_x_traverse[0] - p_y_retreat[0])|abs %}
    {% set max_d_for_x_leg = dx_traverse * k90 %}

    {% if max_d_for_x_leg < min_D %}
        { action_respond_info("Path Optimization: X-leg (%.1fmm) is too short for min_D=%.1f. Merging moves." % (dx_traverse, min_D)) }
        {% set new_points = [] %}
        {% for point in plan.points %}{% if loop.index0 != 2 %}
        {% set _ = new_points.append(point) %}{% endif %}{% endfor %}
        {% set plan.points = new_points %}
    {% else %}
        { action_respond_info("Path is long enough. No optimization needed.") }
    {% endif %}
  
    {% set d_values = [] %}
    ; Iterate through the CORNERS of the path (all points except start and end)
    {% for i in range(1, plan.points|length - 1) %}
        {% set p_prev = plan.points[i-1] %}
        {% set p_curr = plan.points[i] %}
        {% set p_next = plan.points[i+1] %}
        {% set len_in = _distance(p_prev, p_curr)|float %}
        {% set len_out = _distance(p_curr, p_next)|float %}
        {% set d_for_corner = [len_in, len_out]|min * k90 %}
        
        {% set _ = d_values.append(d_for_corner) %}
    {% endfor %}
    
    {% set _ = d_values.append(0) %} ; Final move is always D=0

    
    {% set gcode_lines = [] %}
    {% for i in range(1, plan.points|length) %}
        {% set p_prev = plan.points[i-1] %}
        {% set p_curr = plan.points[i] %}
        {% set d_val = d_values[i-1] %}
        
        {% set x_val = " X=%.3f" % p_curr[0] if p_curr[0] != p_prev[0] else "" %}
        {% set y_val = " Y=%.3f" % p_curr[1] if p_curr[1] != p_prev[1] else "" %}
        {% set z_val = " Z=%.3f" % p_curr[2] if p_curr[2] != p_prev[2] else "" %}
        
        {% set gcode_line = "ROUNDED_G0%s%s%s D=%.2f F=%.0f" % (x_val, y_val, z_val, d_val, fast) %}
        {% set _ = gcode_lines.append(gcode_line) %}
    {% endfor %}

    { action_respond_info(gcode_lines|join('\n')) }






#  {% set curz       = printer.toolhead.position[2] %}
#  {% set increments = [0.05, 0.01, 0.005, -0.05, -0.01, -0.005] %}  
#  #───< macro/short helpers
#
#    #───< move by that amount
#    SAVE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
#    G91
#    G0 Z{amount} #───< move by amount, convince printer we didnt.
#    SET_KINEMATIC_POSITION Z={curz}
#    RESTORE_GCODE_STATE NAME=TC_ADJUST_Z_ALL
#    #───< update every probe in our offsets 
#    {% for tname in p.toolchanger.tool_names if off_key(tname) in svf %}
#      {% set offsets    = svf.get(off_key(tname), {}) %}
#      {% set probe_val  = offsets.get('probe', -1) %}
#      {% set _          = offsets.update({'probe': (probe_val - amount)|round(r_save)}) %}
#      SAVE_VARIABLE VARIABLE={off_key(tname)} VALUE="{offsets}"
#    {% endfor %}
#    #───< update our probes ttbz offset shift
#    {% set pp        = svf.get('probe_position', {}) %}
#    {% set c_ttbz    = pp.get('ttbz', 0) %}
#    {% set _         = pp.update({'ttbz': (c_ttbz - amount)|round(r_save)}) %}
#    {tc.svf_update()} VARIABLE=probe_position VALUE="{pp}"
##########################################################################################
#    {% set start_time, names = printer.printer.reactor.monotonic(), [] %}
#    {% set gcode_macro_obj = printer.printer.objects['gcode_macro'] %}
#    {% for name, helper_obj in printer.printer.objects.items() if name.startswith('gcode_macro ') %}
#        {% set macro_name = name.split(' ', 1)[1] %}
#        {% if macro_name.startswith('_') and macro_name.endswith('_helper') %}
#            {% set _ = names.append(macro_name) %}
#            {% set lib_string = printer.configfile.settings[name].gcode %}
#            {% set compiled_lib = gcode_macro_obj.env.from_string(lib_string, globals=self._TemplateReference__context).module %}
#            {% set _ = helper_obj.__setattr__('lib', compiled_lib) %}
#        {% endif %}
#    {% endfor %}
#    {% set duration = printer.printer.reactor.monotonic() - start_time %}
#    {% if names %}
#        {action_respond_info("Compiled and cached %d helper(s) in %.4f seconds: %s" % (names|length, duration, names|join(', ')))}
#    {% else %}
#        {action_respond_info("Found no helper macros matching '_*_helper' to cache.")}
#    {% endif %}




#{params.items()|map('join', '="')|join('" ') ~ '"'}


#[gcode_macro ACCEPT]
#gcode:
#    {% set config = printer.printer.lookup_object('configfile') %}
#    {% set pending = config.autosave.pending_items %}
#    {% if 'tool_probe_endstop' in pending and 'z_offset' in pending['tool_probe_endstop'] %}
#        {% set offset = pending['tool_probe_endstop'].pop('z_offset', None) %}  
#        {% set _ = pending.pop('tool_probe_endstop', None) %}
#        {% set _ = config.set(printer.tool_probe_endstop.active_tool_probe, 'z_offset', offset) %}
#    {% endif %}


[gcode_macro LOOKUP_OBJECT]
gcode:
  {% set msg = [] %}
  {% set obj = printer.printer.lookup_object(params.OBJECT|default(None), default=None) %}
  {% if obj %}
    {% for name in obj.__dir__()|sort if not name.startswith('_') %}
      {% set attr = obj|attr(name) %}
      {% if attr is callable %}
        {% set _ = msg.append(name ~ " (callable)") %}
      {% else %}
        {% set _ = msg.append(name ~ " (attribute)") %}
      {% endif %}
    {% endfor %}
    {% if params.CALL is defined %}
      RESPOND MSG="{obj|attr(params.CALL)()}"
    {% else %}
      RESPOND MSG="{msg|join('<br>')}"
    {% endif %}
  {% else %}
    RESPOND MSG="no object found named: {obj}"
  {% endif %}


[gcode_macro WAIT_HEAT_SOAK]
variable_duration: 5        # in minutes
variable_threshold_temp: 45 #in °C
gcode:
  {% if printer.heater_bed.temperature <= threshold_temp %}
    HEAT_SOAK_BED
    G4 P{duration * 60 * 1000}
  {% else %}
    RESPOND MSG="skipping heat soak... ({printer.heater_bed.temperature} > {threshold_temp}) "
  {% endif %}

[delayed_gcode _WAIT_HEAT_SOAK]
gcode:
  PRINT_START CONTINUE="True"


[gcode_macro BFS]
description: "A fast, flat, and reliable search for the Klipper object tree. Usage: BFS S=<search> E=<exclude>"
variable_path_color:      "rgb(200,200,200)"
variable_val_color:       "rgb(255,200,50)"
variable_type_color:      "rgb(150,150,150)"
variable_match_color:     "rgb(255,100,150)"
variable_long_limit:      150
variable_max_depth:       10
variable_delimiter:       "°"
variable_timeout:         20 # timeout in seconds
gcode:
    {% set S = params.S|default("")|string %}
    {% if not S %}
        {action_respond_info("BFS Usage: S=<search>°<terms> [E=<exclude>]. Example: BFS S=toolhead°position")}
    {% else %}
        {% set E = params.E|default("")|string %}
        {% set nl = '\n' %}
        {% set search_terms = [] %}{%- for t in (S|lower).split(delimiter) -%}{%- if t -%}{%- set _ = search_terms.append(t) -%}{%- endif -%}{%- endfor -%}
        {% set exclude_terms = [] %}{%- for t in (E|lower).split(delimiter) -%}{%- if t -%}{%- set _ = exclude_terms.append(t) -%}{%- endif -%}{%- endfor -%}

        ; --------------------------------------------------------------------------
        ; STAGE 1: YOUR ORIGINAL, PROVEN SEARCH AND GROUPING LOGIC.
        ; This works. It is left untouched.
        ; --------------------------------------------------------------------------
        {% set queue = namespace(data=[(printer, 'printer')]) %}
        {% set visited = namespace(paths=[]) %}
        {% set results_grouped = namespace(data={}) %}
        {% set total_found = namespace(count=0) %}

        {% set timed = namespace(out=False) %}
        {%- set start_time = printer.printer.reactor.monotonic() -%}
        {% for _ in range(10000) if not timed.out %}
            {% set timed.out = printer.printer.reactor.monotonic() - start_time > timeout %}
            {% if queue.data and total_found.count < 1500 %}
                {% set task = queue.data.pop(0) %}
                {% set current_obj, current_path = task %}

                {% if current_path not in visited.paths %}
                    {% set _ = visited.paths.append(current_path) %}
                    {% set items_to_process = namespace(data=[]) %}
                    {% if current_obj is mapping %}{% for key, value in current_obj.items() %}{% set _ = items_to_process.data.append((key, value)) %}{% endfor %}
                    {% elif current_obj|attr('__dict__') is defined %}{% for key, value in (current_obj|attr('__dict__')).items() %}{% set _ = items_to_process.data.append((key, value)) %}{% endfor %}
                    {% endif %}

                    {% for key, child_obj in items_to_process.data %}
                        {% if not (key|string).startswith('_') %}
                            {% set new_path = current_path ~ '.' ~ key|string %}
                            {% set typ_str = child_obj.__class__.__name__|string %}
                            {% set val_str = "method()" if child_obj is callable else (child_obj|string|e)|truncate(long_limit) %}
                            {% set haystack = (new_path ~ "=" ~ val_str)|lower %}
                            
                            {% set is_excluded = namespace(val=false) %}
                            {% for term in exclude_terms %}{% if term and term in haystack %}{% set is_excluded.val=true %}{% endif %}{% endfor %}
                            
                            {% if not is_excluded.val %}
                                {% set all_found = namespace(val=true) %}
                                {% for term in search_terms %}{% if term not in haystack %}{% set all_found.val=false %}{% endif %}{% endfor %}
                                
                                {% if all_found.val %}
                                    {% set total_found.count = total_found.count + 1 %}
                                    {% if current_path not in results_grouped.data %}{% set _ = results_grouped.data.update({current_path: []}) %}{% endif %}
                                    {% set leaf = {'name': key|string, 'val': val_str, 'typ': typ_str} %}
                                    {% set _ = results_grouped.data[current_path].append(leaf) %}
                                {% endif %}
                            {% endif %}

                            {% if (key != 'printer' and (child_obj is mapping or child_obj|attr('__dict__') is defined)) or loop.first %}
                                {% if (current_path.split('.')|length) < max_depth and new_path not in visited.paths %}
                                    {% set _ = queue.data.append((child_obj, new_path)) %}
                                {% endif %}
                            {% endif %}
                        {% endif %}
                    {% endfor %}
                {% endif %}
            {% endif %}
        {% endfor %}

        ; --------------------------------------------------------------------------
        ; STAGE 2: SIMPLE, FAST, FLAT, SORTED RENDERING.
        ; No recursion, no tree building. Just sorting and printing.
        ; --------------------------------------------------------------------------
        {%- macro highlight(text, terms, color) -%}
            {%- set ns = namespace(current_text=text) -%}
            {%- for term in terms -%}
                {%- if term and term|lower in (ns.current_text)|lower -%}
                    {%- set text_lc = (ns.current_text)|lower -%}
                    {%- set term_lc = term|lower -%}
                    {%- set start = text_lc.find(term_lc) -%}
                    {%- set L = term_lc|length -%}
                    {%- set old_text = ns.current_text -%}
                    {%- set ns.current_text = old_text[:start]~"<span style='background-color:rgba(255,100,150,0.2);color:"~color~";'>"~old_text[start:start+L]~"</span>"~old_text[start+L:] -%}
                {%- endif -%}
            {%- endfor -%}
            {ns.current_text}
        {%- endmacro -%}
        
        {% if total_found.count == 0 %}
            {action_respond_info("BFS: No results found for S='" ~ S ~ "' E='" ~ E ~ "'")}
        {% else %}
            {% set summary = "BFS: Found " ~ total_found.count ~ " results in " ~ (results_grouped.data|length) ~ " objects for S='" ~ S ~ "' E='" ~ E ~ "'" %}
            {% set html = namespace(data="") %}
            
            ; --- Iterate through the PARENT paths, sorted alphabetically to create a visual hierarchy. ---
            {% for path, leaves in results_grouped.data|dictsort %}
                {% set h_path = highlight(path, search_terms, path_color) %}
                
                {% set details_content = namespace(data='') %}
                {% for leaf in leaves|sort(attribute='name') %}
                    {% set h_leaf_name = highlight(leaf.name, search_terms, path_color) %}
                    {% set h_val = highlight(leaf.val, search_terms, val_color) %}
                    {% set leaf_html = "<div style='font-family:monospace;white-space:nowrap;padding-left:15px;'><span style='color:" ~ path_color ~ ";'>" ~ h_leaf_name ~ "</span>=<span style='color:" ~ val_color ~ ";'>" ~ h_val ~ "</span><span style='color:" ~ type_color ~ ";'>(" ~ leaf.typ ~ ")</span></div>" %}
                    {% set details_content.data = details_content.data ~ leaf_html %}
                {% endfor %}
                
                {% set group_html = "<details><summary style='cursor:pointer;'>" ~ h_path ~ " (" ~ (leaves|length) ~ " matches)</summary>" ~ details_content.data ~ "</details>" %}
                {% set html.data = html.data ~ group_html %}
            {% endfor %}

            {action_respond_info(summary ~ nl ~ html.data)}
        {% endif %}
    {% endif %}